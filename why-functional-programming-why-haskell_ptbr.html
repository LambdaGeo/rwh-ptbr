<!DOCTYPE html>
<html lang="pt-br">
<head>
   <meta charset="utf-8"></meta>
	<title>Por quê programação funcional?  Por quê Haskell?</title>
	<link rel="stylesheet" href="support/styles.css" type="text/css">
	
	</head>

	<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div class="navheader"><h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2></div>

<div class="navheader"><table width="100%" summary="Navigation header"><tbody><tr><th colspan="3" align="center">Why functional programming?  Why Haskell?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="getting-started.html">Next</a></td></tr></tbody></table></div>

		
<div  class=preface id=whyfp>
<div class="titlepage"><div><div><h2 class="title">Por quê programação funcional?  Por quê Haskell?</h2></div></div></div>


<h2 class="title" id="id1">Temos uma solução para você!</h2>
	
	<p>
		Haskell é uma linguagem com muitos recursos, e seu aprendizado é uma experiência extremamente gratificante. Vamos nos concentrar em três elementos.  O ”rimeiro é a <em>inovaç“o</em>: nós convidamos você a pensar sobre a programação de uma perspectiva diferente e valiosa. O segundo é o <em>poder</em>: nós vamos mostrar-lhe como criar um software que é curto, rápido e seguro. Por fim, oferecemos-lhe um muita <em>diversão</em>: o prazer de aplicação de soluções de programação elegantes para resolver problemas reais.
	
	</p>


			
	<h3 class="title"  id="id2">Inovadora</h3>
	
	<p>
		Haskell é provavelmente muito diferente do que qualquer linguagem que você já usou antes. Programação funcional nos oferece uma maneira profundamente diferente de pensar sobre softwares.
		</p>

	<p> 
Em Haskell, nós deixamos de enfatizar códigos que modifica dados. Em
vez disso, vamos nos concentrar nas funções que têm valores imutáveis
como entrada e produzem novos valores como saída. Dadas as mesmas
entradas, estas funções sempre retornam os mesmos resultados. Essa é
uma idéia central por trás da programação funcional.
</p>

<p>
Junto com a não modificação de dados, nossas funções Haskell
normalmente, não “dialoga” com o mundo externo, chamamos-as de funções <em>puras</em>.
Nós fazemos uma distinção forte entre o código puro e as partes dos
nossos programas que lêem ou escrevem arquivos, comunicam-se por meio
de conexões de rede, ou fazem mover os braços de um robô. Isso torna
mais fácil organizar, estudar e testar os nossos programas.
</p>

<p>
Abandonamos algumas idéias que podem parecer fundamentais, tais como
ter um <code>for</code> loop incorporadas a linguagem. Temos outras
formas mais flexíveis de executar tarefas repetitivas.
</p>

<p>
Mesmo a maneira pela qual avaliamos as expressões é diferente em
Haskell. Nós adiamos todos os cálculos até que seu resultado seja
realmente necessário: Haskell é uma linguagem que tem avalição <em>preguiçosa</em>.
Esse recurso não é apenas um modo de adiar a avaliação: ela afeta
profundamente a forma como escrevemos os programas. 
</p>


	<h3 class="title"  id="id2">Poderosa</h3>
   <p>
Ao longo deste livro, vamos mostrar a vocês que as alternativas do
Haskell para os recursos de linguagens tradicionais são poderosas,
flexíveis, e levam a códigos mais confiáveis
   </p>

<p>
Como o código puro não pode ter relações com o mundo exterior, e os
dados
que ele trabalha nunca são modificados, é muito raro você ter o tipo de
surpresa desagradável onde uma parte de um código invisível corrompe os
dados utilizados por outro. Qualquer contexto, usamos uma função pura,
ele irá se comportar de forma consistente. 
   </p>

<p>
Código puro é mais fácil de testar que o código que lida com o mundo
exterior. Quando uma função só responde a suas entradas visíveis,
podemos afirmar com facilidade as propriedades do seu comportamento que
deve ser sempre verdadeiro. Podemos testar automaticamente se essas
propriedades se mantem dado um conjunto enorme de entradas aleatórias,
e quando passar em nossos testes, podemos seguir em frente acoplando
essa função ao sistema como todo. Temos ainda a utilização de técnicas
tradicionais para testar o código que deve interagir com arquivos,
redes, hardware ou exóticos. Desde há muito menos deste código impura
do que se poderia encontrar em uma linguagem tradicional, nós temos
muito mais segurança que o nosso software é consistente.
   </p>

<p>
Avaliação
preguiçosa tem alguns efeitos assustadores. Vamos dizer que queremos
encontrar as <em>k</em> menores elementos em uma lista não
ordenada. Em uma linguagem tradicional, a abordagem óbvia seria a de
ordenar a lista em primeiro lugar e tirar os <em>k</em>&nbsp; elementos , mas
isso é caro. Para maior eficiência, teríamos, ao invés disso escrever uma função especial que encontra esses valores em uma
única passagem, e para isso teria que realizar algumas complexas alterações. Em Haskell, a abordagem sort-then-take
realmente funciona bem: a avaliação preguiçosa garante que a lista só
será classificada o suficiente para encontrar os <em>k</em> elementos
mínimos. 
   </p>
<p>
Melhor ainda, o nosso código Haskell, que opera de forma tão eficiente
é minúsculo e usa funções da biblioteca padrão
</p>

<pre id="KMinima.hs:minima" class="programlisting">-- file: ch00/KMinima.hs
-- lines beginning with "--" are comments.

minima k xs = take k (sort xs)</pre>

<p>
Pode demorar um pouco para desenvolver uma percepção intuitiva para
quando a avaliação preguiçosa é importante, mas quando nós
exploramos-na, o código resultante é limpo, pequeno e eficiente. 
</p>

<p>

Como mostra o exemplo acima, um aspecto importante do poder Haskell
reside na compactação do código que escrevemos. Comparado a trabalhar
em linguagens populares tradicionais, quando se desenvolver em Haskell,
muitas vezes, escrevemos muito menos código, em menos tempo, e
substancialmente com menos erros. 

</p>


<h3 class="title"  id=“iddivertida”>Divertida</h3>

<p>
Como a programação efetiva em Haskell é muito diferente de outras
linguagens, você deve esperar que dominar tanto a linguagem quanto as
técnicas de programação funcional exigirá muita dedicação e prática.
</p>

<p>
Remontando aos nossos dias de começando com Haskell, a boa notícia é
que a diversão começa cedo: é simplesmente um desafio agradável a
desbravar essa nova linguagem, em que tantas idéias comuns são
diferentes ou ausentes, e para descobrir como escrever programas
simples. 
</p>

<p>
Para nós, o prazer inicial durou a nossa experiência cresceu e
aprofundou nossa compreensão. Em outras linguagens, é difícil ver
qualquer conexão entre a ciência e as porcas e parafusos, da
programação. Em Haskell, temos algumas idéias importadas da matemática
abstrata e colocá-los para funcionar. Mesmo que nós achamos que estas
idéias não fáceis de aprender, elas têm um retorno prático para nos
ajudar a escrever códigos mais compacto e reutilizável.
</p>

<p>
Além disso, não vamos estar colocando qualquer pedra em seu caminho:
não há particularmente nenhuma técnica difícil neste livro que você
deverá dominar a fim de poder programar de forma eficaz.
</p>

<p> 
Dito isto, Haskell é uma linguagem rigorosa:
ela vai exigir mais do seu raciocínio daqui para frente. Pode demorar
um pouco para conseguir executar o seu primeiro código, com o
compilador dizendo que o seu programa não faz sentido. Mesmo com anos
de experiência, ficamos surpresos e satisfeitos pela forma como muitas
vezes os nossos programas Haskell simplesmente funcionam na primeira
tentativa, uma vez que corrigimos esses erros de compilação.
</p>


<h2 class=“title” id=“id12”>O que esperar deste livro</h2>

<p> 
Começamos este projeto porque um número crescente de pessoas estão
usando Haskell para resolver problemas cotidianos. Porque Haskell tem
suas raízes na academia, pouco dos livros que existem atualmente sobre
Haskell focam sobre problemas e técnicas de programação do dia a dia
que estamos interessado.
</p>

<p> 
Com este livro queremos
mostrar como usar a programação funcional e Haskell para resolver
problemas reais. Este é um livro de referência: cada capítulo contém
dezenas de exemplos de código, e muitos contêm aplicações completas.
Aqui estão alguns exemplos das bibliotecas, técnicas e ferramentas que
nós vamos mostrar-lhe como desenvolver.
</p>

<ul type="disc">
  <li>
Criar um aplicativo que
baixa os episódios de podcast da internet e armazene-o em um
banco de dados SQL
</li>

 <li>
Testar o seu código de um modo poderosa e
intuitiva. Descrever as propriedades que devem ser
verdade, então deixe a biblioteca QuickCheck gerar casos de teste
automaticamente. 
</li>

 <li>
Pegar um telefone com câmera que captura um
código de barras, e transforme-o
em um identificador que você pode usar para consulta uma biblioteca ou
web site de uma libraria. 
</li>

 <li>
Escrever o código que
percorra a web. Troque dados com os servidores e clientes escritos
em
outras linguagens usando a notação JSON. Desenvolver um verificador da
ligação concorrente. 
</li>
</ul>

<h3 class="title"  id=“”>Um pouco sobre você</h3>

<p>
O que você precisa saber antes de ler este livro? Esperamos que você já
saiba programar, mas se você nunca usou uma linguagem funcional, tudo
bem. 
</p>

<p>
Não importa o seu nível de experiência, temos tentado antecipar suas
necessidades: para explicar novas idéias em profundidade, geralmente
usamos exemplos e imagens para conduzir nossas questões.
</p>

<p>
Como um novo programador Haskell, você vai inevitavelmente começar a
escrever alguns códigos a mão onde você poderia ter utilizado uma
função de alguma biblioteca ou alguma técnica de programação. Nos
empacotamos este livro com informações para ajudá-lo a aprender o mais
rapido possível. 
</p>

<p>
Claro, sempre haverá alguns solavancos ao longo da estrada. Se você
começar a antecipar uma surpresa ocasional ou dificuldade, juntamente
com a diversão, você terá a melhor experiência. Qualquer remendos
ásperos você pode bater, não vai durar muito.
</p>

<p>
Como se tornar um programador mais experiente Haskell, a maneira que
você escrever código irá mudar. Com efeito, ao longo deste livro, a
forma que apresentamos código irá evoluir, como nos movemos desde o
básico da língua até técnicas e recursos poderosos e produtivos.
</p>

<h2 class=“title” id=“”>O que esperar do Haskell</h2>
<p>
Haskell é uma linguagem de programação de propósito geral. Foi
concebido sem qualquer nicho de aplicação em mente. Embora ela tenha
uma posição firme sobre como os programas devem ser escritos, não
favoreça um domínio do problema em detrimento de outros. 
</p>

<p>
Embora em sua essência, a linguagem encoraja um estilo
de programação funcional pura e não estrita, esse é o <em>padrão</em>,
e não a única opção.
Haskell também suporta as mais tradicionais modelos de códigos
processuais e avaliação rigorosa. Além disso, embora o foco da
linguagem está centrado na escrita de programas estaticamente tipados,
é possível (embora raramente) escrever código Haskell usando tipos
dinâmicos. 
</p>

<h3 class="title"  id=“”>Comparado com as linguagens estáticas
tradicionais</h3>

<p>
Linguagens que somente usam sistemas do tipo estático foram o
esteio do mundo da programação durante décadas. Haskell é estaticamente
tipados, mas a sua noção do que tipos são, e o que podemos fazer
com eles, é muito mais flexível e poderoso do que nas linguagens
tradicionais. Tipos dão uma contribuição importante para a concisão,
clareza e eficiência dos programas Haskell. 
</p>

<p>
Apesar de poderosa, o sistema de tipos do haskell é muitas vezes também
discreto. Se omitir informações de tipos explícito, um compilador
Haskell automaticamente inferirá o tipo de uma expressão ou função.
Comparado com as linguagens tradicionais estáticas, a que devemos
prover grandes quantidades de informações sobre o tipo, a
combinação do poder e a inferência do sistema de tipos em Haskell reduz
significativamente a desorganização e a redundância do nosso código. <
</p>

<p>
Vários outros recursos de Haskell se combinam para aumentar a
quantidade de trabalho que pode caber em uma tela de texto. Isto traz
melhorias no desenvolvimento do tempo e agilidade: podemos criar um
código de confiança rapidamente e facilmente refatorar em resposta a
novas exigências. 
</p>

<p>
Às vezes, os programas Haskell pode funcionar mais lentamente do que os
programas similares escrito em C ou C + +. Para a maioria do código que
escrevemos, as grandes vantagens do Haskell de produtividade e
confiabilidade superam qualquer desvantagem no desempenho de pequeno
porte. 
</p>

<p>
Os processadores multicore estão
onipresentes, mas eles permanecem extremamente difícil para o programa
com técnicas tradicionais. Haskell oferece tecnologias exclusivas para
tornar a programação multicore mais tratáveis. Ele oferece suporte a
programação paralela, o software de memória transacional para a
simultaneidade de confiança, e escalas de centenas de milhares de
threads em simultâneo.
</p>



<h3 class="title"  id=“”> Comparado com as linguagens dinâmicas
modernas </h3>
<p>
Durante a última década, linguagens interpretada e dinamicamente tipada
se
tornaram cada vez mais popular. Elas oferecem benefícios substanciais
na produtividade do desenvolvedor. Embora estas muitas vezes vem à
custa
de um enorme impacto na performance, para muitas a produtividade nas
tarefas de programação prevalece sobre o desempenho, ou o desempenho
não é o fator
mais importante de qualquer modo. 
</p>

<p>
Concisão é uma área em que Haskell e linguagens com tipagem dinâmica
executam de forma semelhante: em cada caso, escrevemos muito menos
código para resolver um problema do que em uma linguagem tradicional.
Programas ficam muitas vezes em torno do mesmo tamanho em linguagens
dinâmicamente tipadas e Haskell.
</p>

<p>
Quando se considera o desempenho de execução, Haskell quase sempre tem
uma enorme vantagem. Código compilado pelo Glasgow Haskell Compiler
(GHC) ficam normalmente entre 20 e 60 vezes mais rápido do que o
executado em um interpretador de uma linguagem dinâmicamente tipada.
GHC também fornece
um intérprete, assim você pode executar scripts sem compilá-los.
</p>

<p>
Outra grande diferença entre as linguagens dinâmicamente tipadas e
Haskell
reside na sua filosofia em torno de tipos. Um dos principais motivos
para a popularidade de linguagens dinâmicamente tipadas é que raramente
precisamos mencionar explicitamente os tipos. Através da inferência de
tipo automático, Haskell oferece a mesma vantagem.
</p>

<p>
Para além desta semelhança superficial, as diferenças são profundas. Em
uma linguagem dinamicamente tipada, podemos criar construções que são
difíceis de expressar em uma linguagem estaticamente tipada. No
entanto, o mesmo acontece em sentido inverso: com um tipo de sistema
tão poderosa como o do Haskell, podemos estruturar um programa de uma
forma
que seria impossível ou inviável em linguagens de tipagem dinâmica. 
</p>

<p>
É importante reconhecer que cada uma dessas abordagens envolve
tradeoffs. Muito brevemente, é
a escolha entre a perspectiva de segurança que Haskell
enfatiza, e a perspectiva de flexibilidade que a tipagem dinâmica&nbsp;
favorece. Se alguém já havia descoberto uma maneira de pensar
sobre os tipos de que foi sempre melhor, imaginamos que todos soubessem
sobre ela até agora. 
</p>
Claro, temos nossas próprias opiniões sobre quais vantagens e
desvantagens, são mais benéficas. Dois de nós têm anos de experiência
em programação em linguagens dinâmicamente tipadas. Nós adoramos
trabalhar
com elas, nós ainda usamos todos os dias, mas geralmente, nós
preferimos Haskell. 
<p>

</p>


<h3 class="title"  id=“”>Haskell na indústria e código aberto
</h3>
<p>
Aqui estão apenas alguns exemplos de grandes sistemas de software que
tenham sido criados em Haskell. Alguns deles são de código aberto,
enquanto outros são produtos patenteados.
</p>

<ul type="disc">
  <li>
ASIC e FPGA design software (Lava, produtos da
Bluespec Inc.) 
</li>
  <li>
Software de composição musical (Haskore)
</li>
  <li>
Compiladores e ferramentas relacionadas com
compilador (principalmente GHC)
</li>
  <li>
Controle de distribuição e revisão (Darcs)
</li>
  <li>
Web middleware (Happstack, produtos de Galois
Inc.) 
</li>
  <li>
ABN AMRO é um banco internacional. Ele usa
Haskell em investimentos, para medir o risco de contraparte de
carteiras de derivativos financeiros. 
</li>
  <li>
 Anygma é uma empresa de inicialização.
Desenvolve ferramentas de criação multimídia conteúdo usando Haskell.
</li>
  <li>
Amgen é uma empresa de biotecnologia. Ele
cria modelos matemáticos e outras aplicações complexas em Haskell.
</li>
  <li>
Bluespec é um ASIC e FPGA fornecedor de
software de design. Seus produtos são desenvolvidos em Haskell, e as
Linguagens de design de chips que fornecem seus produtos são
influenciados pelo Haskell.
</li>
  <li>
Eaton utiliza Haskell para a concepção e
verificação de sistemas hidráulicos de veículos híbridos.
</li>
</ul>


<h3 class="title"  id=“”>Compilação, depuração e análise de desempenho
</h3>

<p>
Para o trabalho prático, quase tão importante como a própria linguagem
é o "ecossistema" de bibliotecas e ferramentas à sua volta. Haskell tem
uma forte presença nesta área. 
</p>

<p>
O compilador mais utilizado, GHC, foi ativamente desenvolvida por mais
de 15 anos, e fornece um conjunto maduro e estável de recursos.
</p>
<ul type="disc">
<li>
Compila para código nativo eficiente em todos
os principais sistemas operacionais modernos e arquiteturas de CPU
</li>
<li>
Fácil implantação dos binários compilados,
livre de restrições de licenciamento
</li>
<li>
Análise da cobertura de código
</li>
<li>
Detalhado perfis de desempenho e uso de
memória 
</li>
<li>
Documentação completa
</li>
<li>
Apoio escalável e massivo para multicore e
programação concorrente 
</li>
<li>
Interpretador e depurador interativo 
</li>

</ul>


<h3 class="title"  id=“”>Bibliotecas bundled e a terceira parte</h3>

<p>
O compilador GHC vem com uma coleção de bibliotecas úteis. Aqui
estão algumas das necessidades comuns de programação que as bibliotecas
face a estes. 
</p>

<ul type="disc">
  <li>
I/O arquivo, e de passagem e manipulação de
sistema de arquivos 
</li>
  <li>
Programação de cliente e servidor de rede 
</li>
  <li>
Expressões regulares e análise sintática
</li>
  <li>
Programação concorrente 
</li>
  <li>
Testes automatizados
</li>
  <li>
Som e gráficos 
</li>
</ul>
<p>
O banco de dados do pacote Hackage é uma coleção de
bibliotecas de código aberto e aplicações da comunidade Haskell. A
maioria das bibliotecas
publicado em Hackage são licenciados sob os termos que permitem tanto o
uso como código aberto e comercial. Algumas das áreas
abrangidas pelas bibliotecas de código aberto incluem o seguinte.
</p>
<ul type="disc">
  <li>
Interfaces para todas as principais banco de dados open source
e comercial.
</li>
  <li>
Processamento de XML, HTML e XQuery 	
</li>
  <li>
Desenvolvimento de cliente e servidor de redes
e web
</li>
  <li>
GUIs Desktop, incluindo toolkits
e cross-platform 
</li>
  <li>
Suporte para Unicode e outras codificações de
texto
</li>
</ul>


<h2 class=“title” id=“”>Um breve resumo da
história do Haskell</h2>

<p>O desenvolvimento de Haskell está
enraizada na matemática e na pesquisa de ciência da computação. 
</p>


<h3 class="title"  id=“”>Pré-História</h3>
<p>
Algumas décadas antes dos computadores
modernos serem inventados, o
matemático Alonzo Church desenvolveu uma linguagem chamada de cálculo
lambda. Ela destina-se como uma ferramenta para investigar os
fundamentos da matemática. A primeira pessoa a perceber a conexão entre
práticas de programação e cálculo lambda foi John McCarthy, que criou
Lisp em 1958.
</p>
<p>
Durante os anos 1960, cientistas da
computação começaram a reconhecer e
estudar a importância do cálculo lambda. Peter Landin e Christopher
Strachey desenvolveu idéias sobre os fundamentos das linguagens de
programação: sobre como entender o que eles fazem (semântica
operacional) e como entender o que eles significam (semântica
denotational). 
</p>
<p>
No início dos anos 1970, Robin Milner
criou um linguagem de programação
funcional mais rigorosa, chamado ML. Embora ML foi desenvolvida para
ajudar com provas automatizada de teoremas matemáticos, acabou ganhando
uma sequência de outras tarefas de computação em geral. 
</p>
<p>
A década de 1970 viu o surgimento da
avaliação preguiçosa (ou função não-estrita) como uma nova
estratégia. David Turner desenvolveu SASL e KRC, enquanto Rod Burstall
e John Darlington desenvolvido NPL e Hope. NPL, KRC e ML influenciaram
o desenvolvimento de várias outras linguagens na década de 1980,
incluindo Lazy ML, Clean e Miranda.
</p>


<h3 class="title"  id=“”>História recente</h3>

<p>
Até o final dos anos 1980, os esforços
dos investigadores que trabalham
sobre avaliação preguiçosa em linguagens funcionais estavam espalhados
por mais de uma dezena de Linguagens. Preocupados com essa difusão de
esforço, um número de investigadores decidiram formar uma comissão para
criar uma linguagem comum. Após três anos de trabalho, a comissão
publicou a especificação 1.0 do Haskell em 1990. É o nomearam a
linguagem depois em homenagem a Haskell Curry, um influente lógico.
</p>

<p>
 Muitas pessoas são realmente suspeitas
de falar sobre “<span class="quote">design by committee</span>”,
mas o trabalho da comissão do Haskell é um belo exemplo dos melhores
trabalhos que uma comissão pode fazer. Eles produziram um elegante
projeto de linguagem, e conseguiu unificar os esforços divididos da sua
comunidade de pesquisa. Do emaranhado de linguagens funcionais com
avaliação preguiçosa que existia em 1990, apenas Haskell ainda é
ativamente usada
</p>

<p>
Desde a sua publicação em 1990, o
padrão de linguagem Haskell passou por cinco
revisões, a mais recente em 1998. Um número de implementações de
Haskell foram escritas e várias ainda estão ativamente em
desenvolvimento.
</p>

<p>
Durante a década de 1990, Haskell teve dois objetivos principais. De um
lado, ele dava pesquisadores de linguagem uma linguagem estável em que
podia experimentar como a avalição preguiçosa podia fazer programas
funcionais executar eficientemente. Outros pesquisadores exploraram
como construir programas usando técnicas baseados em avaliação
preguiçosa funcional. Outros ainda usaram como linguagem de ensino.
</p>


<h3 class="title"  id=“”>A era moderna</h3>

<p>
Embora estas explorações básica da década de 1990 prosseguiram, Haskell
permaneceu firme como um assunto acadêmico. O slogan informal de quem
estava dentro da comunidade era “evitar o sucesso a todo custo”. Poucos
fora dessa comunidade tinham ouvido falar da linguagem. Desse
modo,&nbsp; a programação funcional, ficou como um campo bastante
obscuro.
</p>

<p>
Durante este tempo o mainstream mundo da programação experimentava com
pequenos ajustes relativamente: a partir de programação em C, até C +
+, até Java. Enquanto isso, na periferia, os programadores estavam
começando a mexer com o novo, linguagens mais dinâmicas. Guido van
Rossum projetou Python, Larry Wall criou Perl e Yukihiro Matsumoto
desenvolveu Ruby.
</p>

<p>
Como essas novas linguagens começaram a infiltrar-se em uma utilização
mais ampla, elas espalharam algumas idéias fundamentais. O primeiro foi
que os programadores não estavam plenamente trabalhando em linguagens
expressivas. A segunda foi, em parte, um subproduto do rápido
crescimento no poder computacional da época: muitas vezes é inteligente
sacrificar algum desempenho de execução, em troca de um grande aumento
na produtividade do programador. Finalmente, várias dessas linguagens
emprestaram algo da programação funcional.
</p>

<p>
Durante a última metade da década passada, Haskell conseguiu escapar da
academia, impulsionado em parte pela visibilidade do Python, Ruby e até
Javascript. A linguagem agora tem um&nbsp; rápido e vibrante
crescimento na cultura dos usuários open source e comercial, e os
pesquisadores continuam a usá-lo para aumentar os limites de desempenho
e expressividade.
</p>


<h2 class=“title” id=“”>Recursos úteis</h2>

<p>
A medida que você trabalhar com Haskell, com certeza terá dúvidas e irá
querer mais informações sobre as coisas. Aqui estão alguns recursos da
Internet onde você pode buscar informações e interagir com outros
programadores Haskell. 
</p>


<h3 class="title"  id=“”>Material de referência</h3>
<ul type="disc">
  <li>
<a class="ulink" href="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html" target="_top">The Haskell Hierarchical Libraries reference</a> fornece
a documentação para a biblioteca padrão que vem com o compilador. Este
é um dos mais valiosos activos online para programadores Haskell. 
 </li>
  <li>
Para perguntas sobre a sintaxe e recursos da
linguage o <a href="http://haskell.org/onlinereport/" target="_top">Haskell
98 Report</a> descreve ao padrão da linguagem Haskell 98.
 </li>
  <li>
Diversas extensões à linguagem tornaram-se
comuns desde o Haskell 98 Report foi liberado. O <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html" target="_top">Guia do usuário do GHC</a> contém documentação detalhada
sobre as extensões suportadas pelo GHC, bem como algumas
características específicas do GHC.
 </li>
  <li>
<a href="http://haskell.org/hoogle/" target="_top">Hoogle</a> e <a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_top">Hayoo</a>
são os motores de busca da API Haskell. Eles podem procurar as funções
pelo nome ou por tipo. 
 </li>
</ul>

<h3 class="title"  id=“”> Aplicativos e bibliotecas</h3>
<p>
Se você está procurando uma biblioteca Haskell a ser usado para uma
tarefa específica, ou de um pedido escrito em Haskell, confira os
seguintes recursos.
</p>
<ul type="disc">
  <li>
A comunidade Haskell mantém um repositório
central de bibliotecas de código aberto e aplicações Haskell. É chamado
    <a href="http://hackage.haskell.org/" target="_top">Hackage</a>, e
permite que você procure software para download, ou procurar a sua
coleção por categoria.
 </li>
  <li>
O <a href="http://haskell.org/haskellwiki/Applications_and_libraries" target="_top">Haskell Wiki</a> contém uma seção dedicada à informação
sobre algumas bibliotecas Haskell.
 </li>

</ul>


<h3 class="title"  id=“”>A comunidade Haskell</h3>
<p>Há uma série de maneiras que você pode entrar em contato com outros
programadores Haskell, fazer perguntas, saber o que outras pessoas
estão falando, e simplesmente fazer alguma rede social com seus pares.</p>
<ul type="disc">
  <li>
A primeira parada em sua busca por recursos da
comunidade deve ser o <a href="http://www.haskell.org/" target="_top">site
Haskell</a>. Esta página contém os links mais atuais para várias
comunidades e informação, bem como um wiki e mantida ativamente.
 </li>
  <li>
Haskellers utilizar uma série de <a href="http://haskell.org/haskellwiki/Mailing_lists" target="_top">listas</a>
para os debates de atualidade. Destes, o geralmente mais interessante é
chamado <code>haskell-cafe</code>. Tem uma atmosfera tranquila e
amigável, onde profissionais e acadêmicos trocam informações com
hackers casuais e novatos. 
 </li>
  <li>
Para bate-papo em tempo real, o <a href="http://haskell.org/haskellwiki/IRC_channel" target="_top">canal
de IRC Haskell</a>, chamado <code>#haskell</code>, é grande e animado.
Parecido como o <code>haskell-cafe</code>, a atmosfera e amigável e
prestativos, apesar do grande número de usuários simultâneos.
 </li>
  <li>
 Há muitos grupos de usuários locais, meetups,
workshops acadêmicos, e assim por diante, aqui está <a href="http://haskell.org/haskellwiki/User_groups" target="_top">uma
lista dos grupos de usuários conhecidos e workshops</a>.
 </li>
<li>
O <a href="http://sequence.complete.org/" target="_top">Haskell Weekly News</a> é um-quase-resumo semanal de
muitas atividades na comunidade Haskell. Você pode encontrar links para
listas de discussões interessantes, novas versões de softwares, e assim
por diante.
</li>
<li>
<a class="ulink" href="http://haskell.org/communities/" target="_top">Haskell
Communities and Activities Report</a> recolhe informações sobre as
pessoas que usam Haskell, e o que eles estão fazendo com ele. Ela tem
funcionada durante anos, por isso oferece uma boa maneira de descobrir
o passado do Haskell. 
</li>
</ul>

<h2 class=“title” id=“”> Agradecimentos </h2>



				
</div>

<footer> 
<p>Copyright
	2007, 2008 Bryan O'Sullivan, Don Stewart, and John Goerzen. This
	work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
	  Commons Attribution-Noncommercial 3.0 License</a>. Icons by
	  <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.</p>
	


<div class="navfooter"><table width="100%" summary="Navigation footer"><tbody><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="getting-started.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Real World Haskell&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;1.&nbsp;Getting Started</td></tr></tbody></table>
	
</footer>


</body>	
</html>
