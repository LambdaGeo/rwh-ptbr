<!DOCTYPE html>
<html lang="pt-br">
   <head>
      <meta charset="utf-8">
      </meta>
      <title>Por quê programação funcional?  Por quê Haskell?</title>
      <link rel="stylesheet" href="support/styles.css" type="text/css">
   </head>
   <body >
      <header>
         <h2 class="booktitle"><a href="index.html">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2>
         <a accesskey="p" style="float:left" href="index.html">Anterior</a>
         <a  href="getting-started_ptbr.html" style="float:right">Próximo</a>
         <p style="text-align:center"><a accesskey="p"  href="index.html">Inicio</a></p>
      </header>
      <article id=whyfp>
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title">Por quê programação funcional?  Por quê Haskell?</h2>
               </div>
            </div>
         </div>
         <h2 class="title" id="id1">Temos uma solução para você!</h2>
         <p>
            Haskell é uma linguagem com muitos recursos, e seu aprendizado é uma experiência extremamente gratificante. Vamos nos concentrar em três elementos.  O ”rimeiro é a <em>inovaç“o</em>: nós convidamos você a pensar sobre a programação de uma perspectiva diferente e valiosa. O segundo é o <em>poder</em>: nós vamos mostrar-lhe como criar um software que é curto, rápido e seguro. Por fim, oferecemos-lhe um muita <em>diversão</em>: o prazer de aplicação de soluções de programação elegantes para resolver problemas reais.
         </p>
         <h3 class="title"  id="id2">Inovadora</h3>
         <p>
            Haskell é provavelmente muito diferente do que qualquer linguagem que você já usou antes. Programação funcional nos oferece uma maneira profundamente diferente de pensar sobre softwares.
         </p>
         <p> 
            Em Haskell, nós deixamos de enfatizar códigos que modifica dados. Em
            vez disso, vamos nos concentrar nas funções que têm valores imutáveis
            como entrada e produzem novos valores como saída. Dadas as mesmas
            entradas, estas funções sempre retornam os mesmos resultados. Essa é
            uma idéia central por trás da programação funcional.
         </p>
         <p>
            Junto com a não modificação de dados, nossas funções Haskell
            normalmente, não “dialoga” com o mundo externo, chamamos-as de funções <em>puras</em>.
            Nós fazemos uma distinção forte entre o código puro e as partes dos
            nossos programas que lêem ou escrevem arquivos, comunicam-se por meio
            de conexões de rede, ou fazem mover os braços de um robô. Isso torna
            mais fácil organizar, estudar e testar os nossos programas.
         </p>
         <p>
            Abandonamos algumas idéias que podem parecer fundamentais, tais como
            ter um <code>for</code> loop incorporadas a linguagem. Temos outras
            formas mais flexíveis de executar tarefas repetitivas.
         </p>
         <p>
            Mesmo a maneira pela qual avaliamos as expressões é diferente em
            Haskell. Nós adiamos todos os cálculos até que seu resultado seja
            realmente necessário: Haskell é uma linguagem que tem avalição <em>preguiçosa</em>.
            Esse recurso não é apenas um modo de adiar a avaliação: ela afeta
            profundamente a forma como escrevemos os programas. 
         </p>
         <h3 class="title"  id="id2">Poderosa</h3>
         <p>
            Ao longo deste livro, vamos mostrar a vocês que as alternativas do
            Haskell para os recursos de linguagens tradicionais são poderosas,
            flexíveis, e levam a códigos mais confiáveis
         </p>
         <p>
            Como o código puro não pode ter relações com o mundo exterior, e os
            dados
            que ele trabalha nunca são modificados, é muito raro você ter o tipo de
            surpresa desagradável onde uma parte de um código invisível corrompe os
            dados utilizados por outro. Qualquer contexto, usamos uma função pura,
            ele irá se comportar de forma consistente. 
         </p>
         <p>
            Código puro é mais fácil de testar que o código que lida com o mundo
            exterior. Quando uma função só responde a suas entradas visíveis,
            podemos afirmar com facilidade as propriedades do seu comportamento que
            deve ser sempre verdadeiro. Podemos testar automaticamente se essas
            propriedades se mantem dado um conjunto enorme de entradas aleatórias,
            e quando passar em nossos testes, podemos seguir em frente acoplando
            essa função ao sistema como todo. Temos ainda a utilização de técnicas
            tradicionais para testar o código que deve interagir com arquivos,
            redes, hardware ou exóticos. Desde há muito menos deste código impura
            do que se poderia encontrar em uma linguagem tradicional, nós temos
            muito mais segurança que o nosso software é consistente.
         </p>
         <p>
            Avaliação
            preguiçosa tem alguns efeitos assustadores. Vamos dizer que queremos
            encontrar as <em>k</em> menores elementos em uma lista não
            ordenada. Em uma linguagem tradicional, a abordagem óbvia seria a de
            ordenar a lista em primeiro lugar e tirar os <em>k</em>&nbsp; elementos , mas
            isso é caro. Para maior eficiência, teríamos, ao invés disso escrever uma função especial que encontra esses valores em uma
            única passagem, e para isso teria que realizar algumas complexas alterações. Em Haskell, a abordagem sort-then-take
            realmente funciona bem: a avaliação preguiçosa garante que a lista só
            será classificada o suficiente para encontrar os <em>k</em> elementos
            mínimos. 
         </p>
         <p>
            Melhor ainda, o nosso código Haskell, que opera de forma tão eficiente
            é minúsculo e usa funções da biblioteca padrão
         </p>
         <pre id="KMinima.hs:minima" class="programlisting">-- file: ch00/KMinima.hs
-- lines beginning with "--" are comments.

minima k xs = take k (sort xs)</pre>
         <p>
            Pode demorar um pouco para desenvolver uma percepção intuitiva para
            quando a avaliação preguiçosa é importante, mas quando nós
            exploramos-na, o código resultante é limpo, pequeno e eficiente. 
         </p>
         <p>
            Como mostra o exemplo acima, um aspecto importante do poder Haskell
            reside na compactação do código que escrevemos. Comparado a trabalhar
            em linguagens populares tradicionais, quando se desenvolver em Haskell,
            muitas vezes, escrevemos muito menos código, em menos tempo, e
            substancialmente com menos erros. 
         </p>
         <h3 class="title"  id=“iddivertida”>Divertida</h3>
         <p>
            Como a programação efetiva em Haskell é muito diferente de outras
            linguagens, você deve esperar que dominar tanto a linguagem quanto as
            técnicas de programação funcional exigirá muita dedicação e prática.
         </p>
         <p>
            Remontando aos nossos dias de começando com Haskell, a boa notícia é
            que a diversão começa cedo: é simplesmente um desafio agradável a
            desbravar essa nova linguagem, em que tantas idéias comuns são
            diferentes ou ausentes, e para descobrir como escrever programas
            simples. 
         </p>
         <p>
            Para nós, o prazer inicial durou a nossa experiência cresceu e
            aprofundou nossa compreensão. Em outras linguagens, é difícil ver
            qualquer conexão entre a ciência e as porcas e parafusos, da
            programação. Em Haskell, temos algumas idéias importadas da matemática
            abstrata e colocá-los para funcionar. Mesmo que nós achamos que estas
            idéias não fáceis de aprender, elas têm um retorno prático para nos
            ajudar a escrever códigos mais compacto e reutilizável.
         </p>
         <p>
            Além disso, não vamos estar colocando qualquer pedra em seu caminho:
            não há particularmente nenhuma técnica difícil neste livro que você
            deverá dominar a fim de poder programar de forma eficaz.
         </p>
         <p> 
            Dito isto, Haskell é uma linguagem rigorosa:
            ela vai exigir mais do seu raciocínio daqui para frente. Pode demorar
            um pouco para conseguir executar o seu primeiro código, com o
            compilador dizendo que o seu programa não faz sentido. Mesmo com anos
            de experiência, ficamos surpresos e satisfeitos pela forma como muitas
            vezes os nossos programas Haskell simplesmente funcionam na primeira
            tentativa, uma vez que corrigimos esses erros de compilação.
         </p>
         <h2 class=“title” id=“id12”>O que esperar deste livro</h2>
         <p> 
            Começamos este projeto porque um número crescente de pessoas estão
            usando Haskell para resolver problemas cotidianos. Porque Haskell tem
            suas raízes na academia, pouco dos livros que existem atualmente sobre
            Haskell focam sobre problemas e técnicas de programação do dia a dia
            que estamos interessado.
         </p>
         <p> 
            Com este livro queremos
            mostrar como usar a programação funcional e Haskell para resolver
            problemas reais. Este é um livro de referência: cada capítulo contém
            dezenas de exemplos de código, e muitos contêm aplicações completas.
            Aqui estão alguns exemplos das bibliotecas, técnicas e ferramentas que
            nós vamos mostrar-lhe como desenvolver.
         </p>
         <ul type="disc">
            <li>
               Criar um aplicativo que
               baixa os episódios de podcast da internet e armazene-o em um
               banco de dados SQL
            </li>
            <li>
               Testar o seu código de um modo poderosa e
               intuitiva. Descrever as propriedades que devem ser
               verdade, então deixe a biblioteca QuickCheck gerar casos de teste
               automaticamente. 
            </li>
            <li>
               Pegar um telefone com câmera que captura um
               código de barras, e transforme-o
               em um identificador que você pode usar para consulta uma biblioteca ou
               web site de uma libraria. 
            </li>
            <li>
               Escrever o código que
               percorra a web. Troque dados com os servidores e clientes escritos
               em
               outras linguagens usando a notação JSON. Desenvolver um verificador da
               ligação concorrente. 
            </li>
         </ul>
         <h3 class="title"  id=“”>Um pouco sobre você</h3>
         <p>
            O que você precisa saber antes de ler este livro? Esperamos que você já
            saiba programar, mas se você nunca usou uma linguagem funcional, tudo
            bem. 
         </p>
         <p>
            Não importa o seu nível de experiência, temos tentado antecipar suas
            necessidades: para explicar novas idéias em profundidade, geralmente
            usamos exemplos e imagens para conduzir nossas questões.
         </p>
         <p>
            Como um novo programador Haskell, você vai inevitavelmente começar a
            escrever alguns códigos a mão onde você poderia ter utilizado uma
            função de alguma biblioteca ou alguma técnica de programação. Nos
            empacotamos este livro com informações para ajudá-lo a aprender o mais
            rapido possível. 
         </p>
         <p>
            Claro, sempre haverá alguns solavancos ao longo da estrada. Se você
            começar a antecipar uma surpresa ocasional ou dificuldade, juntamente
            com a diversão, você terá a melhor experiência. Qualquer remendos
            ásperos você pode bater, não vai durar muito.
         </p>
         <p>
            Como se tornar um programador mais experiente Haskell, a maneira que
            você escrever código irá mudar. Com efeito, ao longo deste livro, a
            forma que apresentamos código irá evoluir, como nos movemos desde o
            básico da língua até técnicas e recursos poderosos e produtivos.
         </p>
         <h2 class=“title” id=“”>O que esperar do Haskell</h2>
         <p>
            Haskell é uma linguagem de programação de propósito geral. Foi
            concebido sem qualquer nicho de aplicação em mente. Embora ela tenha
            uma posição firme sobre como os programas devem ser escritos, não
            favoreça um domínio do problema em detrimento de outros. 
         </p>
         <p>
            Embora em sua essência, a linguagem encoraja um estilo
            de programação funcional pura e não estrita, esse é o <em>padrão</em>,
            e não a única opção.
            Haskell também suporta as mais tradicionais modelos de códigos
            processuais e avaliação rigorosa. Além disso, embora o foco da
            linguagem está centrado na escrita de programas estaticamente tipados,
            é possível (embora raramente) escrever código Haskell usando tipos
            dinâmicos. 
         </p>
         <h3 class="title"  id=“”>Comparado com as linguagens estáticas
            tradicionais
         </h3>
         <p>
            Linguagens que somente usam sistemas do tipo estático foram o
            esteio do mundo da programação durante décadas. Haskell é estaticamente
            tipados, mas a sua noção do que tipos são, e o que podemos fazer
            com eles, é muito mais flexível e poderoso do que nas linguagens
            tradicionais. Tipos dão uma contribuição importante para a concisão,
            clareza e eficiência dos programas Haskell. 
         </p>
         <p>
            Apesar de poderosa, o sistema de tipos do haskell é muitas vezes também
            discreto. Se omitir informações de tipos explícito, um compilador
            Haskell automaticamente inferirá o tipo de uma expressão ou função.
            Comparado com as linguagens tradicionais estáticas, a que devemos
            prover grandes quantidades de informações sobre o tipo, a
            combinação do poder e a inferência do sistema de tipos em Haskell reduz
            significativamente a desorganização e a redundância do nosso código. <
         </p>
         <p>
            Vários outros recursos de Haskell se combinam para aumentar a
            quantidade de trabalho que pode caber em uma tela de texto. Isto traz
            melhorias no desenvolvimento do tempo e agilidade: podemos criar um
            código de confiança rapidamente e facilmente refatorar em resposta a
            novas exigências. 
         </p>
         <p>
            Às vezes, os programas Haskell pode funcionar mais lentamente do que os
            programas similares escrito em C ou C + +. Para a maioria do código que
            escrevemos, as grandes vantagens do Haskell de produtividade e
            confiabilidade superam qualquer desvantagem no desempenho de pequeno
            porte. 
         </p>
         <p>
            Os processadores multicore estão
            onipresentes, mas eles permanecem extremamente difícil para o programa
            com técnicas tradicionais. Haskell oferece tecnologias exclusivas para
            tornar a programação multicore mais tratáveis. Ele oferece suporte a
            programação paralela, o software de memória transacional para a
            simultaneidade de confiança, e escalas de centenas de milhares de
            threads em simultâneo.
         </p>
         <h3 class="title"  id=“”> Comparado com as linguagens dinâmicas
            modernas 
         </h3>
         <p>
            Durante a última década, linguagens interpretada e dinamicamente tipada
            se
            tornaram cada vez mais popular. Elas oferecem benefícios substanciais
            na produtividade do desenvolvedor. Embora estas muitas vezes vem à
            custa
            de um enorme impacto na performance, para muitas a produtividade nas
            tarefas de programação prevalece sobre o desempenho, ou o desempenho
            não é o fator
            mais importante de qualquer modo. 
         </p>
         <p>
            Concisão é uma área em que Haskell e linguagens com tipagem dinâmica
            executam de forma semelhante: em cada caso, escrevemos muito menos
            código para resolver um problema do que em uma linguagem tradicional.
            Programas ficam muitas vezes em torno do mesmo tamanho em linguagens
            dinâmicamente tipadas e Haskell.
         </p>
         <p>
            Quando se considera o desempenho de execução, Haskell quase sempre tem
            uma enorme vantagem. Código compilado pelo Glasgow Haskell Compiler
            (GHC) ficam normalmente entre 20 e 60 vezes mais rápido do que o
            executado em um interpretador de uma linguagem dinâmicamente tipada.
            GHC também fornece
            um intérprete, assim você pode executar scripts sem compilá-los.
         </p>
         <p>
            Outra grande diferença entre as linguagens dinâmicamente tipadas e
            Haskell
            reside na sua filosofia em torno de tipos. Um dos principais motivos
            para a popularidade de linguagens dinâmicamente tipadas é que raramente
            precisamos mencionar explicitamente os tipos. Através da inferência de
            tipo automático, Haskell oferece a mesma vantagem.
         </p>
         <p>
            Para além desta semelhança superficial, as diferenças são profundas. Em
            uma linguagem dinamicamente tipada, podemos criar construções que são
            difíceis de expressar em uma linguagem estaticamente tipada. No
            entanto, o mesmo acontece em sentido inverso: com um tipo de sistema
            tão poderosa como o do Haskell, podemos estruturar um programa de uma
            forma
            que seria impossível ou inviável em linguagens de tipagem dinâmica. 
         </p>
         <p>
            É importante reconhecer que cada uma dessas abordagens envolve
            tradeoffs. Muito brevemente, é
            a escolha entre a perspectiva de segurança que Haskell
            enfatiza, e a perspectiva de flexibilidade que a tipagem dinâmica&nbsp;
            favorece. Se alguém já havia descoberto uma maneira de pensar
            sobre os tipos de que foi sempre melhor, imaginamos que todos soubessem
            sobre ela até agora. 
         </p>
         Claro, temos nossas próprias opiniões sobre quais vantagens e
         desvantagens, são mais benéficas. Dois de nós têm anos de experiência
         em programação em linguagens dinâmicamente tipadas. Nós adoramos
         trabalhar
         com elas, nós ainda usamos todos os dias, mas geralmente, nós
         preferimos Haskell. 
         <p>
         </p>
         <h3 class="title"  id=“”>Haskell na indústria e código aberto</h3>
         <p>
            Aqui estão apenas alguns exemplos de grandes sistemas de software que
            tenham sido criados em Haskell. Alguns deles são de código aberto,
            enquanto outros são produtos patenteados.
         </p>
         <ul type="disc">
            <li>
               ASIC e FPGA design software (Lava, produtos da
               Bluespec Inc.) 
            </li>
            <li>
               Software de composição musical (Haskore)
            </li>
            <li>
               Compiladores e ferramentas relacionadas com
               compilador (principalmente GHC)
            </li>
            <li>
               Controle de distribuição e revisão (Darcs)
            </li>
            <li>
               Web middleware (Happstack, produtos de Galois
               Inc.) 
            </li>
            <li>
               ABN AMRO é um banco internacional. Ele usa
               Haskell em investimentos, para medir o risco de contraparte de
               carteiras de derivativos financeiros. 
            </li>
            <li>
               Anygma é uma empresa de inicialização.
               Desenvolve ferramentas de criação multimídia conteúdo usando Haskell.
            </li>
            <li>
               Amgen é uma empresa de biotecnologia. Ele
               cria modelos matemáticos e outras aplicações complexas em Haskell.
            </li>
            <li>
               Bluespec é um ASIC e FPGA fornecedor de
               software de design. Seus produtos são desenvolvidos em Haskell, e as
               Linguagens de design de chips que fornecem seus produtos são
               influenciados pelo Haskell.
            </li>
            <li>
               Eaton utiliza Haskell para a concepção e
               verificação de sistemas hidráulicos de veículos híbridos.
            </li>
         </ul>
         <h3 class="title"  id=“”>Compilação, depuração e análise de desempenho</h3>
         <p>
            Para o trabalho prático, quase tão importante como a própria linguagem
            é o "ecossistema" de bibliotecas e ferramentas à sua volta. Haskell tem
            uma forte presença nesta área. 
         </p>
         <p>
            O compilador mais utilizado, GHC, foi ativamente desenvolvida por mais
            de 15 anos, e fornece um conjunto maduro e estável de recursos.
         </p>
         <ul type="disc">
            <li>
               Compila para código nativo eficiente em todos
               os principais sistemas operacionais modernos e arquiteturas de CPU
            </li>
            <li>
               Fácil implantação dos binários compilados,
               livre de restrições de licenciamento
            </li>
            <li>
               Análise da cobertura de código
            </li>
            <li>
               Detalhado perfis de desempenho e uso de
               memória 
            </li>
            <li>
               Documentação completa
            </li>
            <li>
               Apoio escalável e massivo para multicore e
               programação concorrente 
            </li>
            <li>
               Interpretador e depurador interativo 
            </li>
         </ul>
         <h3 class="title"  id=“”>Bibliotecas bundled e a terceira parte</h3>
         <p>
            O compilador GHC vem com uma coleção de bibliotecas úteis. Aqui
            estão algumas das necessidades comuns de programação que as bibliotecas
            face a estes. 
         </p>
         <ul type="disc">
            <li>
               I/O arquivo, e de passagem e manipulação de
               sistema de arquivos 
            </li>
            <li>
               Programação de cliente e servidor de rede 
            </li>
            <li>
               Expressões regulares e análise sintática
            </li>
            <li>
               Programação concorrente 
            </li>
            <li>
               Testes automatizados
            </li>
            <li>
               Som e gráficos 
            </li>
         </ul>
         <p>
            O banco de dados do pacote Hackage é uma coleção de
            bibliotecas de código aberto e aplicações da comunidade Haskell. A
            maioria das bibliotecas
            publicado em Hackage são licenciados sob os termos que permitem tanto o
            uso como código aberto e comercial. Algumas das áreas
            abrangidas pelas bibliotecas de código aberto incluem o seguinte.
         </p>
         <ul type="disc">
            <li>
               Interfaces para todas as principais banco de dados open source
               e comercial.
            </li>
            <li>
               Processamento de XML, HTML e XQuery 	
            </li>
            <li>
               Desenvolvimento de cliente e servidor de redes
               e web
            </li>
            <li>
               GUIs Desktop, incluindo toolkits
               e cross-platform 
            </li>
            <li>
               Suporte para Unicode e outras codificações de
               texto
            </li>
         </ul>
         <h2 class=“title” id=“”>Um breve resumo da
            história do Haskell
         </h2>
         <p>O desenvolvimento de Haskell está
            enraizada na matemática e na pesquisa de ciência da computação. 
         </p>
         <h3 class="title"  id=“”>Pré-História</h3>
         <p>
            Algumas décadas antes dos computadores
            modernos serem inventados, o
            matemático Alonzo Church desenvolveu uma linguagem chamada de cálculo
            lambda. Ela destina-se como uma ferramenta para investigar os
            fundamentos da matemática. A primeira pessoa a perceber a conexão entre
            práticas de programação e cálculo lambda foi John McCarthy, que criou
            Lisp em 1958.
         </p>
         <p>
            Durante os anos 1960, cientistas da
            computação começaram a reconhecer e
            estudar a importância do cálculo lambda. Peter Landin e Christopher
            Strachey desenvolveu idéias sobre os fundamentos das linguagens de
            programação: sobre como entender o que eles fazem (semântica
            operacional) e como entender o que eles significam (semântica
            denotational). 
         </p>
         <p>
            No início dos anos 1970, Robin Milner
            criou um linguagem de programação
            funcional mais rigorosa, chamado ML. Embora ML foi desenvolvida para
            ajudar com provas automatizada de teoremas matemáticos, acabou ganhando
            uma sequência de outras tarefas de computação em geral. 
         </p>
         <p>
            A década de 1970 viu o surgimento da
            avaliação preguiçosa (ou função não-estrita) como uma nova
            estratégia. David Turner desenvolveu SASL e KRC, enquanto Rod Burstall
            e John Darlington desenvolvido NPL e Hope. NPL, KRC e ML influenciaram
            o desenvolvimento de várias outras linguagens na década de 1980,
            incluindo Lazy ML, Clean e Miranda.
         </p>
         <h3 class="title"  id=“”>História recente</h3>
         <p>
            Até o final dos anos 1980, os esforços
            dos investigadores que trabalham
            sobre avaliação preguiçosa em linguagens funcionais estavam espalhados
            por mais de uma dezena de Linguagens. Preocupados com essa difusão de
            esforço, um número de investigadores decidiram formar uma comissão para
            criar uma linguagem comum. Após três anos de trabalho, a comissão
            publicou a especificação 1.0 do Haskell em 1990. É o nomearam a
            linguagem depois em homenagem a Haskell Curry, um influente lógico.
         </p>
         <p>
            Muitas pessoas são realmente suspeitas
            de falar sobre “<span class="quote">design by committee</span>”,
            mas o trabalho da comissão do Haskell é um belo exemplo dos melhores
            trabalhos que uma comissão pode fazer. Eles produziram um elegante
            projeto de linguagem, e conseguiu unificar os esforços divididos da sua
            comunidade de pesquisa. Do emaranhado de linguagens funcionais com
            avaliação preguiçosa que existia em 1990, apenas Haskell ainda é
            ativamente usada
         </p>
         <p>
            Desde a sua publicação em 1990, o
            padrão de linguagem Haskell passou por cinco
            revisões, a mais recente em 1998. Um número de implementações de
            Haskell foram escritas e várias ainda estão ativamente em
            desenvolvimento.
         </p>
         <p>
            Durante a década de 1990, Haskell teve dois objetivos principais. De um
            lado, ele dava pesquisadores de linguagem uma linguagem estável em que
            podia experimentar como a avalição preguiçosa podia fazer programas
            funcionais executar eficientemente. Outros pesquisadores exploraram
            como construir programas usando técnicas baseados em avaliação
            preguiçosa funcional. Outros ainda usaram como linguagem de ensino.
         </p>
         <h3 class="title"  id=“”>A era moderna</h3>
         <p>
            Embora estas explorações básica da década de 1990 prosseguiram, Haskell
            permaneceu firme como um assunto acadêmico. O slogan informal de quem
            estava dentro da comunidade era “evitar o sucesso a todo custo”. Poucos
            fora dessa comunidade tinham ouvido falar da linguagem. Desse
            modo,&nbsp; a programação funcional, ficou como um campo bastante
            obscuro.
         </p>
         <p>
            Durante este tempo o mainstream mundo da programação experimentava com
            pequenos ajustes relativamente: a partir de programação em C, até C +
            +, até Java. Enquanto isso, na periferia, os programadores estavam
            começando a mexer com o novo, linguagens mais dinâmicas. Guido van
            Rossum projetou Python, Larry Wall criou Perl e Yukihiro Matsumoto
            desenvolveu Ruby.
         </p>
         <p>
            Como essas novas linguagens começaram a infiltrar-se em uma utilização
            mais ampla, elas espalharam algumas idéias fundamentais. O primeiro foi
            que os programadores não estavam plenamente trabalhando em linguagens
            expressivas. A segunda foi, em parte, um subproduto do rápido
            crescimento no poder computacional da época: muitas vezes é inteligente
            sacrificar algum desempenho de execução, em troca de um grande aumento
            na produtividade do programador. Finalmente, várias dessas linguagens
            emprestaram algo da programação funcional.
         </p>
         <p>
            Durante a última metade da década passada, Haskell conseguiu escapar da
            academia, impulsionado em parte pela visibilidade do Python, Ruby e até
            Javascript. A linguagem agora tem um&nbsp; rápido e vibrante
            crescimento na cultura dos usuários open source e comercial, e os
            pesquisadores continuam a usá-lo para aumentar os limites de desempenho
            e expressividade.
         </p>
         <h2 class=“title” id=“”>Recursos úteis</h2>
         <p>
            A medida que você trabalhar com Haskell, com certeza terá dúvidas e irá
            querer mais informações sobre as coisas. Aqui estão alguns recursos da
            Internet onde você pode buscar informações e interagir com outros
            programadores Haskell. 
         </p>
         <h3 class="title"  id=“”>Material de referência</h3>
         <ul type="disc">
            <li>
               <a class="ulink" href="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html" target="_top">The Haskell Hierarchical Libraries reference</a> fornece
               a documentação para a biblioteca padrão que vem com o compilador. Este
               é um dos mais valiosos activos online para programadores Haskell. 
            </li>
            <li>
               Para perguntas sobre a sintaxe e recursos da
               linguage o <a href="http://haskell.org/onlinereport/" target="_top">Haskell
               98 Report</a> descreve ao padrão da linguagem Haskell 98.
            </li>
            <li>
               Diversas extensões à linguagem tornaram-se
               comuns desde o Haskell 98 Report foi liberado. O <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html" target="_top">Guia do usuário do GHC</a> contém documentação detalhada
               sobre as extensões suportadas pelo GHC, bem como algumas
               características específicas do GHC.
            </li>
            <li>
               <a href="http://haskell.org/hoogle/" target="_top">Hoogle</a> e <a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_top">Hayoo</a>
               são os motores de busca da API Haskell. Eles podem procurar as funções
               pelo nome ou por tipo. 
            </li>
         </ul>
         <h3 class="title"  id=“”> Aplicativos e bibliotecas</h3>
         <p>
            Se você está procurando uma biblioteca Haskell a ser usado para uma
            tarefa específica, ou de um pedido escrito em Haskell, confira os
            seguintes recursos.
         </p>
         <ul type="disc">
            <li>
               A comunidade Haskell mantém um repositório
               central de bibliotecas de código aberto e aplicações Haskell. É chamado
               <a href="http://hackage.haskell.org/" target="_top">Hackage</a>, e
               permite que você procure software para download, ou procurar a sua
               coleção por categoria.
            </li>
            <li>
               O <a href="http://haskell.org/haskellwiki/Applications_and_libraries" target="_top">Haskell Wiki</a> contém uma seção dedicada à informação
               sobre algumas bibliotecas Haskell.
            </li>
         </ul>
         <h3 class="title"  id=“”>A comunidade Haskell</h3>
         <p>Há uma série de maneiras que você pode entrar em contato com outros
            programadores Haskell, fazer perguntas, saber o que outras pessoas
            estão falando, e simplesmente fazer alguma rede social com seus pares.
         </p>
         <ul type="disc">
            <li>
               A primeira parada em sua busca por recursos da
               comunidade deve ser o <a href="http://www.haskell.org/" target="_top">site
               Haskell</a>. Esta página contém os links mais atuais para várias
               comunidades e informação, bem como um wiki e mantida ativamente.
            </li>
            <li>
               Haskellers utilizar uma série de <a href="http://haskell.org/haskellwiki/Mailing_lists" target="_top">listas</a>
               para os debates de atualidade. Destes, o geralmente mais interessante é
               chamado <code>haskell-cafe</code>. Tem uma atmosfera tranquila e
               amigável, onde profissionais e acadêmicos trocam informações com
               hackers casuais e novatos. 
            </li>
            <li>
               Para bate-papo em tempo real, o <a href="http://haskell.org/haskellwiki/IRC_channel" target="_top">canal
               de IRC Haskell</a>, chamado <code>#haskell</code>, é grande e animado.
               Parecido como o <code>haskell-cafe</code>, a atmosfera e amigável e
               prestativos, apesar do grande número de usuários simultâneos.
            </li>
            <li>
               Há muitos grupos de usuários locais, meetups,
               workshops acadêmicos, e assim por diante, aqui está <a href="http://haskell.org/haskellwiki/User_groups" target="_top">uma
               lista dos grupos de usuários conhecidos e workshops</a>.
            </li>
            <li>
               O <a href="http://sequence.complete.org/" target="_top">Haskell Weekly News</a> é um-quase-resumo semanal de
               muitas atividades na comunidade Haskell. Você pode encontrar links para
               listas de discussões interessantes, novas versões de softwares, e assim
               por diante.
            </li>
            <li>
               <a class="ulink" href="http://haskell.org/communities/" target="_top">Haskell
               Communities and Activities Report</a> recolhe informações sobre as
               pessoas que usam Haskell, e o que eles estão fazendo com ele. Ela tem
               funcionada durante anos, por isso oferece uma boa maneira de descobrir
               o passado do Haskell. 
            </li>
         </ul>
         <h2 class=“title” id=“”> Agradecimentos </h2>
      </article>
      <footer>
         <p>Copyright
            2007, 2008 Bryan O'Sullivan, Don Stewart, and John Goerzen. This
            work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
            Commons Attribution-Noncommercial 3.0 License</a>. Icons by
            <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.
         </p>
         <a accesskey="p" style="float:left" href="index.html">Anterior</a>
         <a  href="getting-started.html" style="float:right">Próximo</a>
         <p style="text-align:center"><a accesskey="p"  href="index.html">Inicio</a></p>
         <br>
      </footer>
   </body>
</html>