
<!-- saved from url=(0058)http://book.realworldhaskell.org/read/using-databases.html -->
<HTML><STYLE>#awesome_screenshot_wrapper {
	position: absolute;
	top:0; left:0;
	z-index:2147483630; /* MAX:2147483647 */
	cursor: crosshair;
	background-color: rgba(0, 0, 0, 0.3);
	
	font: normal normal normal 12px/1 Helvetica, arial, sans-serif;
}

#awesome_screenshot_wrapper>div {
	position:absolute;
	background-color: rgba(0, 0, 0, 0.3);
	cursor:auto;
}
#awesome_screenshot_top 		{ top:0; left:0; }
#awesome_screenshot_right	{ top:0; right:0; }
#awesome_screenshot_bottom	{ right:0; bottom:0; }
#awesome_screenshot_left	{ bottom:0; left:0; }

div#awesome_screenshot_center { 
	cursor:move;
	outline: 1px dashed #000;
	background-color: rgba(0, 0, 0, 0);
}

.dragresize {
	display: block !important;
	position: absolute !important; 
	z-index: 999 !important; 
	width:9px !important; height:9px !important;
	background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIxJREFUeNqMUDEOgCAMrA58CFZX3uDIU/iBX3D0DawkTCS8xhBYao84aOLgJZdy10sLTMxMgDHGSVmFizAKj5zzPpoIaa037z2nlLjWOio0/DFEDg5Ga42fgL6DbsYKay0ppegJaPjjCpI8seIL8NHHpFhKoS/cfkToCCFQ7/0VgIaP/q/XTX/+6RJgAEc6j4dkIiynAAAAAElFTkSuQmCC);
	background-position:center center !important; background-repeat:no-repeat !important; 
	font-size: 0.1px !important; 
}
.dragresize-tl { top:-5px; left: -5px; cursor: nw-resize; }
.dragresize-tm { top:-5px; width:100% !important; cursor: n-resize; }
.dragresize-tr { top:-5px; right: -5px; cursor: ne-resize; }
.dragresize-ml { left: -5px; height:100% !important; cursor: w-resize; }
.dragresize-mr { right: -5px; height:100% !important; cursor: e-resize; }
.dragresize-bl { left:-5px; bottom: -5px; cursor: sw-resize; }
.dragresize-bm { bottom: -5px; width:100% !important; cursor: s-resize; }
.dragresize-br { right:-5px; bottom: -5px; cursor: se-resize; }

#awesome_screenshot_size {
	display:none;
	position:absolute; 
	top:-30px; left:0;
}
#awesome_screenshot_size span {
	min-width:60px; 
	padding:2px 10px; 
	border-radius:10px; 
	background-color:rgba(0, 0, 0, 0.7); 
    color:#eee; 
	text-align:center; 
	line-height:20px;
}

#awesome_screenshot_action {
	display:none;
	position:absolute; 
	bottom:-30px; right:0
}
#awesome_screenshot_action a {
	display: inline-block;
	margin-left:20px;
	padding: 2px 8px 2px 6px;
	height: 20px;
	border-radius:6px;
	background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#F8F8F8), to(#D2D2D2));
	-webkit-box-shadow: #666 0px 3px 7px;
	color: #000;
	font-size:13px; line-height:20px;
	text-shadow: #F5F5F5 0px 1px 0px;
	text-decoration:none !important;
}
#awesome_screenshot_action a:hover { background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fff), to(#e5e5e5)); }
#awesome_screenshot_action a:active { background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#e5e5e5), to(#ddd)); }
a#awesome_screenshot_capture { font-size:13px; font-weight:bold; }

#awesome_screenshot_action a span {
	display:inline-block;
    width:20px; height:20px;
	margin-right:4px;
    background-repeat:no-repeat;
	vertical-align:top;
}
#awesome_screenshot_capture span { 
	background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAu1JREFUeNqslF9IU2EUwM/97r95t7mpm+aoiIxELHrpL+KfhzIUJDAlhR5mhVRoRfRiPhQkVA89JAmFWEHZkz2FfxCMMIIowtl6KKPEKNTmmnO7m9v917mat2WTTD1wvst3vvP9OOc751xK0zRYS2H0Zd+5T6thsBgTwW/85c0cjVkNCUE2Qig3z0IQt490KLNymJZJE9JmMrFVO7dwTSZ23k5WCMvGyDo3Ztur9BKkcNQXi0BkA6j9H8yBsDsuh3W/K9MCDE0gEJbDUzOKZgBpQi33zXiENTvTzRXODDPIqgo8R2Dsu5z78WucNYBmfnmZq6paaTVzbodd0OHgn56FSFwFjqHyTBzFGG0jY7R6vIviTEGNJuw3cyzdbBV4u967vkAUwuGodGAH/2Z3rjDAMUQygGJMhYWs0TcL15OIj1EUXPtlYzHVRpvFlM9xNEwGZkGOx2O1JZYud2naLXR5p8dlAPGiHiHBpYphKDdLM2WapvokRR1QFHiNx4U8Sx/hOQb8wTgoSDtx0N5ZU2K7jtdH/pqUQEjhEXpWMNGXrRY2hedYkCTZKYmx42j3YtFqeY7ODkVlhElSfZn9YU2xrQWvjiYdvdbTLiLJmmXAI049exvZYLfgAUNh9UkxAfUqtkZ5TNYgFJmFU+X2x9VFqS344KPJCkf9+jnoL+ic+CEXPvWE6u72TxcFI2C1mIiiYu54zAbDMlQWWF9cqHY0CDzxLAY994pQuN1sABeERs0Z9Ip1N7qm6sd8UnqqQMO0qEDRNmHk0tHMRqeN6U8W2URAhnVpzFznJ1Pnq/di0+ErY5Nbj33QSi9+nhn0hhvQTi/27e7uho6ODmO/VEf7duUKbWcOZbS6HKxYsSf1yd484QHalUSnnp4eGB4ehvHxcWhvb/9dlCVkpiBfuH/v/PoIDr+Xpalg4mFvby94PB4sHjOnfr//n0B9xr9tymJv61OXaO/r64OhoaE5EEXNTwRN039Uec3kpwADAF/7QPnKdxP4AAAAAElFTkSuQmCC);
}
#awesome_screenshot_cancel span { 
	background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA7VJREFUeNqslF9Im1cYxt/zfV8So6l/o1HIav/B7GRh3VpkmMFA6cXcxdp600EdBt0cu9rNoC0MKaxzN1th4MXK7gqyYouzDAZlo81crZpoYxvTmMbEGl3KEjKrTWJOvnx7Tmqcdc120wMP58t73veX95zzcJimafQiBysAu46202fXf6F0kbxN5YqBZOgQWEohUJlM0XN6rYNqQGqCyrC+Ai0iFoWe/GeHfsbo8WYbiFRIRG1Qv0r0qlGSSJZl2uCc8FtFziDm75B6b2eHW0APgPwprB6ggTKiD+SammyupSVYsnfvIjMY1jfC4d3M692n+v3VG0SxDFE3Sn4SZaih1wVLAIUmEZgiMk4xdnEO4QDks9v9j8fH31eTSRtymqHWVCj0YaCr68b9khJtliiOmtcgNkVPWVtAgCQXY0dnJUmbt1oTfrs9hP3kfic6529vp/jVq8Sj0UL+kaDDcX1OUbRpxkYAM/0L6C4rq5gxGH706vVq5Pz5wWQweOrunj2rHqI0uv/4pjjnEyeIP3qUz08/ePDW/ebmRTdjGtZfmdwJnKmqsk4bDGnvgQMP0+HwQcSk+OXLX8yYzdxF9Ac6eGdMQDs7icfj+ZqFnp6hGSCmS0t7p3ftkrXttlHX15Uc54bSxsZFQ2OjT8Sqjh//JhMON0TOnu0mzr8uYWz5z+Fhj4TCqo4OokxmTsa2Jav1DTIaL6EkJT3jIUWhjWBQXTp9mv66coWYLMdq+/q+tPT0/Izll7Ghi4DujmFtweGgpNvNVbhDMpkMsskkHPdPh0ptbVbjXIU1LJGBAbO+ujq2T3TS2Rmo7+8/t7G8XBcfHT0iM/atwpgD24vzpaWDnHNW3tQUkCsrs3lQ4QznOzrMvtbWydu4BLde/zlmctXVUWJ4OL+OP3rPe/hw6BZKcAFfwRW2CcZm8a2tOZ32dDDInrmUJy6XLj409IkouM1YxC1Jb+ahFgslRkZEji7l8/XdtdmisNIagLPjOPrAsWNONZ2uKXC2gEK4mJdC3d03fkMY4Hk30UcCeqe+nnxtbRQ5c4bCJ08OjhmN2q/I8ezfH0t6PO9quZz0XCDEMisrb4d6eydgEc2JBwBANyzzA+ZLLp3u5q3y8qhTwGy2h2tjY5+ipnQ7YydQSM6urtoT1659f6+lxQ+YNr6pCeG5hoZo9MKF0Uwkcgq5FTvrWZEHVljAko3F7Llk8lAulbIIq0pGY4LpdAuK2ezEHESMF32+igxlm0Siuin+vy/2ixp/CzAAgfM+qr/p3aEAAAAASUVORK5CYII=);
}</STYLE><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><TITLE>Capítulo&nbsp;21.&nbsp;Usando Bancos de Dados</TITLE><LINK rel="stylesheet" href="./Chapter 21. Using Databases_files/styles.css" type="text/css"><META name="generator" content="DocBook XSL Stylesheets V1.73.2"><LINK rel="start" href="http://book.realworldhaskell.org/read/index.html" title="Real World Haskell"><LINK rel="up" href="http://book.realworldhaskell.org/read/index.html" title="Real World Haskell"><LINK rel="prev" href="http://book.realworldhaskell.org/read/systems-programming-in-haskell.html" title="Chapter&nbsp;20.&nbsp;Systems Programming in Haskell"><LINK rel="next" href="http://book.realworldhaskell.org/read/extended-example-web-client-programming.html" title="Chapter&nbsp;22.&nbsp;Extended Example: Web Client Programming"><LINK rel="alternate" type="application/atom+xml" title="Comments" href="http://book.realworldhaskell.org/feeds/comments/"><LINK rel="shortcut icon" type="image/png" href="http://book.realworldhaskell.org/support/figs/favicon.png"><SCRIPT type="text/javascript" src="./Chapter 21. Using Databases_files/jquery-min.js"></SCRIPT><SCRIPT type="text/javascript" src="./Chapter 21. Using Databases_files/form.js"></SCRIPT><SCRIPT type="text/javascript" src="./Chapter 21. Using Databases_files/hsbook.js"></SCRIPT><STYLE type="text/css">.jlhlebbhengjlhmcjebbkambaekglhkf {top: 0px; left: 0px;min-width: 30px;max-width: 300px;font-size: 13px;font-family: arial, helvetica, sans-serif;opacity: .93;padding:0px;position:absolute;display:block;z-index: 999997;font-style: normal;font-variant: normal;font-weight: normal;}#jlhlebbhengjlhmcjebbkambaekglhkf_up{text-align: center;padding:0px;margin: 0px;}#jlhlebbhengjlhmcjebbkambaekglhkf_cont{background-color: #729FCF;font-family: arial, helvetica, sans-serif-webkit-box-shadow: #729FCF 0px 0px 2px;color: #FFFFFF;padding:7px;-webkit-border-radius: 5px;}#jlhlebbhengjlhmcjebbkambaekglhkf_down{text-align: center;padding:0px;margin: 0px;}</STYLE></HEAD><BODY bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><DIV class="navheader"><H2 class="booktitle"><A href="http://book.realworldhaskell.org/">Real World Haskell</A><SPAN class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</SPAN></H2></DIV><DIV class="navheader"><TABLE width="100%" summary="Navigation header"><TBODY><TR><TH colspan="3" align="center">Capítulo&nbsp;21.&nbsp;Usando Bancos de Dados</TH></TR><TR><TD width="20%" align="left"><A accesskey="p" href="http://book.realworldhaskell.org/read/systems-programming-in-haskell.html">Prev</A>&nbsp;</TD><TH width="60%" align="center">&nbsp;</TH><TD width="20%" align="right">&nbsp;<A accesskey="n" href="http://book.realworldhaskell.org/read/extended-example-web-client-programming.html">Next</A></TD></TR></TBODY></TABLE></DIV><DIV class="chapter" lang="en" id="databases"><DIV class="titlepage"><DIV><DIV><H2 class="title">Capítulo&nbsp;21.&nbsp;Usando Bancos de Dados</H2></DIV></DIV></DIV><DIV class="toc"><P style="opacity: 0.35; "><B>Índice</B></P><P style="display: none;"><A onclick="return loadAllComments()">Carregar todos os comentários (<B>slow</B>)</A></P><DL><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.hdbc">Resumo do HDBC</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.hdbc.install">Instalando HDBC e Drivers</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.connect">Conectando aos Bancos de Dados</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.transactions">Transações</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.simplequeries">Pesquisas Simples</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#database.sqlvalue">SqlValues</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.args">Parâmetros de Pesquisa</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.statements">Declarações Preparadas</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.readingresults">Leitura de Resultados</A></SPAN></DT><DD><DL><DT><SPAN class="sect2"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.readingstatements">Leitura de Declarações</A></SPAN></DT><DT><SPAN class="sect2"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.readinglazy">Leitura Preguiçosa</A></SPAN></DT></DL></DD><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.metadata">Metadados de Banco de Dados</A></SPAN></DT><DT><SPAN class="sect1"><A href="http://book.realworldhaskell.org/read/using-databases.html#databases.errors">Tratamento de Erro</A></SPAN></DT></DL></DIV><P id="x_Ec"><A name="x_Ec"></A>
      Tudo desde fóruns a podcatchers ou até mesmo programas de backup 
	  freqüentemente usam bancos de dados para armazenamento persistente.
	  Bancos de dados baseados em SQL são  bastante convenientes: eles são 
	  rápidos, a escala de tamanhos pode variar de minúsculo a enorme, 
	  pode operar através da rede, frequentemente ajuda a lidar com travamentos 
	  e operações, e pode ainda fornecer tratamento de erros e melhorias 
	  em redundância para aplicações. Bases de dados vêm em diferentes formas:
	  a grandes bases de dados comerciais, tais como Oracle, engines de código
	  aberto, como MySQL ou PostgreSQL, e ainda engines integradas como Sqlite.
     <SPAN id="comments_x_Ec" class="comment"><A class="commenttoggle" id="toggle_x_Ec" pid="x_Ec" onclick="return loadComments(&quot;x_Ec&quot;)" href="comments: show / hide">6 comments</A></SPAN></P><P id="x_Fc"><A name="x_Fc"></A>
      Motivos pelos quais os bancos de dados são tão importantes,
	  mostra como o suporte Haskell para eles também é importante. 
	  Neste capítulo, vamos apresentar um dos frameworks Haskell para
	  trabalhar com bancos de dados. Também vamos usar esse framework
	  para começar a construir um podcast downloader, que será desenvolvido 
	  no Capítulo 22, Exemplo Extendido: Web Client Programming.<A class="xref" href="http://book.realworldhaskell.org/read/extended-example-web-client-programming.html" title="Chapter&nbsp;22.&nbsp;Extended Example: Web Client Programming">Chapter&nbsp;22, <I>Extended Example: Web Client Programming</I></A>.
     <SPAN id="comments_x_Fc" class="comment"><A class="commenttoggle" id="toggle_x_Fc" pid="x_Fc" onclick="return loadComments(&quot;x_Fc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.hdbc">Resumo do HDBC</H2></DIV></DIV></DIV><P id="x_Gc"><A name="x_Gc"></A>
     Na parte inferior da pilha do banco de dados está a engine do banco de dados.
	 A engine do banco de dados é responsável por armazenar os dados no disco. 
	 Engines de Bancos de dados conhecidas incluem PostgreSQL, MySQL e Oracle.  <SPAN id="comments_x_Gc" class="comment"><A class="commenttoggle" id="toggle_x_Gc" pid="x_Gc" onclick="return loadComments(&quot;x_Gc&quot;)" href="comments: show / hide">4 comments</A></SPAN></P><P id="x_Hc"><A name="x_Hc"></A>
     A maioria das engines de bancos de dados modernas suportam SQL, Structured Query Language, 
	 como uma forma padrão de obter dados de entrada e saída de bancos de dados relacionais. 
	 Este livro não irá fornecer um tutorial sobre SQL ou gerenciamento de banco de dados relacional. <SUP>[<A name="id667806" href="http://book.realworldhaskell.org/read/using-databases.html#ftn.id667806" class="footnote">49</A>]</SUP>
       <SPAN id="comments_x_Hc" class="comment"><A class="commenttoggle" id="toggle_x_Hc" pid="x_Hc" onclick="return loadComments(&quot;x_Hc&quot;)" href="comments: show / hide">3 comments</A></SPAN></P><P id="x_Ic"><A name="x_Ic"></A>
       Uma vez que você utiliza uma engine de banco de dados que suporta SQL,
	   você precisa encontrar uma maneira de se comunicar com ela. Cada banco 
	   de dados tem seu próprio protocolo. Desde que SQL é razoavelmente constante 
	   em bases de dados, é possível fazer uma interface genérica que usa os drivers
	   para cada protocolo individualmente.
       <SPAN id="comments_x_Ic" class="comment"><A class="commenttoggle" id="toggle_x_Ic" onclick="return loadComments(&quot;x_Ic&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Jc"><A name="x_Jc"></A>
        Haskell tem vários frameworks de bancos de dados diferentes disponíveis, 
		fornecendo algumas camadas de alto nível que sobrepõe umas as outras.
		Para este capítulo, vamos nos concentrar no HDBC, o sistema Haskell Data Base Connectivity. 
		HDBC é uma biblioteca de abstração de banco de dados. Ou seja, você pode escrever 
		código que usa HDBC e pode acessar dados armazenados em quase qualquer banco de dados 
		SQL com pouca ou nenhuma modificação.
		<SUP>[<A name="id667844" href="http://book.realworldhaskell.org/read/using-databases.html#ftn.id667844" class="footnote">50</A>]</SUP>  
		Mesmo que você nunca precise mudar as engines de banco de dados subjacentes, o sistema HDBC 
		de drivers faz com que um grande número de opções disponíveis para você com uma única interface.
       <SPAN id="comments_x_Jc" class="comment"><A class="commenttoggle" id="toggle_x_Jc" pid="x_Jc" onclick="return loadComments(&quot;x_Jc&quot;)" href="comments: show / hide">4 comments</A></SPAN></P><P id="x_Lc"><A name="x_Lc"></A>
        Outra biblioteca de abstração para o banco de dados para Haskell é a HSQL, que compartilha
		um propósito semelhante ao HDBC. Há também um framework de alto nível chamado HaskellDB, que 
		fica sobre um HDBC ou HSQL, e é projetado para ajudar a isolar o programador dos detalhes de 
		trabalhar com SQL. No entanto, ele não tem como apelo mais amplo porque o projeto limita a certos 
		- embora bastante comum - padrões de acesso ao banco. Finalmente, Takusen é um framework que utiliza
		uma abordagem "left fold" para a leitura de dados do banco de dados.
       <SPAN id="comments_x_Lc" class="comment"><A class="commenttoggle" id="toggle_x_Lc" pid="x_Lc" onclick="return loadComments(&quot;x_Lc&quot;)" href="comments: show / hide">5 comments</A></SPAN></P></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.hdbc.install">Instalando HDBC e Drivers</H2></DIV></DIV></DIV><P id="x_Mc"><A name="x_Mc"></A>
        Para conectar um dado banco de dados com o HDBC, você precisa de ao menos dois pacotes: 
		a interface genérica, e um driver específico para o seu banco de dados. Você pode obter 
		o pacote genérico HDBC, e todos os outros drivers do <A class="ulink" href="http://hackage.haskell.org/" target="_top">Hackage</A><SUP>[<A name="id667890" href="http://book.realworldhaskell.org/read/using-databases.html#ftn.id667890" class="footnote">51</A>]</SUP>.
        Para este capítulo, utilizaremos o HDBC versão 1.1.3 para exemplos.
       <SPAN id="comments_x_Mc" class="comment"><A class="commenttoggle" id="toggle_x_Mc" pid="x_Mc" onclick="return loadComments(&quot;x_Mc&quot;)" href="comments: show / hide">6 comments</A></SPAN></P><P id="x_Nc"><A name="x_Nc"></A>
        Você também vai precisar de um banco de dados de backend e um driver backend. 
		Para este capítulo, vamos usar a versão SQLite 3. SQLite é um banco de dados 
		integrado, por isso não requer um servidor separado e é fácil de configurar.
		Muitos sistemas operacionais já vêm com o SQLite versão 3. Se o seu não, você
		pode baixá-lo em<A class="ulink" href="http://www.sqlite.org/" target="_top">http://www.sqlite.org/</A>.  
        A homepage do HDBC tem um link para conhecidos HDBC backend drivers. O driver específico para o SQLite versão 3 pode ser obtido no Hackage.
	   <SPAN id="comments_x_Nc" class="comment"><A class="commenttoggle" id="toggle_x_Nc" pid="x_Nc" onclick="return loadComments(&quot;x_Nc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_Oc"><A name="x_Oc"></A>
        Se você quiser usar HDBC com outras bases de dados, confira os drivers HDBC conhecidos na página <A class="ulink" href="http://software.complete.org/hdbc/wiki/KnownDrivers" target="_top">http://software.complete.org/hdbc/wiki/KnownDrivers</A>.
        Lá você encontrará um link para a ligação ODBC, que permite você se conectar a 
		praticamente qualquer banco de dados em praticamente qualquer plataforma (Windows, POSIX, e outros).
		Você encontrará também uma ligação PostgreSQL. MySQL é suportado através da ligação ODBC, e informações 
		específicas para usuários do MySQL podem ser encontradas na
        <A class="ulink" href="http://software.complete.org/static/hdbc-odbc/doc/HDBC-odbc/" target="_top">HDBC-ODBC API documentation</A>.
       <SPAN id="comments_x_Oc" class="comment"><A class="commenttoggle" id="toggle_x_Oc" pid="x_Oc" onclick="return loadComments(&quot;x_Oc&quot;)" href="comments: show / hide">9 comments</A></SPAN></P></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.connect">Conectando ao Banco de Dados</H2></DIV></DIV></DIV><P id="x_Pc"><A name="x_Pc"></A>
        Para conectar a um banco de dados, você vai usar uma função de conexão de um driver de backend de banco 
		de dados. Cada banco tem seu próprio método único de conexão. A conexão inicial é geralmente a única 
		vez que você vai chamar qualquer coisa de um módulo de driver backend diretamente. 
       <SPAN id="comments_x_Pc" class="comment"><A class="commenttoggle" id="toggle_x_Pc" onclick="return loadComments(&quot;x_Pc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Qc"><A name="x_Qc"></A>
        A função de conexão com o banco de dados irá devolver um identificador banco de dados.
		O tipo exato deste identificador pode variar de um driver para outro, mas será sempre 
		uma instância da <CODE class="literal">IConnection</CODE> typeclass.Todas as funções 
		que você irá usar para operar em bancos de dados irá trabalhar com qualquer tipo que 
		seja uma instância de<CODE class="literal">IConnection</CODE>.  Quando você terminar 
		de falar com o banco de dados, chame a função <CODE class="literal">disconnect</CODE>. 
		Ele irá desconectá-lo do banco de dados. Aqui está um exemplo de conexão com um banco de dados SQLite:
       <SPAN id="comments_x_Qc" class="comment"><A class="commenttoggle" id="toggle_x_Qc" onclick="return loadComments(&quot;x_Qc&quot;)" href="comment: add">No comments</A></SPAN></P><A name="connect.ghci:conn"></A><PRE id="connect.ghci:conn" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>:module Database.HDBC Database.HDBC.Sqlite3</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
Loading package array-0.1.0.0 ... linking ... done.
Loading package containers-0.1.0.1 ... linking ... done.
Loading package bytestring-0.9.0.1 ... linking ... done.
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package mtl-1.1.0.0 ... linking ... done.
Loading package HDBC-1.1.5 ... linking ... done.
Loading package HDBC-sqlite3-1.1.4.0 ... linking ... done.
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>:type conn</CODE></STRONG>
conn :: Connection
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_connect.ghci:conn" class="comment"><A class="commenttoggle" id="toggle_connect.ghci:conn" pid="connect.ghci:conn" onclick="return loadComments(&quot;connect.ghci:conn&quot;)" href="comments: show / hide">5 comments</A></SPAN></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.transactions">Transações</H2></DIV></DIV></DIV><P id="x_Rc"><A name="x_Rc"></A>
        A maioria dos SGBDs modernos possuem controle de regras para as transações. 
		Este controle visa garantir que todos os componentes de uma modificação sejam 
		aplicados, ou que nenhum deles seja. Além disso, este controle de transações impede 
		que outros processos acessando o mesmo banco de dados de acessar dados de alterações 
		parciais que estão em andamento.
       <SPAN id="comments_x_Rc" class="comment"><A class="commenttoggle" id="toggle_x_Rc" pid="x_Rc" onclick="return loadComments(&quot;x_Rc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_Sc"><A name="x_Sc"></A>
        Muitos SGBDs exigem explicitamente que seja realizado um commit(comando da DTL – 
		Linguagem de Transação de Dados - que envia todos os dados das mudanças permanentemente)
		antes que as mudanças sejam gravadas no disco. No modo "autocommit" um commit implícito 
		é executado após cada declaração. Isso pode fazer o ajuste de bancos de dados mais facilmente
		para os programadores não acostumados com o SGBD, mas é apenas um obstáculo para as pessoas
		que realmente querem usar transações multi-instrução. 
       <SPAN id="comments_x_Sc" class="comment"><A class="commenttoggle" id="toggle_x_Sc" pid="x_Sc" onclick="return loadComments(&quot;x_Sc&quot;)" href="comments: show / hide">4 comments</A></SPAN></P><P id="x_Tc"><A name="x_Tc"></A>
        HDBC intencionalmente não suporta o modo AUTOCOMMIT. Quando você modificar dados em seus 
		bancos de dados você deve explicitamente fazer um COMMIT para que as alterações sobre os 
		dados sejam gravadas em disco. Existem duas maneiras de fazer isso no HDBC:
        pode-se chamar <CODE class="literal">commit</CODE> quando você estiver pronto para 
		escrever dados no disco, ou você pode usar a função <CODE class="literal">withTransaction</CODE> que 
        trabalha com os dados em torno das modificações. <CODE class="literal">withTransaction</CODE> fará com
		que os dados alterados sofram COMMIT após a conclusão bem-sucedida da transação.
       <SPAN id="comments_x_Tc" class="comment"><A class="commenttoggle" id="toggle_x_Tc" pid="x_Tc" onclick="return loadComments(&quot;x_Tc&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><P id="x_Uc"><A name="x_Uc"></A>
       Às vezes, um problema ocorre enquanto se está trabalhando na gravação de dados no disco. 
	   Talvez, perceba-se um erro do SGBD ou descubra-se um problema com os dados. Nesses casos, 
	   você pode "reverter" as alterações. Isso fará com que todas as modificações que foram feitas 
	   no ultimo <CODE class="literal">commit</CODE> sejam esquecidas.
       Em HDBC, você pode chamar o comando <CODE class="literal">rollback</CODE> para 
	   reverter o ultimo <CODE class="literal">commit</CODE>. Se você estiver usando <CODE class="literal">withTransaction</CODE>, 
	   qualquer exceção não capturada fará um <CODE class="literal">rollback</CODE> para ser efetivada.
	   <SPAN id="comments_x_Uc" class="comment"><A class="commenttoggle" id="toggle_x_Uc" onclick="return loadComments(&quot;x_Uc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Vc"><A name="x_Vc"></A>
        Note que o <CODE class="literal">rollback</CODE> reverte as operações da última <CODE class="literal">commit</CODE>, <CODE class="literal">rollback</CODE>,
		ou <CODE class="literal">withTransaction</CODE>. Um banco de dados não mantém um extenso histórico das operações, 
		como um controle de versão do sistema. Você verá exemplos de <CODE class="literal">commit</CODE> mais tarde neste capítulo.
       <SPAN id="comments_x_Vc" class="comment"><A class="commenttoggle" id="toggle_x_Vc" pid="x_Vc" onclick="return loadComments(&quot;x_Vc&quot;)" href="comments: show / hide">6 comments</A></SPAN></P><DIV class="warning"><TABLE border="0" summary="Warning"><TBODY><TR><TD rowspan="2" align="center" valign="top" width="25"><IMG alt="[Warning]" src="./Chapter 21. Using Databases_files/warning.png"></TD><TH align="left">Aviso</TH></TR><TR><TD align="left" valign="top"><P id="x_Wc"><A name="x_Wc"></A>
          Um banco de dados popular, o MySQL, não suporta transações
		  com seu tipo de tabela padrão. Na sua configuração padrão,
		  o MySQL irá ignorar chamadas para <CODE class="literal">commit</CODE> ou <CODE class="literal">rollback</CODE> e irá
		  gravar todas as alterações no disco imediatamente. O driver
		  ODBC HDBC tem instruções para configurar o MySQL para indicar
		  ao HDBC que ele não suporta estes comandos de transações DTL, 
		  o que fará o <CODE class="literal">commit</CODE> e <CODE class="literal">rollback</CODE> gerar erros. Alternativamente, 
		  você pode usar tabelas InnoDB no MySQL, que realiza operações 
		  de apoio. Tabelas InnoDB são recomendadas para uso com HDBC.
         <SPAN id="comments_x_Wc" class="comment"><A class="commenttoggle" id="toggle_x_Wc" onclick="return loadComments(&quot;x_Wc&quot;)" href="comment: add">No comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.simplequeries">Pequisas Simples</H2></DIV></DIV></DIV><P id="x_Yc"><A name="x_Yc"></A>
        Algumas das mais simples consultas em SQL envolvem declarações 
		que não retornam todos os dados. Essas consultas podem ser usadas
		para criar tabelas, inserir dados, apagar dados e definir os parâmetros do banco de dados.
       <SPAN id="comments_x_Yc" class="comment"><A class="commenttoggle" id="toggle_x_Yc" onclick="return loadComments(&quot;x_Yc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Zc"><A name="x_Zc"></A>
        A função básica para o envio de consultas ao banco de dados é <CODE class="literal">run</CODE>.
		Esta função tem um <CODE class="literal">IConnection</CODE>, uma <CODE class="literal">String</CODE> que representa a consulta
		em si, e uma lista de parâmetros. Vamos usá-lo para configurar algumas 
		coisas na nossa base de dados. 
       <SPAN id="comments_x_Zc" class="comment"><A class="commenttoggle" id="toggle_x_Zc" onclick="return loadComments(&quot;x_Zc&quot;)" href="comment: add">No comments</A></SPAN></P><A name="query.ghci:setup"></A><PRE id="query.ghci:setup" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>:module Database.HDBC Database.HDBC.Sqlite3</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
Loading package array-0.1.0.0 ... linking ... done.
Loading package containers-0.1.0.1 ... linking ... done.
Loading package bytestring-0.9.0.1 ... linking ... done.
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package mtl-1.1.0.0 ... linking ... done.
Loading package HDBC-1.1.5 ... linking ... done.
Loading package HDBC-sqlite3-1.1.4.0 ... linking ... done.
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>run conn "CREATE TABLE test (id INTEGER NOT NULL, desc VARCHAR(80))" []</CODE></STRONG>
0
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>run conn "INSERT INTO test (id) VALUES (0)" []</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>commit conn</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:setup" class="comment"><A class="commenttoggle" id="toggle_query.ghci:setup" pid="query.ghci:setup" onclick="return loadComments(&quot;query.ghci:setup&quot;)" href="comments: show / hide">6 comments</A></SPAN><P id="x_ac"><A name="x_ac"></A>
        Depois de se conectar ao banco de dados, criamos previamente
		uma tabela chamada <CODE class="literal">test</CODE>. Então, inserimos uma linha de dados na
		tabela. Finalmente, demos um <CODE class="literal">commit</CODE>, gravamos a mudança no disco
		e desconectamos do banco de dados. Note que se não tivéssemos
		chamado <CODE class="literal">commit</CODE>, nenhuma mudança final teria sido gravada no banco de dados.
       <SPAN id="comments_x_ac" class="comment"><A class="commenttoggle" id="toggle_x_ac" onclick="return loadComments(&quot;x_ac&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_bc"><A name="x_bc"></A>
        A função <CODE class="literal">run</CODE> retorna o número de linhas modificadas pela consulta. Para a primeira 
		consulta, que criou uma tabela, nenhuma linha foi modificada. A segunda consulta de
		inserção de dados na tabela que inseriu uma única linha a função <CODE class="literal">run</CODE> retornou <CODE class="literal">1</CODE>..
       <SPAN id="comments_x_bc" class="comment"><A class="commenttoggle" id="toggle_x_bc" onclick="return loadComments(&quot;x_bc&quot;)" href="comment: add">No comments</A></SPAN></P></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="database.sqlvalue">SqlValues</H2></DIV></DIV></DIV><P id="x_cc"><A name="x_cc"></A>
		Antes de prosseguir, precisamos discutir um tipo de dados
		introduzidos no HDBC: <CODE class="literal">SqlValue</CODE>. Uma vez que ambos, Haskell
		e SQL são fortemente tipadas o HDBC tenta preservar informações sobre o tipo. 
		Ao mesmo tempo, os tipos do Haskell e do SQL não exatamente idênticos.
		Além disso, os bancos de dados diferentes têm maneiras diferentes de 
		representar os seus tipos como datas ou caracteres especiais em strings.
       <SPAN id="comments_x_cc" class="comment"><A class="commenttoggle" id="toggle_x_cc" pid="x_cc" onclick="return loadComments(&quot;x_cc&quot;)" href="comments: show / hide">5 comments</A></SPAN></P><P id="x_dc"><A name="x_dc"></A>
        <CODE class="literal">SqlValue</CODE> é um tipo de dados que tem um número de construtores
		igual ao do <CODE class="literal">SqlString</CODE>, <CODE class="literal">SqlBool</CODE>, <CODE class="literal">SqlNull</CODE>, <CODE class="literal">SqlInteger</CODE>, etc. 
		Isso permite que você represente vários tipos de dados no banco de dados, e acessar vários
		tipos de dados nos resultados das consultas, e ainda armazená-los, para isto existem as funções <CODE class="literal">toSql</CODE> e <CODE class="literal">fromSql</CODE> 
		que são normalmente usadas para este fim. Se você se preocupa com a representação exata dos
		dados você ainda pode construir manualmente as <CODE class="literal">SqlValue</CODE> dos dados se você precisar.
       <SPAN id="comments_x_dc" class="comment"><A class="commenttoggle" id="toggle_x_dc" pid="x_dc" onclick="return loadComments(&quot;x_dc&quot;)" href="comments: show / hide">1 comment</A></SPAN></P></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.args">Parâmetros de Busca</H2></DIV></DIV></DIV><P id="x_ec"><A name="x_ec"></A>
        HDBC, como a maioria dos bancos de dados, suporta um conceito de
		parâmetros substituíveis em consultas. Há três benefícios primários
		de usar parâmetros substituíveis: eles previnem erros nos SQL ou dificuldade
		quando a entrada contiver caracter especial, eles melhoram desempenho ao executar
		consultas semelhantes repetidamente, e eles permitem inserção fácil e portátil de dados em consultas. 
       <SPAN id="comments_x_ec" class="comment"><A class="commenttoggle" id="toggle_x_ec" pid="x_ec" onclick="return loadComments(&quot;x_ec&quot;)" href="comments: show / hide">8 comments</A></SPAN></P><P id="x_fc"><A name="x_fc"></A>
		Digamos que você quer adicionar milhares de filas em nossa nova tabela <CODE class="literal">test</CODE>.
		Você poderia emitir milhares de consultas que se parecem 
		<CODE class="literal">INSERT INTO test VALUES (0,'zero')</CODE> e <CODE class="literal">INSERT INTO test VALUES (1,'one')</CODE>. 
		Isto força o servidor de banco de dados a analisar gramaticalmente cada 
		declaração de SQL individualmente. Se você pudesse substituir os dois 
		valores por um endereço de memória, o servidor poderia analisar gramaticalmente
		o SQL com uma consulta, executando em tempos múltiplos com os dados diferentes. 
       <SPAN id="comments_x_fc" class="comment"><A class="commenttoggle" id="toggle_x_fc" onclick="return loadComments(&quot;x_fc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_gc"><A name="x_gc"></A>
        Um segundo problema envolve caracter de salvamento. Se você quisesse inserir
		a string <CODE class="literal">"I don't like 1"</CODE>?  SQL usa o único caracter especial para mostrar 
		o fim do campo. A maioria dos bancos de dados de SQL lhe exigiria que escrevesse
		dessa forma <CODE class="literal">'I don''t like 1'</CODE>. Mas regras para outros caracteres especiais, como
		backslashes, diferem entre bancos de dados. Em lugar de tentar codificar isto
		você mesmo, o HDBC pode controlar tudo para você. Veja um exemplo.
       <SPAN id="comments_x_gc" class="comment"><A class="commenttoggle" id="toggle_x_gc" pid="x_gc" onclick="return loadComments(&quot;x_gc&quot;)" href="comments: show / hide">4 comments</A></SPAN></P><A name="query.ghci:runargs"></A><PRE id="query.ghci:runargs" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>run conn "INSERT INTO test VALUES (?, ?)" [toSql 0, toSql "zero"]</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>commit conn</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:runargs" class="comment"><A class="commenttoggle" id="toggle_query.ghci:runargs" pid="query.ghci:runargs" onclick="return loadComments(&quot;query.ghci:runargs&quot;)" href="comments: show / hide">3 comments</A></SPAN><P id="x_hc"><A name="x_hc"></A>
		Os pontos de interrogação na pesquisa INSERT neste exemplo são os
		endereços de memória. Nós passamos os parâmetros que serão encaminahdos para lá. 
		<CODE class="literal">run</CODE> leva uma lista de <CODE class="literal">SqlValue</CODE>, então nós usamos <CODE class="literal">toSql</CODE> para 
		converter cada item em um <CODE class="literal">SqlValue</CODE>. O HDBC automaticamente controla
		a conversão no uso da <CODE class="literal">String</CODE>  <CODE class="literal">"zero"</CODE> na representação apropriada para o banco de dados. 
       <SPAN id="comments_x_hc" class="comment"><A class="commenttoggle" id="toggle_x_hc" onclick="return loadComments(&quot;x_hc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_ic"><A name="x_ic"></A>
        Esta aproximação na verdade não alcançará qualquer desempenho benéfico ao inserir 
		grandes quantidades de dados. Para isso, nós precisamos de mais controle em cima do processo de criar a consulta SQL.
       <SPAN id="comments_x_ic" class="comment"><A class="commenttoggle" id="toggle_x_ic" onclick="return loadComments(&quot;x_ic&quot;)" href="comment: add">No comments</A></SPAN></P><DIV class="note"><TABLE border="0" summary="Note: Using replaceable parameters"><TBODY><TR><TD rowspan="2" align="center" valign="top" width="25"><IMG alt="[Note]" src="./Chapter 21. Using Databases_files/note.png"></TD><TH align="left">Usando Declarações Realocáveis </TH></TR><TR><TD align="left" valign="top"><P id="x_jc"><A name="x_jc"></A>
          Declarações Realocáveis apenas trabalham como parte de consultas
          onde o servidor é esperado como valor, como uma cláusula onde uma declaração SELECT ou um valor para uma declaração INSERT.
          Você não pode declarar <CODE class="literal">run "SELECT * from ?"
          [toSql "tablename"]</CODE> e epserar que funcione. Uma nome tabela não é um valor, e a maioria dos bancos de dados não aceitará esta sintaxe.
          Na prática não é um grande problema, porque raramente chamadas para recolocar coisas que não são valores são chamadas deste modo.
         <SPAN id="comments_x_jc" class="comment"><A class="commenttoggle" id="toggle_x_jc" pid="x_jc" onclick="return loadComments(&quot;x_jc&quot;)" href="comments: show / hide">4 comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.statements">Declarações Preparadas</H2></DIV></DIV></DIV><P id="x_kc"><A name="x_kc"></A>
        HDBC define uma função <CODE class="literal">prepare</CODE> que preparará uma consulta de SQL, mas ainda não liga os parâmetros à consulta. <CODE class="literal">prepare</CODE> retorna <CODE class="literal">Statement</CODE> que representa a consulta compilada.
       <SPAN id="comments_x_kc" class="comment"><A class="commenttoggle" id="toggle_x_kc" pid="x_kc" onclick="return loadComments(&quot;x_kc&quot;)" href="comments: show / hide">3 comments</A></SPAN></P><P id="x_lc"><A name="x_lc"></A>
        Uma vez você tem uma <CODE class="literal">Statement</CODE>, você pode fazer várias coisas com isto. Você pode chamar
		<CODE class="literal">execute</CODE> nisto um ou mais vezes. Depois de chamar <CODE class="literal">execute</CODE> 
		em uma consulta que retorna dados, você pode usar uma função de recuperação para recuperar aqueles dados.
		Funções como <CODE class="literal">run</CODE> e <CODE class="literal">quickQuery'</CODE> usam declarações e a função <CODE class="literal">execute</CODE>
		interiormente; eles simplesmente são atalhos para deixar você executar tarefas comuns depressa. Quando 
		você precisar de mais controle sobre o que está acontecendo, você pode usar uma <CODE class="literal">Statement</CODE> em vez de uma função como <CODE class="literal">run</CODE>. 
       <SPAN id="comments_x_lc" class="comment"><A class="commenttoggle" id="toggle_x_lc" pid="x_lc" onclick="return loadComments(&quot;x_lc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_mc"><A name="x_mc"></A>
       Veja que usar declarações para inserir valores múltiplos com uma única consulta. Aqui está um exemplo:
       <SPAN id="comments_x_mc" class="comment"><A class="commenttoggle" id="toggle_x_mc" onclick="return loadComments(&quot;x_mc&quot;)" href="comment: add">No comments</A></SPAN></P><A name="query.ghci:mult"></A><PRE id="query.ghci:mult" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>stmt &lt;- prepare conn "INSERT INTO test VALUES (?, ?)"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>execute stmt [toSql 1, toSql "one"]</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>execute stmt [toSql 2, toSql "two"]</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>execute stmt [toSql 3, toSql "three"]</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>execute stmt [toSql 4, SqlNull]</CODE></STRONG>
1
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>commit conn</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:mult" class="comment"><A class="commenttoggle" id="toggle_query.ghci:mult" onclick="return loadComments(&quot;query.ghci:mult&quot;)" href="comment: add">No comments</A></SPAN><P id="x_nc"><A name="x_nc"></A>
        Neste exemplo, nós criamos uma declaração preparada e chamamos de <CODE class="literal">stmt</CODE>.
		Nós executamos aquela declaração então quatro vezes, e passamos parâmetros diferentes a cada hora. 
		Estes parâmetros são usados, em ordem, para substituir os pontos de interrogação na String de consulta original. Finalmente, fazemos as mudanças e desconectamos o banco de dados. 
       <SPAN id="comments_x_nc" class="comment"><A class="commenttoggle" id="toggle_x_nc" pid="x_nc" onclick="return loadComments(&quot;x_nc&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><P id="x_oc"><A name="x_oc"></A>
        HDBC também provê uma função <CODE class="literal">executeMany</CODE> que pode ser útil em situações como esta. 
		A função <CODE class="literal">executeMany</CODE> leva uma lista de filas de dados simplesmente para chamar a declaração. Aqui está um exemplo:
       <SPAN id="comments_x_oc" class="comment"><A class="commenttoggle" id="toggle_x_oc" pid="x_oc" onclick="return loadComments(&quot;x_oc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><A name="query.ghci:executeMany"></A><PRE id="query.ghci:executeMany" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>stmt &lt;- prepare conn "INSERT INTO test VALUES (?, ?)"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>executeMany stmt [[toSql 5, toSql "five's nice"], [toSql 6, SqlNull]]</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>commit conn</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:executeMany" class="comment"><A class="commenttoggle" id="toggle_query.ghci:executeMany" onclick="return loadComments(&quot;query.ghci:executeMany&quot;)" href="comment: add">No comments</A></SPAN><DIV class="note"><TABLE border="0" summary="Note: More efficient execution"><TBODY><TR><TD rowspan="2" align="center" valign="top" width="25"><IMG alt="[Note]" src="./Chapter 21. Using Databases_files/note.png"></TD><TH align="left">Execução mais eficiente</TH></TR><TR><TD align="left" valign="top"><P id="x_pc"><A name="x_pc"></A>
          No servidor, a maioria dos bancos de dados terão uma otimização que eles podem aplicar 
          <CODE class="literal">executeMany</CODE> para então ter de compilar esta string consulta uma vez, ao invés de duas.
		  <SUP>[<A name="id668986" href="http://book.realworldhaskell.org/read/using-databases.html#ftn.id668986" class="footnote">52</A>]</SUP> Isto pode levar a um ganho dramático de memória
		  quando a inserção usa grandes volumes de dados de uma vez. Alguns bancos de dados podem também aplicar esta otimização ao
          <CODE class="literal">execute</CODE>, mas não a tudo.
         <SPAN id="comments_x_pc" class="comment"><A class="commenttoggle" id="toggle_x_pc" pid="x_pc" onclick="return loadComments(&quot;x_pc&quot;)" href="comments: show / hide">5 comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.readingresults">Leitura dos Resultados</H2></DIV></DIV></DIV><P id="x_rc"><A name="x_rc"></A>
        Até agora, discutimos as consultas que inserem ou alteram dados.
		Vamos discutir a obtenção de dados de volta para fora do banco de dados.
		O tipo da função <CODE class="literal">quickQuery'</CODE> se assemelha muito a <CODE class="literal">run</CODE>, mas ele retorna
		uma lista de resultados, em vez de uma contagem de linhas alteradas.
		<CODE class="literal">quickQuery'</CODE> é normalmente é usado com SELECT. Vamos ver um exemplo:
       <SPAN id="comments_x_rc" class="comment"><A class="commenttoggle" id="toggle_x_rc" pid="x_rc" onclick="return loadComments(&quot;x_rc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><A name="query.ghci:qqp"></A><PRE id="query.ghci:qqp" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>quickQuery' conn "SELECT * from test where id &lt; 2" []</CODE></STRONG>
[[SqlString "0",SqlNull],[SqlString "0",SqlString "zero"],[SqlString "1",SqlString "one"]]
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:qqp" class="comment"><A class="commenttoggle" id="toggle_query.ghci:qqp" pid="query.ghci:qqp" onclick="return loadComments(&quot;query.ghci:qqp&quot;)" href="comments: show / hide">5 comments</A></SPAN><P id="x_sc"><A name="x_sc"></A>
        <CODE class="literal">quickQuery'</CODE> trabalha com parâmetros substituíveis, como discutimos acima.
		Neste caso, não estamos usando nenhum, então o conjunto de valores para substituir
		é uma lista vazia no final da chamada do <CODE class="literal">quickQuery'</CODE>. <CODE class="literal">quickQuery'</CODE> retorna uma
		lista de linhas, onde cada linha é em si representado como <CODE class="literal">[SqlValue]</CODE>. Os valores
		da linha são listados na ordem retornada pelo banco de dados. Pode-se usar
		<CODE class="literal">fromSql</CODE> para convertê-las em tipos regulares Haskell, conforme necessário.
       <SPAN id="comments_x_sc" class="comment"><A class="commenttoggle" id="toggle_x_sc" onclick="return loadComments(&quot;x_sc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_tc"><A name="x_tc"></A>
        É um pouco difícil de ler a saída.
		Vamos estender este exemplo para formatar bem os resultados. 
		Aqui está um código para fazer isso:
       <SPAN id="comments_x_tc" class="comment"><A class="commenttoggle" id="toggle_x_tc" onclick="return loadComments(&quot;x_tc&quot;)" href="comment: add">No comments</A></SPAN></P><A name="query.hs:all"></A><PRE id="query.hs:all" class="programlisting">-- file: ch21/query.hs
import Database.HDBC.Sqlite3 (connectSqlite3)
import Database.HDBC

{- | Definir uma função que recebe um inteiro que representa o máximo id do valor acima.
Buscar todas as linhas correspondentes do banco de dados de teste e 
imprimi-las para a tela em um formato amigável. -}
query :: Int -&gt; IO ()
query maxId = 
    do -- Connect to the database
       conn &lt;- connectSqlite3 "test1.db"

       -- Run the query and store the results in r
       r &lt;- quickQuery' conn
            "SELECT id, desc from test where id &lt;= ? ORDER BY id, desc"
            [toSql maxId]

       -- Convert each row into a String
       let stringRows = map convRow r
                        
       -- Print the rows out
       mapM_ putStrLn stringRows

       -- And disconnect from the database
       disconnect conn

    where convRow :: [SqlValue] -&gt; String
          convRow [sqlId, sqlDesc] = 
              show intid ++ ": " ++ desc
              where intid = (fromSql sqlId)::Integer
                    desc = case fromSql sqlDesc of
                             Just x -&gt; x
                             Nothing -&gt; "NULL"
          convRow x = fail $ "Unexpected result: " ++ show x</PRE> <SPAN id="comments_query.hs:all" class="comment"><A class="commenttoggle" id="toggle_query.hs:all" pid="query.hs:all" onclick="return loadComments(&quot;query.hs:all&quot;)" href="comments: show / hide">4 comments</A></SPAN><P id="x_uc"><A name="x_uc"></A>
       
		
		Este programa é essencialmente a mesma coisa que o nosso exemplo
		com <SPAN class="command"><STRONG>ghci</STRONG></SPAN>, mas com uma novidade: a função <CODE class="literal">convRow</CODE>. Esta função tem 
		uma linha de dados do banco de dados e converte para uma <CODE class="literal">String</CODE>.
		Essa string pode então ser facilmente impressa.
       <SPAN id="comments_x_uc" class="comment"><A class="commenttoggle" id="toggle_x_uc" pid="x_uc" onclick="return loadComments(&quot;x_uc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_vc"><A name="x_vc"></A>
        Observe como tomamos <CODE class="literal">intid</CODE> de <CODE class="literal">fromSql</CODE> diretamente, mas o <CODE class="literal">fromSql sqlDesc</CODE>
		processado como um tipo <CODE class="literal">Maybe String</CODE>.
		
		Se você lembrar, declaramos que a primeira coluna desta tabela não pode conter um 
		valor nulo, mas que a segunda coluna poderia. Portanto, podemos ignorar o potencial 
		para um nulo na primeira coluna, mas não na segunda. É possível usar <CODE class="literal">fromSql</CODE> para
		converter a segunda coluna para uma <CODE class="literal">String</CODE> diretamente, e seria o  mesmo trabalho
		- até que uma linha com nulo na posição seja encontrado, o que causaria uma exceção 
		do tempo de execução. Então, nós convertemos um valor nulo do SQL na string <CODE class="literal">"NULL"</CODE>. 
		Quando impresso, isso será equivalente a uma string SQL <CODE class="literal">'NULL'</CODE>, mas que é aceitável 
		para este exemplo. Vamos tentar chamar essa função em <SPAN class="command"><STRONG>ghci</STRONG></SPAN>:
       <SPAN id="comments_x_vc" class="comment"><A class="commenttoggle" id="toggle_x_vc" pid="x_vc" onclick="return loadComments(&quot;x_vc&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><A name="query.ghci:queryhs"></A><PRE id="query.ghci:queryhs" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>:load query.hs</CODE></STRONG>
[1 of 1] Compiling Main             ( query.hs, interpreted )
Ok, modules loaded: Main.
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>query 2</CODE></STRONG>
0: NULL
0: zero
1: one
2: two
</PRE> <SPAN id="comments_query.ghci:queryhs" class="comment"><A class="commenttoggle" id="toggle_query.ghci:queryhs" onclick="return loadComments(&quot;query.ghci:queryhs&quot;)" href="comment: add">No comments</A></SPAN><DIV class="sect2" lang="en"><DIV class="titlepage"><DIV><DIV><H3 class="title" id="databases.readingstatements">Leitura de Declarações</H3></DIV></DIV></DIV><P id="x_wc"><A name="x_wc"></A>
          Como discutimos na seção chamada <A class="xref" href="http://book.realworldhaskell.org/read/using-databases.html#databases.statements" title="Prepared Statements">“Declarações Preparadas”</A>,
		  você pode usar as instruções para a leitura. Existem várias
		  maneiras de leitura de dados a partir de instruções que podem
		  ser úteis em determinadas situações. Como a <CODE class="literal">run</CODE>, <CODE class="literal">quickQuery'</CODE>
		  são funções de conveniência que na verdade usam instruções para 
		  realizar sua tarefa. 
         <SPAN id="comments_x_wc" class="comment"><A class="commenttoggle" id="toggle_x_wc" onclick="return loadComments(&quot;x_wc&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_xc"><A name="x_xc"></A>
          Para criar uma instrução para a leitura use <CODE class="literal">prepare</CODE> do mesmo modo 
		  como faria para uma instrução que seria utilizada para gravar dados.
		  Você também pode usar <CODE class="literal">execute</CODE> para executá-la sobre o servidor de banco de dados. 
		  Depois, você pode usar várias funções para ler os dados da <CODE class="literal">Statement</CODE>.
		  A função <CODE class="literal">fetchAllRows'</CODE> retorna <CODE class="literal">[[SqlValue]]</CODE>, assim como <CODE class="literal">quickQuery'</CODE>. 
		  Há também uma função chamada <CODE class="literal">sFetchAllRows'</CODE>, que converte dados de cada
		  coluna em um <CODE class="literal">Maybe String</CODE> antes de retorná-lo. Finalmente, há <CODE class="literal">fetchAllRows'</CODE>,
		  que retorna <CODE class="literal">(String, SqlValue)</CODE> pares de cada coluna.
		  
		A String é o nome da coluna retornado pelo banco de dados, veja a seção 
		chamada <A class="xref" href="http://book.realworldhaskell.org/read/using-databases.html#databases.metadata" title="Database Metadata">“Metadados de Bancos de Dados”</A> para outras formas de obter os nomes de coluna.
         <SPAN id="comments_x_xc" class="comment"><A class="commenttoggle" id="toggle_x_xc" pid="x_xc" onclick="return loadComments(&quot;x_xc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_yc"><A name="x_yc"></A>
          Você também pode ler dados de uma linha por vez, chamada  <CODE class="literal">fetchRow</CODE>,
		  que retorna a <CODE class="literal">IO (Maybe [SqlValue])</CODE>. Ela será <CODE class="literal">Nothing</CODE> se todos os
		  resultados já foram lidos, ou uma linha em contrário. 
         <SPAN id="comments_x_yc" class="comment"><A class="commenttoggle" id="toggle_x_yc" onclick="return loadComments(&quot;x_yc&quot;)" href="comment: add">No comments</A></SPAN></P></DIV><DIV class="sect2" lang="en"><DIV class="titlepage"><DIV><DIV><H3 class="title" id="databases.readinglazy">Leitura Preguiçosa</H3></DIV></DIV></DIV><P id="x_zc"><A name="x_zc"></A>
          Voltando na seção chamada <A class="xref" href="http://book.realworldhaskell.org/read/io.html#io.lazy" title="Lazy I/O">“Lazy I/O”</A>, 
		  nós falamos sobre E/S preguiçosa de arquivos. Também é possível ler dados a partir de bases de dados preguiçosamente. Isto pode ser
		  particularmente útil quando se trata de consultas que retornam uma quantidade 
		  excepcionalmente grande de dados. Ao ler dados preguiçosamente, você ainda pode usar
		  as funções convenientes, tais como <CODE class="literal">fetchAllRows</CODE> em vez de ter que manualmente ler cada
		  linha como se apresenta. Se você for cuidadoso no uso dos dados, você pode evitar 
		  ter todos os dados do buffer na memória.
         <SPAN id="comments_x_zc" class="comment"><A class="commenttoggle" id="toggle_x_zc" pid="x_zc" onclick="return loadComments(&quot;x_zc&quot;)" href="comments: show / hide">2 comments</A></SPAN></P><P id="x_Ad"><A name="x_Ad"></A>
          Leitura Preguiçosa de um banco de dados, no entanto, é mais complexa
		  do que a leitura de um arquivo. Quando você terminar de ler 
		  preguiçosamente dados de um arquivo, o arquivo é fechado, o 
		  que geralmente é bom. Quando você terminar de ler preguiçosamente
		  dados de um banco, a conexão do banco de dados ainda está em aberto
		  - podendo apresentar outras consultas com ele, por exemplo. 
		  Alguns bancos de dados podem ainda oferecer suporte a várias consultas
		  simultâneas, assim o HDBC não pode simplesmente fechar a conexão 
		  quando estiver pronto.
         <SPAN id="comments_x_Ad" class="comment"><A class="commenttoggle" id="toggle_x_Ad" pid="x_Ad" onclick="return loadComments(&quot;x_Ad&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><P id="x_Bd"><A name="x_Bd"></A>
         Ao usar a leitura preguiçosa, é extremamente importante terminar de 
		 ler o conjunto total de dados antes de tentar fechar a conexão ou 
		 executar uma nova consulta. Nós encorajamos você a utilizar as funções
		 estritas, ou de transformação de linha por linha, sempre que possível
		 para minimizar as interações complexas com a leitura preguiçosa. 
         <SPAN id="comments_x_Bd" class="comment"><A class="commenttoggle" id="toggle_x_Bd" pid="x_Bd" onclick="return loadComments(&quot;x_Bd&quot;)" href="comments: show / hide">3 comments</A></SPAN></P><DIV class="tip"><TABLE border="0" summary="Tip"><TBODY><TR><TD rowspan="2" align="center" valign="top" width="25"><IMG alt="[Tip]" src="./Chapter 21. Using Databases_files/tip.png"></TD><TH align="left">Dica</TH></TR><TR><TD align="left" valign="top"><P id="x_gv"><A name="x_gv"></A>
            Se você é novo no HDBC ou no conceito de leitura preguiçosa,
			mas têm grandes quantidades de dados para ler, repetidas
			chamadas para  <CODE class="literal">fetchRow</CODE> pode ser mais fácil de entender. 
			Leitura Preguiçosa é uma ferramenta poderosa e útil, mas deve ser usada corretamente.
           <SPAN id="comments_x_gv" class="comment"><A class="commenttoggle" id="toggle_x_gv" onclick="return loadComments(&quot;x_gv&quot;)" href="comment: add">No comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV><P id="x_Cd"><A name="x_Cd"></A>
          Para ler preguiçosamente um banco de dados, você pode usar as mesmas 
		  funções que você usou antes, sem o apóstrofo. Por exemplo, você pode 
		  usar no lugar do <CODE class="literal">fetchAllRows'</CODE>, o <CODE class="literal">fetchAllRows</CODE>. Os tipos de funções 
		  preguiçosas são as mesmas que seus primos estritos. 
		  Aqui está um exemplo de leitura preguiçosa: 
         <SPAN id="comments_x_Cd" class="comment"><A class="commenttoggle" id="toggle_x_Cd" onclick="return loadComments(&quot;x_Cd&quot;)" href="comment: add">No comments</A></SPAN></P><A name="query.ghci:far"></A><PRE id="query.ghci:far" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>stmt &lt;- prepare conn "SELECT * from test where id &lt; 2"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>execute stmt []</CODE></STRONG>
0
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>results &lt;- fetchAllRowsAL stmt</CODE></STRONG>
[[("id",SqlString "0"),("desc",SqlNull)],[("id",SqlString "0"),("desc",SqlString "zero")],[("id",SqlString "1"),("desc",SqlString "one")]]
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>mapM_ print results</CODE></STRONG>
[("id",SqlString "0"),("desc",SqlNull)]
[("id",SqlString "0"),("desc",SqlString "zero")]
[("id",SqlString "1"),("desc",SqlString "one")]
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:far" class="comment"><A class="commenttoggle" id="toggle_query.ghci:far" pid="query.ghci:far" onclick="return loadComments(&quot;query.ghci:far&quot;)" href="comments: show / hide">1 comment</A></SPAN><P id="x_Dd"><A name="x_Dd"></A>
          Note que você poderia ter usado <CODE class="literal">fetchAllRowsAL'</CODE> aqui também. 
		  No entanto, se você tivesse um grande conjunto de dados para 
		  ler, teria consumido uma grande quantidade de memória. Ao ler 
		  os dados preguiçosamente, podemos imprimir conjunstos de resultados extremamente 
		  grandes usando uma quantidade constante de memória. Com a 
		  versão lenta, os resultados serão avaliado em blocos, com a versão rigorosa,
		  todos os resultado são lidos na frente, armazenadas na memória RAM, em seguida, impressos.
         <SPAN id="comments_x_Dd" class="comment"><A class="commenttoggle" id="toggle_x_Dd" pid="x_Dd" onclick="return loadComments(&quot;x_Dd&quot;)" href="comments: show / hide">3 comments</A></SPAN></P></DIV></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.metadata">Metadados de Banco de Dados</H2></DIV></DIV></DIV><P id="x_Ed"><A name="x_Ed"></A>
        Às vezes pode ser útil para um programa para saber informações sobre 
		o próprio banco de dados. Por exemplo, um programa pode querer ver que 
		existem tabelas de modo que ele possa criar automaticamente as tabelas 
		em falta ou atualizar o esquema do banco de dados. Em alguns casos, um 
		programa pode precisar alterar o seu comportamento, dependendo do banco
		de dados back-end em uso.
       <SPAN id="comments_x_Ed" class="comment"><A class="commenttoggle" id="toggle_x_Ed" onclick="return loadComments(&quot;x_Ed&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Fd"><A name="x_Fd"></A>
        Primeiro, existe uma função <CODE class="literal">getTables</CODE> que vai obter uma lista das tabelas 
		definidas em um banco de dados. Você também pode usar a função <CODE class="literal">describeTable</CODE>, 
		que irá fornecer informações sobre as colunas definidas em uma determinada tabela. 
       <SPAN id="comments_x_Fd" class="comment"><A class="commenttoggle" id="toggle_x_Fd" onclick="return loadComments(&quot;x_Fd&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Gd"><A name="x_Gd"></A>
        Você pode aprender sobre o servidor de banco de dados em uso chamando <CODE class="literal">dbServerVer</CODE>
		e <CODE class="literal">proxiedClientName</CODE>, por exemplo. A função <CODE class="literal">dbTransactionSupport</CODE> pode ser usada 
		para determinar se um banco de dados oferece, ou não, suporte a transações.
		Vejamos um exemplo de alguns desses itens:
       <SPAN id="comments_x_Gd" class="comment"><A class="commenttoggle" id="toggle_x_Gd" pid="x_Gd" onclick="return loadComments(&quot;x_Gd&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><A name="query.ghci:metadata"></A><PRE id="query.ghci:metadata" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>getTables conn</CODE></STRONG>
["test"]
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>proxiedClientName conn</CODE></STRONG>
"sqlite3"
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>dbServerVer conn</CODE></STRONG>
"3.5.9"
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>dbTransactionSupport conn</CODE></STRONG>
True
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:metadata" class="comment"><A class="commenttoggle" id="toggle_query.ghci:metadata" onclick="return loadComments(&quot;query.ghci:metadata&quot;)" href="comment: add">No comments</A></SPAN><P id="x_Hd"><A name="x_Hd"></A>
        Você também pode aprender sobre os resultados de uma consulta específica e
		obter informações de sua declaração. A função <CODE class="literal">describeResult</CODE> retorna 
		<CODE class="literal">[(String, SqlColDesc)]</CODE>, uma lista de pares. O primeiro item que dá o 
		nome da coluna, e o segundo fornece informações sobre a coluna: o tipo,
		o tamanho, e se ele pode ser NULL. A especificação completa é dada na 
		referência API HDBC.
       <SPAN id="comments_x_Hd" class="comment"><A class="commenttoggle" id="toggle_x_Hd" pid="x_Hd" onclick="return loadComments(&quot;x_Hd&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><P id="x_Id"><A name="x_Id"></A>
        Note que algumas bases de dados podem não ser capazes de fornecer todos os metadados. 
		Nestas circunstâncias, uma exceção será levantada. Sqlite3, por exemplo, não suporta
		<CODE class="literal">describeResult</CODE> ou <CODE class="literal">describeTable</CODE> do modo presente escrito.
       <SPAN id="comments_x_Id" class="comment"><A class="commenttoggle" id="toggle_x_Id" pid="x_Id" onclick="return loadComments(&quot;x_Id&quot;)" href="comments: show / hide">1 comment</A></SPAN></P></DIV><DIV class="sect1" lang="en"><DIV class="titlepage"><DIV><DIV><H2 class="title" style="clear: both" id="databases.errors">Tratamento de Erros</H2></DIV></DIV></DIV><P id="x_Jd"><A name="x_Jd"></A>
        HDBC utilizará exceções quando erros acontecerem. As exceções têm 
		tipo <CODE class="literal">SqlError</CODE>. Elas carregam informação da máquina de SQL subjacente,
		como o estado do banco de dados, a mensagem de erro, e o código de erro
		numérico do banco de dados, etc. <SPAN id="comments_x_Jd" class="comment"><A class="commenttoggle" id="toggle_x_Jd" pid="x_Jd" onclick="return loadComments(&quot;x_Jd&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><P id="x_Kd"><A name="x_Kd"></A>
		<SPAN class="command"><STRONG>ghc</STRONG></SPAN> não sabe exibir um <CODE class="literal">SqlError</CODE> 
		na tela quando acontece.
		Enquanto a exceção fará o programa terminar, não será exibida uma mensagem útil. Aqui está um exemplo: 
       <SPAN id="comments_x_Kd" class="comment"><A class="commenttoggle" id="toggle_x_Kd" pid="x_Kd" onclick="return loadComments(&quot;x_Kd&quot;)" href="comments: show / hide">1 comment</A></SPAN></P><A name="query.ghci:error1"></A><PRE id="query.ghci:error1" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>quickQuery' conn "SELECT * from test2" []</CODE></STRONG>
*** Exception: (unknown)
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:error1" class="comment"><A class="commenttoggle" id="toggle_query.ghci:error1" pid="query.ghci:error1" onclick="return loadComments(&quot;query.ghci:error1&quot;)" href="comments: show / hide">1 comment</A></SPAN><P id="x_Ld"><A name="x_Ld"></A>
        Aqui nós tentamos SELECIONAR dados de uma tabela que não existia. A mensagem de erro que voltamos não foi útil. 
		Há uma função utilitária, <CODE class="literal">handleSqlError</CODE> que captura um <CODE class="literal">SqlError</CODE>
		e aumenta isto como um <CODE class="literal">IOError</CODE>. Desta forma, será exibido um ponto de impressão na tela, mas será mais difícil de extrair pedaços específicos de informação.
		Vejamos o seu uso:
       <SPAN id="comments_x_Ld" class="comment"><A class="commenttoggle" id="toggle_x_Ld" onclick="return loadComments(&quot;x_Ld&quot;)" href="comment: add">No comments</A></SPAN></P><A name="query.ghci:error2"></A><PRE id="query.ghci:error2" class="screen"><CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>conn &lt;- connectSqlite3 "test1.db"</CODE></STRONG>
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>handleSqlError $ quickQuery' conn "SELECT * from test2" []</CODE></STRONG>
*** Exception: user error (SQL error: SqlError {seState = "", seNativeError = 1, seErrorMsg = "prepare 20: SELECT * from test2: no such table: test2"})
<CODE class="prompt">ghci&gt; </CODE><STRONG class="userinput"><CODE>disconnect conn</CODE></STRONG>
</PRE> <SPAN id="comments_query.ghci:error2" class="comment"><A class="commenttoggle" id="toggle_query.ghci:error2" pid="query.ghci:error2" onclick="return loadComments(&quot;query.ghci:error2&quot;)" href="comments: show / hide">2 comments</A></SPAN><P id="x_Md"><A name="x_Md"></A>
        Aqui nós adquirimos mais informações, enquanto incluímos uma declaração
		de mensagem que não há nenhuma tal tabela como test2. Isto é muito mais útil.
		Muitos programadores de HDBC fazem disto uma prática padrão para iniciar os 
		programas deles com main = <CODE class="literal">main = handleSqlError $ do</CODE>,
		que assegurará que todo <CODE class="literal">SqlError</CODE> capturado será imprimido de uma maneira útil. 		
       <SPAN id="comments_x_Md" class="comment"><A class="commenttoggle" id="toggle_x_Md" onclick="return loadComments(&quot;x_Md&quot;)" href="comment: add">No comments</A></SPAN></P><P id="x_Nd"><A name="x_Nd"></A>
        Também há <CODE class="literal">catchSql</CODE>
		e  <CODE class="literal">handleSql</CODE> -- semelhantes as funções padrão <CODE class="literal">catch</CODE> e
		<CODE class="literal">handle</CODE> e funções de controle.
		<CODE class="literal">catchSql</CODE> e <CODE class="literal">handleSql</CODE> interceptarão só erros de HDBC.
        Para mais informações no tratamento de erros, acesse
		<A class="xref" href="http://book.realworldhaskell.org/read/error-handling.html" title="Chapter&nbsp;19.&nbsp;Error handling">Capítulo&nbsp;19, <I>Tratamento de Erro</I></A>.
       <SPAN id="comments_x_Nd" class="comment"><A class="commenttoggle" id="toggle_x_Nd" onclick="return loadComments(&quot;x_Nd&quot;)" href="comment: add">No comments</A></SPAN></P></DIV><DIV class="footnotes"><BR><HR width="100" align="left"><DIV class="footnote"><P><SUP>[<A name="ftn.id667806" href="http://book.realworldhaskell.org/read/using-databases.html#id667806" class="para">49</A>] </SUP>
            The O'Reilly books <SPAN class="emphasis"><EM>Learning SQL</EM></SPAN> and
            <SPAN class="emphasis"><EM>SQL in a Nutshell</EM></SPAN> may be useful if
            you don't have experience wiht SQL.
          </P></DIV><DIV class="footnote"><P><SUP>[<A name="ftn.id667844" href="http://book.realworldhaskell.org/read/using-databases.html#id667844" class="para">50</A>] </SUP>This assumes you restrict yourself to
            using standard SQL.</P></DIV><DIV class="footnote"><P><SUP>[<A name="ftn.id667890" href="http://book.realworldhaskell.org/read/using-databases.html#id667890" class="para">51</A>] </SUP>Para mais informação na instalação de pacotes Haskell,
			acesse
        <A class="xref" href="http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html#installing.haskell.software" title="Installing Haskell software">the section called “Installing Haskell software”</A>.</P></DIV><DIV class="footnote"><P><SUP>[<A name="ftn.id668986" href="http://book.realworldhaskell.org/read/using-databases.html#id668986" class="para">52</A>] </SUP>HDBC
        </P></DIV></DIV></DIV><DIV class="rwhfooter"><P><IMG src="./Chapter 21. Using Databases_files/rss.png"> Want to stay up to date? Subscribe to the comment feed for <A id="chapterfeed" class="feed" href="http://book.realworldhaskell.org/feeds/comments/databases/">this chapter</A>, or the <A class="feed" href="http://book.realworldhaskell.org/feeds/comments/">entire book</A>.</P><P>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart, and
      John Goerzen. This work is licensed under a <A rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
      Commons Attribution-Noncommercial 3.0 License</A>. Icons by <A href="mailto:mattahan@gmail.com">Paul Davey</A> aka <A href="http://mattahan.deviantart.com/">Mattahan</A>.</P></DIV><DIV class="navfooter"><TABLE width="100%" summary="Navigation footer"><TBODY><TR><TD width="40%" align="left"><A accesskey="p" href="http://book.realworldhaskell.org/read/systems-programming-in-haskell.html">Prev</A>&nbsp;</TD><TD width="20%" align="center">&nbsp;</TD><TD width="40%" align="right">&nbsp;<A accesskey="n" href="http://book.realworldhaskell.org/read/extended-example-web-client-programming.html">Next</A></TD></TR><TR><TD width="40%" align="left" valign="top">Chapter&nbsp;20.&nbsp;Systems Programming in Haskell&nbsp;</TD><TD width="20%" align="center"><A accesskey="h" href="http://book.realworldhaskell.org/read/index.html">Home</A></TD><TD width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;22.&nbsp;Extended Example: Web Client Programming</TD></TR></TBODY></TABLE></DIV><SCRIPT src="./Chapter 21. Using Databases_files/urchin.js" type="text/javascript"></SCRIPT><SCRIPT type="text/javascript">_uacct = "UA-1805907-3"; urchinTracker();</SCRIPT>
</BODY><EMBED type="application/x-cooliris-page" hidden="true" id="coolirisBridge" launchable="false"></HTML>