<html><head><title>Cap&iacute;tulo 11 - Testes</title><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c17{color:#000000;font-size:12pt;background-color:#f0f4ff;font-family:Verdana}.c1{line-height:1.5;text-indent:36.0pt;text-align:justify;direction:ltr}.c0{line-height:1.5;text-indent:0pt;text-align:justify;direction:ltr}.c11{line-height:1.5;text-indent:0pt;direction:ltr}.c2{color:#000000;font-size:11pt;font-family:Courier New}.c12{line-height:1.5;text-indent:36.0pt;direction:ltr}.c9{color:#000000;font-size:18pt;font-family:Arial}.c10{color:#000000;font-size:14pt;font-family:Arial}.c3{line-height:1.15;text-indent:0pt;direction:ltr}.c8{color:#000000;font-size:8pt;font-family:Arial}.c14{line-height:1.15;text-indent:36.0pt;direction:ltr}.c15{color:#000000;font-size:11pt;font-family:Cambria}.c4{color:#000000;font-size:11pt;font-family:Arial}.c16{background-color:#e7ffc7}.c18{font-weight:bold}.c7{background-color:#ffffff}.c13{margin-left:36.0pt}.c5{font-style:italic}.c6{text-align:justify}</style></head><body class="c7"><p class="c0"><span class="c9">Cap&iacute;tulo 11 &ndash; Testes e garantia de qualidade</span></p><p class="c1"><span class="c4">Construir sistemas reais significa ter cuidado com o controle de qualidade, robustez e precis&atilde;o. Com os mecanismos certos para a garantia de qualidade, c&oacute;digo bem-escrito pode parecer uma m&aacute;quina precisa, com todas as fun&ccedil;&otilde;es executando suas tarefas de acordo com as especifica&ccedil;&otilde;es. N&atilde;o h&aacute; desleixo nas situa&ccedil;&otilde;es cr&iacute;ticas o que resulta em c&oacute;digo que &eacute; auto-explicativo &ndash; e obviamente correto &ndash; do tipo que inspira confian&ccedil;a.</span></p><p class="c1"><span class="c4">Em Haskell, existem diversas ferramentas &agrave; disposi&ccedil;&atilde;o para construir tais sistemas precisos. A ferramenta mais &oacute;bvia, e constru&iacute;da na pr&oacute;pria linguagem &eacute; o </span><span class="c2">expressive type system</span><span class="c4">, que permite invariantes complicadas serem executadas estaticamente &ndash; tornando imposs&iacute;vel escrever c&oacute;digo que viole tais restri&ccedil;&otilde;es. Adicionalmente, pureza e polimorfismo promovem um estilo de c&oacute;digo que &eacute; modular, refator&aacute;vel e test&aacute;vel. Este &eacute; o tipo de c&oacute;digo que n&atilde;o cont&eacute;m erros.</span></p><p class="c1"><span class="c4">Os testes possuem um importante papel em manter o c&oacute;digo no caminho certo. Os tradicionais mecanismos de teste em Haskell s&atilde;o os testes unit&aacute;rios(por meio da biblioteca HUnit) e o seu descendente mais poderoso, teste de propriedades baseado em tipo, com o QuickCheck, um framework de testes de c&oacute;digo-livre para Haskell. Testes baseados em propriedades promovem uma abordagem de alto-n&iacute;vel para os testes na forma de fun&ccedil;&otilde;es invariantes abstratas que devem satisfazer universalmente, com os dados reais de testes gerados pela biblioteca para o progamador. Desta forma, o c&oacute;digo pode ser exaustivamente testado com milhares de testes que iriam ser invi&aacute;veis para escrever com as m&atilde;os, geralmente n&atilde;o cobrindo casos especiais que n&atilde;o seriam encontrados.</span></p><p class="c1"><span class="c4">Neste cap&iacute;tulo iremos ver como usar QuickCheck para estabelecer invariantes no c&oacute;digo, e ent&atilde;o re-examinar o pretty printer desenvolvido nos cap&iacute;tulos anteriores, testando-o com o framework. Iremos tamb&eacute;m ver como conduzir o processo de testes com a ferramenta de cobertura de testes do GHC: HPC.</span></p><p class="c0"><span class="c9">QuickCheck &ndash; Teste baseado em tipos</span></p><p class="c1"><span class="c4">Para obter uma ideia geral sobre como funcionam os testes baseado em tipos, iremos come&ccedil;ar com um cen&aacute;rio simples: voc&ecirc; escreveu uma fun&ccedil;&atilde;o espec&iacute;fica de ordena&ccedil;&atilde;o e deseja testar o seu comportamento.</span></p><p class="c1"><span class="c4">Primeiramente, nos importamos a biblioteca QuickCheck e os m&oacute;dulos necess&aacute;rios:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs </span></p><p class="c3"><span class="c2">import Test.QuickCheck </span></p><p class="c11"><span class="c2">import Data.List</span></p><p class="c1"><span class="c4">E a fun&ccedil;&atilde;o que n&oacute;s queremos testar &ndash; uma rotina personalizada de ordena&ccedil;&atilde;o:</span></p><p class="c3"><span class="c4"> </span><span class="c2">-- file: ch11/QC-basics.hs </span></p><p class="c3"><span class="c2">qsort :: Ord a =&gt; [a] -&gt; [a] </span></p><p class="c3"><span class="c2">qsort [] = [] </span></p><p class="c3"><span class="c2">qsort (x:xs) = qsort lhs ++ [x] ++ qsort rhs </span></p><p class="c14"><span class="c2">where lhs = filter (&lt; x) xs </span></p><p class="c12 c13"><span class="c2">rhs = filter (&gt;= x) xs</span></p><p class="c1"><span class="c4">Esta &eacute; a cl&aacute;ssica implementa&ccedil;&atilde;o de ordena&ccedil;&atilde;o em Haskell: um estudo sobre a eleg&acirc;ncia em programa&ccedil;&atilde;o funcional, n&atilde;o em efici&ecirc;ncia(este n&atilde;o &eacute; um algoritmo de ordena&ccedil;&atilde;o </span><span class="c4 c5">in-place</span><span class="c4">, que altera a estrutura). Agora, n&oacute;s queremos checar que esta fun&ccedil;&atilde;o obedece &agrave;s regras b&aacute;sicas que uma boa ordena&ccedil;&atilde;o deveria seguir. Uma invariante &uacute;til para come&ccedil;ar e uma que aparece com frequ&ecirc;ncia em c&oacute;digos puramente funcionais, &eacute; a idempot&ecirc;ncia &ndash; uma fun&ccedil;&atilde;o aplicada duas vezes deve ter o mesmo resultado quando aplicada apenas uma vez. Para a nossa rotina de ordena&ccedil;&atilde;o &ndash; um algoritmo est&aacute;vel de ordena&ccedil;&atilde;o &ndash; isso deve ser sempre verdadeiro, ou a situa&ccedil;&atilde;o ir&aacute; ficar feia. A invariante pode ser codificada como uma simples propriedade, da seguinte maneira:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs </span></p><p class="c11"><span class="c2">prop_idempotent xs = qsort (qsort xs) == qsort xs</span></p><p class="c1"><span class="c4">Iremos usar a conve&ccedil;&atilde;o de QuickCheck de prefixar as propriedades de teste com </span><span class="c2">prop_</span><span class="c4"> para diferenci&aacute;-las de c&oacute;digo normal. A propriedade de idempot&ecirc;ncia &eacute; escrita simplesmente como uma fun&ccedil;&atilde;o Haskell declarando uma igualdade que deve valer para todos os dados da entrada que &eacute; ordenada. Podemos checar &agrave; m&atilde;o que isso faz sentido para alguns casos simples:</span></p><p class="c11"><span class="c2">ghci&gt; prop_idempotent [] &nbsp; &nbsp; &nbsp; <br>True<br>ghci&gt; prop_idempotent [1,1,1,1] &nbsp;<br>True<br>ghci&gt; prop_idempotent [1..100]<br>True<br>ghci&gt; prop_idempotent [1,5,2,1,2,0,9]<br>True</span></p><p class="c1"><span class="c4">Parece estar certo. Entretanto, escrever os dados de entrada &agrave; m&atilde;o &eacute; tedioso e viola a o c&oacute;digo moral dos programadores funcionais eficientes: deixe a m&aacute;quina fazer o trabalho! Para automatizar isto, a biblioteca QuickCheck prov&ecirc; um conjunto de geradores de dados para todos os tipos b&aacute;sicos de dados Haskell. QuickCheck usa o tipo </span><span class="c2">Arbitrary</span><span class="c4"> para apresentar uma interface uniforme a um pseudo aleat&oacute;rio gerador de dados com o tipo do sistema usado para resolver a quest&atilde;o de qual gerador usar. QuickCheck normalmente esconde o funcionamento da gera&ccedil;&atilde;o de dados, entretanto, n&oacute;s podemos tamb&eacute;m executar os geradores &agrave; m&atilde;o para obter uma ideia dos dados que o QuickCheck produz. Por exemplo, gerar uma lista aleat&oacute;ria de valores booleanos:</span></p><p class="c11"><span class="c2">ghci&gt; generate 10 (System.Random.mkStdGen 2) arbitrary :: [Bool] [False,False,False,False,False,True]</span></p><p class="c1"><span class="c4">QuickCheck gera dados de teste desta maneira e os passa &agrave; propriedade de nossa escolha, por meio da fun&ccedil;&atilde;o </span><span class="c2">quickCheck</span><span class="c4">. O tipo da propriedade em si determina qual gerador de dados &eacute; usado. </span><span class="c2">quickCheck</span><span class="c4"> ent&atilde;o checa para todos os dados de teste produzido, que a propriedade foi satisfeita. Agora, uma vez que nosso teste de idempot&ecirc;ncia &eacute; polim&oacute;rfico na lista de tipos de elementos, precisamos escolher um tipo particular para o qual desejamos gerar os dados de teste, o qual iremos escrever como uma restri&ccedil;&atilde;o de tipo da propriedade. Para executar o teste, apenas chamamos </span><span class="c2">quickCheck </span><span class="c4">com a nossa fun&ccedil;&atilde;o de propriedade, que est&aacute; configurada para o tipo de dado requerido(caso contr&aacute;rio, o tipo de elemento da lista ir&aacute; ser o padr&atilde;o desinteressante tipo </span><span class="c2">()</span><span class="c4">)</span></p><p class="c3"><span class="c2">ghci&gt; :type quickCheck </span></p><p class="c3"><span class="c2">quickCheck :: (Testable a) =&gt; a -&gt; IO ()</span></p><p class="c3"><span class="c2">ghci&gt; quickCheck (prop_idempotent :: [Integer] -&gt; Bool) </span></p><p class="c11"><span class="c2">passed 100 tests.</span></p><p class="c14"><span class="c4">Para as diferentes 100 listas geradas, a nossa propriedade foi um sucesso. Quando escrever testes, geralmente &eacute; &uacute;til olhar os reais dados gerados para cada teste. Para fazer isso, iremos substituir </span><span class="c2">quickCheck</span><span class="c4"> pelo seu irm&atilde;o, </span><span class="c2">verboseCheck</span><span class="c4">, para ver a sa&iacute;da de cada teste. Agora, vamos olhar para propriedades sofisticadas que a nossa fun&ccedil;&atilde;o deve satisfazer.</span></p><p class="c0"><span class="c10">Testes de propriedades</span></p><p class="c1"><span class="c4">Boas bibliotecas consistem de um conjunto de primitivas ortogonais que possuem rela&ccedil;&otilde;es sens&iacute;veis entre si. Podemos usar QuickCheck para especificar as rela&ccedil;&otilde;es entre fun&ccedil;&otilde;es no nosso c&oacute;digo, o que nos ajuda a encontrar uma boa interface para a biblioteca por meio do desenvolvimento de fun&ccedil;&otilde;es que s&atilde;o interrelacionadas atrav&eacute;s de propriedades &uacute;teis. QuickCheck atua desta maneira como uma ferramenta &ldquo;</span><span class="c4 c5">lint</span><span class="c4">&rdquo; de API &ndash; ela prov&ecirc; suporte da m&aacute;quina para assegurar que a nossa API da biblioteca tem sentido.</span></p><p class="c0"><span class="c4"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o de lista deve certamente conter um n&uacute;mero de propriedades interessantes que se relacionam com outras opera&ccedil;&otilde;es de lista. Por exemplo, o primeiro elemento em uma lista ordenada deve sempre ser o menor elemento da lista de entrada. Ficamos tentados a especificar essa intui&ccedil;&atilde;o em Haskell, usando a fun&ccedil;&atilde;o </span><span class="c2">minimum</span><span class="c4"> da biblioteca </span><span class="c2">List:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs </span></p><p class="c11"><span class="c2">prop_minimum xs = head (qsort xs) == minimum xs</span></p><p class="c1"><span class="c4">Testando isso, no entanto, revela um erro:</span></p><p class="c11"><span class="c2">ghci&gt; quickCheck (prop_minimum :: [Integer] -&gt; Bool)<br>** Exception: Prelude.head: empty list</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A propriedade falhou quando ordenou uma lista vazia, para a qual </span><span class="c2">head</span><span class="c4"> e </span><span class="c2">minimum</span><span class="c4"> n&atilde;o est&atilde;o definidas, como podemos ver pela sua defini&ccedil;&atilde;o:</span></p><p class="c3"><span class="c2">-- file: ch11/minimum.hs </span></p><p class="c3"><span class="c2">head :: [a] -&gt; a </span></p><p class="c3"><span class="c2">head (x:_) = x </span></p><p class="c3"><span class="c2">head [] = error &quot;Prelude.head: empty list&quot; </span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2">minimum :: (Ord a) =&gt; [a] -&gt; a </span></p><p class="c3"><span class="c2">minimum [] = error &quot;Prelude.minimum: empty list&quot; </span></p><p class="c11"><span class="c2">minimum xs = foldl1 min xs</span></p><p class="c1"><span class="c4">Portanto esta propriedade ir&aacute; funcionar apenas para listas n&atilde;o-vazias. QuickCheck, felizmente, vem com uma extensa linguagem embarcada para escrever propriedades, para que possamos especificar mais precisamente nossas invariantes, removendo valores que n&atilde;o queremos considerar. Para o caso da lista vazia, n&oacute;s realmente queremos dizer que se a lista n&atilde;o est&aacute; vazia, ent&atilde;o o primeiro elemento da lista ordenada &eacute; o menor da lista de entrada. Isto &eacute; feito utilizando a fun&ccedil;&atilde;o de implica&ccedil;&atilde;o(</span><span class="c2">==&gt;</span><span class="c4">), que remove dados inv&aacute;lidos antes de executar as propriedades:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs<br>prop_minimum&#39; xs = not (null xs) ==&gt; head (qsort xs) == minimum xs</span></p><p class="c1"><span class="c4">O resultado &eacute; claro. Removendo o caso da lista vazia, podemos confirmar que a propriedade de fato funciona:</span></p><p class="c3 c6"><span class="c2">ghci&gt; quickCheck (prop_minimum&#39; :: [Integer] -&gt; Property)</span></p><p class="c3 c6"><span class="c2">passed 100 tests.</span></p><p class="c1"><span class="c4">Note que tivemos que mudar o tipo da propriedade, anteriormente sendo um simples resultado </span><span class="c2">Bool </span><span class="c4">para agora ser um resultado mais geral do tipo </span><span class="c2">Property</span><span class="c4">(a propriedade em si agora &eacute; uma fun&ccedil;&atilde;o que remove listas vazias, antes de test&aacute;-las, ao inv&eacute;s de uma simples constante booleana).</span></p><p class="c1"><span class="c4">Podemos agora completar o conjunto b&aacute;sico de propriedades para a fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o com outras invariantes que ela deve satisfazer: a sa&iacute;da deve ser ordenada(cada elemento deve ser menor, ou igual, ao seu sucessor); a sa&iacute;da deve ser uma permuta&ccedil;&atilde;o da entrada(a qual n&oacute;s alcan&ccedil;amos atrav&eacute;s da fun&ccedil;&atilde;o diferen&ccedil;a de lista, (</span><span class="c2">\\</span><span class="c4">)); o &uacute;ltimo elemento ordenado deve ser o maior elemento; e se encontramos o menor elemento de duas listas, ele deve ser o primeiro elemento se juntarmos e ordenarmos tais listas. Estas propriedades podem ser definidas como:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs<br>prop_ordered xs = ordered (qsort xs)<br> &nbsp; &nbsp;where ordered [] &nbsp; &nbsp; &nbsp; = True<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ordered [x] &nbsp; &nbsp; &nbsp;= True<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ordered (x:y:xs) = x &lt;= y &amp;&amp; ordered (y:xs)<br><br>prop_permutation xs = permutation xs (qsort xs)<br> &nbsp; &nbsp;where permutation xs ys = null (xs \\ ys) &amp;&amp; null (ys \\ xs)<br><br>prop_maximum xs &nbsp; &nbsp; &nbsp; &nbsp; =<br> &nbsp; &nbsp;not (null xs) ==&gt;<br> &nbsp; &nbsp; &nbsp; &nbsp;last (qsort xs) == maximum xs<br><br>prop_append xs ys &nbsp; &nbsp; &nbsp; =<br> &nbsp; &nbsp;not (null xs) ==&gt;<br> &nbsp; &nbsp;not (null ys) ==&gt;<br> &nbsp; &nbsp; &nbsp; &nbsp;head (qsort (xs ++ ys)) == min (minimum xs) (minimum ys)</span></p><p class="c3"><span class="c10">Testando sobre um modelo</span></p><p class="c1"><span class="c4">Outra t&eacute;cnica para adquirir confian&ccedil;a no c&oacute;digo &eacute; testar sobre uma implementa&ccedil;&atilde;o modelo. Podemos relacionar a nossa implementa&ccedil;&atilde;o de ordena&ccedil;&atilde;o de lista com a fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o presente na biblioteca padr&atilde;o, se elas possuem o mesmo comportamento, n&oacute;s ganhamos confian&ccedil;a que nossa fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o faz o que &eacute; certo:</span></p><p class="c3"><span class="c2">-- file: ch11/QC-basics.hs </span></p><p class="c3"><span class="c2">prop_sort_model xs = sort xs == qsort xs</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c11"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Este tipo de teste baseado em modelo &eacute; extremamente poderoso. Geralmente, desenvolvedores ir&atilde;o ter uma implementa&ccedil;&atilde;o de refer&ecirc;ncia ou prot&oacute;tipo que, embora ineficiente, &eacute; correta. Isso pode ent&atilde;o ser mantido por perto e usado para assegurar que o c&oacute;digo de produ&ccedil;&atilde;o otimizado est&aacute; de acordo com a refer&ecirc;ncia. Ao construir uma grande su&iacute;te desses testes baseados em modelos e executando-os regularmente(em cada </span><span class="c2">commit, </span><span class="c4">por exemplo), podemos facilmente assegurar a precis&atilde;o de nosso c&oacute;digo. Grandes projetos Haskell geralmente possuem su&iacute;tes de propriedades de tamanho compar&aacute;vel com o pr&oacute;prio projeto, com milhares de invariantes testadas em cada mudan&ccedil;a, mantendo o c&oacute;digo de acordo com a especifica&ccedil;&atilde;o e assegurando que ele se comporta como requerido.</span></p><p class="c0"><span class="c4"> </span><span class="c9">Testando o caso de uso: especificando uma Pretty Printer</span></p><p class="c1"><span class="c4">Testar as propriedades naturais de &nbsp;fun&ccedil;&otilde;es individuais &eacute; um das mais b&aacute;sicas abordagens que guiam o desenvolvimento de grandes sistemas em Haskell. Veremos agora um cen&aacute;rio mais complicado: construir uma su&iacute;te de testes para a biblioteca de pretty-printing* desenvolvida em cap&iacute;tulos anteriores.</span></p><p class="c1"><span class="c4">*N.dT.: Pretty-printing &eacute; o nome que se d&aacute; &agrave; apresenta&ccedil;&atilde;o de um conte&uacute;do de maneira em que a estrutura da apresenta&ccedil;&atilde;o intensifica o sentido do pr&oacute;prio conte&uacute;do</span></p><p class="c0"><span class="c10">Gerando Dados de Teste</span></p><p class="c1"><span class="c4">Lembre-se que a pretty printer &eacute; constru&iacute;da de acordo com o </span><span class="c2">Doc</span><span class="c4">, um tipo de dado alg&eacute;brico que representa documentos bem-estruturados.</span></p><p class="c3"><span class="c2">-- file: ch11/Prettify2.hs</span></p><p class="c3"><span class="c2">data Doc = Empty</span></p><p class="c3"><span class="c2">| Char Char</span></p><p class="c3"><span class="c2">| Text String</span></p><p class="c3"><span class="c2">| Line</span></p><p class="c3"><span class="c2">| Concat Doc Doc</span></p><p class="c3"><span class="c2">| Union Doc Doc</span></p><p class="c3"><span class="c2">deriving (Show,Eq)</span></p><p class="c1"><span class="c4">A biblioteca em si &eacute; implementada como um conjunto de fun&ccedil;&otilde;es que criam e transformam valores deste tipo de documento, antes de finalmente criar a sua representa&ccedil;&atilde;o completa em uma string.</span></p><p class="c1"><span class="c4">QuickCheck encoraja uma abordagem para testes onde o desenvolvedor especifica invariantes que deveriam ser verdadeiras para quaisquer dados que sejam consumidos pelo c&oacute;digo. Para testar a biblioteca de pretty-printing, ent&atilde;o, precisaremos de uma fonte de dados de entrada. Para isso, usufru&iacute;mos da pequena su&iacute;te de combina&ccedil;&atilde;o para constru&ccedil;&atilde;o de dados rand&ocirc;micos que o QuickCheck prov&ecirc;, via a classe </span><span class="c2">Arbitrary</span><span class="c4">. Essa classe fornece uma fun&ccedil;&atilde;o, </span><span class="c2">arbitrary</span><span class="c4">, que gera dados de diferentes tipos. Com ela, podemos definir nosso gerador de dados para nossos pr&oacute;prios tipos de dados:</span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary.hs</span></p><p class="c3"><span class="c2">class Arbitrary a where</span></p><p class="c3"><span class="c2">arbitrary :: Gen a</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Algo a ser notado &eacute; geradores s&atilde;o executados em um ambiente </span><span class="c2">Gen</span><span class="c4">, indicado pelo tipo. Isso &eacute; um simples monad passa-estados que &eacute; usar para esconder o estado do gerador de n&uacute;mero rand&ocirc;mico, que &eacute; espalhado pelo c&oacute;digo. Examinaremos monads minuciosamente em cap&iacute;tulos posteriores, por agora &eacute; suficientes dizer que, como </span><span class="c2">Gen</span><span class="c4"> &eacute; definido como um monad, n&oacute;s podemos usar a sintaxe </span><span class="c2">do</span><span class="c4"> para escrever novos geradores que acessam o c&oacute;digo de n&uacute;meros rand&ocirc;micos impl&iacute;cito. Na realidade, para escrever geradores para nosso pr&oacute;prio tipo, usamos qualquer conjunto de fun&ccedil;&otilde;es definidas na biblioteca para introduzir novos valores rand&ocirc;micos, para posteriormente junt&aacute;-los para construir estruturas de dados nas quais estejamos interessantes. Os tipos da fun&ccedil;&otilde;es chave s&atilde;o:</span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary.hs</span></p><p class="c3"><span class="c2">elements :: [a] -&gt; Gen a</span></p><p class="c3"><span class="c2">choose :: Random a =&gt; (a, a) -&gt; Gen a</span></p><p class="c3"><span class="c2">oneof :: [Gen a] -&gt; Gen a</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">A fun&ccedil;&atilde;o </span><span class="c2">elements</span><span class="c4">, por exemplo, recebe uma lista de valores e retorna um gerador de valores rand&ocirc;micos a partir daquela lista. (Usaremos </span><span class="c2">choose</span><span class="c4"> e </span><span class="c2">oneof</span><span class="c4"> depois). Com isso, podemos come&ccedil;ar a escrever geradores para tipos de dados simples. Por exemplo, se definirmos um novo tipo de dado para a l&oacute;gica tern&aacute;ria:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary.hs</span></p><p class="c3"><span class="c2">data Ternary</span></p><p class="c3"><span class="c2">= Yes</span></p><p class="c3"><span class="c2">| No</span></p><p class="c3"><span class="c2">| Unknown</span></p><p class="c3"><span class="c2">deriving (Eq,Show)</span></p><p class="c3"><span class="c2"> </span></p><p class="c0"><span class="c4">Podemos escrever uma inst&acirc;ncia de </span><span class="c2">Arbitrary</span><span class="c4"> para o tipo </span><span class="c2">Ternary</span><span class="c4"> ao definir uma fun&ccedil;&atilde;o que escolhe um elemento da lista dos poss&iacute;veis valores do tipo </span><span class="c2">Ternary</span><span class="c4">:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary.hs</span></p><p class="c3"><span class="c2">instance Arbitrary Ternary where</span></p><p class="c3"><span class="c2">arbitrary = elements [Yes, No, Unknown]</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Outra abordagem para a gera&ccedil;&atilde;o de dados &eacute; gerar valores para um dos tipos b&aacute;sicos de Haskell e traduzir tais valores em tipos nos quais estejamos interessados. Poder&iacute;amos ter escrito a inst&acirc;ncia de </span><span class="c2">Ternary</span><span class="c4"> gerando valores inteiros de 0 a 2 por exemplo, usando choose, e ent&atilde;o mapeando os valores em valores tern&aacute;rios:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary2.hs</span></p><p class="c3"><span class="c2">instance Arbitrary Ternary where</span></p><p class="c3"><span class="c2">arbitrary = do</span></p><p class="c3"><span class="c2">n &lt;- choose (0, 2) :: Gen Int</span></p><p class="c3"><span class="c2">return $ case n of</span></p><p class="c3"><span class="c2">0 -&gt; Yes</span></p><p class="c3"><span class="c2">1 -&gt; No</span></p><p class="c3"><span class="c2">_ -&gt; Unknown</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Para simples tipos de </span><span class="c5 c15">sum</span><span class="c4">, essa abordagem funciona bem, j&aacute; que os inteiros s&atilde;o facilmente mape&aacute;veis para os construtores do tipo de dado. Para tipos </span><span class="c4 c5">product</span><span class="c4"> (como as estruturas e as tuplas), precisamos de, no lugar, gerar cara componente do produto separadamente (e recursivamente para tipos aninhados), e ent&atilde;o combinar os componentes. Por exemplo, para gerar pares de valores rand&ocirc;micos:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Arbitrary.hs</span></p><p class="c3"><span class="c2">instance (Arbitrary a, Arbitrary b) =&gt; Arbitrary (a, b) where</span></p><p class="c3"><span class="c2">arbitrary = do</span></p><p class="c3"><span class="c2">x &lt;- arbitrary</span></p><p class="c3"><span class="c2">y &lt;- arbitrary</span></p><p class="c3"><span class="c2">return (x, y)</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Vamos escrever um gerador para todas as diferentes variantes do tipo Doc. Come&ccedil;aremos quebrando o problema em problemas menores, inicialmente gerando construtores rand&ocirc;micos para cada tipo, e ent&atilde;o, dependendo do resultado, os componentes de cada campo. Os casos mais complicados s&atilde;o as variantes de concatena&ccedil;&atilde;o e uni&atilde;o</span></p><p class="c0"><span class="c4"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Primeiro, no entanto, devemos escrever uma inst&acirc;ncia para gerar caracteres rand&ocirc;micos &ndash; QuickCheck n&atilde;o tem uma inst&acirc;ncia padr&atilde;o para caracteres, devido &agrave; abund&acirc;ncia de diferentes codifica&ccedil;&otilde;es de texto que podemos querer usar para testes de caracteres. Escreveremos nossa pr&oacute;pria inst&acirc;ncia, e, como se n&atilde;o nos import&aacute;ssemos com o conte&uacute;do do texto do documento em si, um gerador simples de caracteres alfab&eacute;ticos e pontua&ccedil;&otilde;es ser&aacute; suficiente (geradores mais abrangentes s&atilde;o simples extens&otilde;es dessa abordagem b&aacute;sica):</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">instance Arbitrary Char where</span></p><p class="c3"><span class="c2">arbitrary = elements ([&#39;A&#39;..&#39;Z&#39;] ++ [&#39;a&#39; .. &#39;z&#39;] ++ &quot;~!@#$%^&amp;*()&quot;)</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Com isso, podemos agora escrever uma inst&acirc;ncia para documentos enumerando os construtores e preenchendo os campos. Escolhemos um inteiro rand&ocirc;mico para representar qual variante do documento ser&aacute; gerada, e ent&atilde;o realizar a escolha baseada no resultado. Para gerar n&oacute;s de documentos de concatena&ccedil;&atilde;o ou uni&atilde;o, usamos recurs&atilde;o sobre </span><span class="c2">arbitrary</span><span class="c4">, deixando a infer&ecirc;ncia de tipos determinar qual inst&acirc;ncia de </span><span class="c2">Arbitrary</span><span class="c4"> desejamos:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">instance Arbitrary Doc where</span></p><p class="c3"><span class="c2">arbitrary = do</span></p><p class="c3"><span class="c2">n &lt;- choose (1,6) :: Gen Int</span></p><p class="c3"><span class="c2">case n of</span></p><p class="c3"><span class="c2">1 -&gt; return Empty</span></p><p class="c3"><span class="c2">2 -&gt; do x &lt;- arbitrary</span></p><p class="c3"><span class="c2">return (Char x)</span></p><p class="c3"><span class="c2">3 -&gt; do x &lt;- arbitrary</span></p><p class="c3"><span class="c2">return (Text x)</span></p><p class="c3"><span class="c2">4 -&gt; return Line</span></p><p class="c3"><span class="c2">5 -&gt; do x &lt;- arbitrary</span></p><p class="c3"><span class="c2">y &lt;- arbitrary</span></p><p class="c3"><span class="c2">return (Concat x y)</span></p><p class="c3"><span class="c2">6 -&gt; do x &lt;- arbitrary</span></p><p class="c3"><span class="c2">y &lt;- arbitrary</span></p><p class="c3"><span class="c2">return (Union x y)</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Essa foi uma abordagem bem direta, e podemos melhor&aacute;-la um pouco mais usando a fun&ccedil;&atilde;o oneof, cujo tipo vimos anteriormente, para escolher entre diferentes geradores em uma lista (podemos usar tamb&eacute;m o combinador mon&aacute;dico, liftM, para evitar nomear resultados intermedi&aacute;rios de cada gerador):</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">instance Arbitrary Doc where</span></p><p class="c3"><span class="c2">arbitrary =</span></p><p class="c3"><span class="c2">oneof [ return Empty</span></p><p class="c3"><span class="c2"> , liftM Char arbitrary</span></p><p class="c3"><span class="c2"> , liftM Text arbitrary</span></p><p class="c3"><span class="c2"> , return Line</span></p><p class="c3"><span class="c2"> , liftM2 Concat arbitrary arbitrary</span></p><p class="c3"><span class="c2"> , liftM2 Union arbitrary arbitrary ]</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Esta &uacute;ltima vers&atilde;o &eacute; mais concisa &ndash; escolhendo apenas de uma lista de geradores &ndash; embora ambas as vers&otilde;es descrevam os mesmo dados. Podemos checar que a sa&iacute;da faz sentido, ao gerar uma lista de documentos rand&ocirc;micos (escolhemos a semente inicial do gerador pseudo-rand&ocirc;mico como 2):</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">ghci&gt; generate 10 (System.Random.mkStdGen 2) arbitrary :: [Doc]</span></p><p class="c3"><span class="c2">[Line,Empty,Union Empty Line,Union (Char &#39;R&#39;) (Concat (Union Line (Concat (Text &quot;i@BmSu&quot;) (Char &#39;)&#39;))) (Union (Concat (Concat (Concat (Text &quot;kqV!iN&quot;) Line) Line) Line) Line)),Char &#39;M&#39;,Text &quot;YdwVLrQOQh&quot;]</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Examinando a sa&iacute;da, vemos uma boa mistura de casos b&aacute;sicos e alguns documentos aninhados mais complicados. Geraremos centenas desde a cada execu&ccedil;&atilde;o de teste para que o teste seja v&aacute;lido. Agora podemos escrever algumas propriedades gen&eacute;ricas para nossas fun&ccedil;&otilde;es</span></p><p class="c0"><span class="c4"> </span></p><p class="c0"><span class="c10">Testando a Constru&ccedil;&atilde;o de Documentos</span></p><p class="c1"><span class="c4">Duas das fun&ccedil;&otilde;es b&aacute;sicas sobre documentos s&atilde;o a constante de documento nulo (fun&ccedil;&atilde;o nul&aacute;ria), </span><span class="c2">empty</span><span class="c4">, e a fun&ccedil;&atilde;o anexar. Seus tipos s&atilde;o:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Prettify2.hs</span></p><p class="c3"><span class="c2">empty :: Doc</span></p><p class="c3"><span class="c2">(&lt;&gt;) :: Doc -&gt; Doc -&gt; Doc</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Juntas, essas fun&ccedil;&otilde;es deveriam compor uma propriedade razo&aacute;vel: anexar ou prepor uma lista vazia a uma segunda lista deveria deixar a segunda lista inalterada. Podemos afirmar essa invariante como uma propriedade:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">prop_empty_id x =</span></p><p class="c3"><span class="c2"> &nbsp;empty &lt;&gt; x == x</span></p><p class="c3"><span class="c2">&amp;&amp;</span></p><p class="c3"><span class="c2"> &nbsp;x &lt;&gt; empty == x</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Ao confirmar que essa propriedade &eacute; verdadeira, podemos continuar a cria&ccedil;&atilde;o de nossos testes:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">ghci&gt; quickCheck prop_empty_id</span></p><p class="c3"><span class="c2">passed 100 tests.</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Use isso para ver quais documentos foram realmente gerados (substituindo </span><span class="c2">quickCheck</span><span class="c4"> por </span><span class="c2">verboseCheck</span><span class="c4">). Se examinarmos o que foi gerado, veremos uma boa mistura de casos simples e complicados. Podemos refinar a gera&ccedil;&atilde;o de dados mais al&eacute;m, definindo restri&ccedil;&otilde;es sobre a propor&ccedil;&atilde;o de dados gerados, se desejado.</span></p><p class="c0"><span class="c4"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Outras fun&ccedil;&otilde;es na API s&atilde;o simples o suficiente para terem o seu comportamento completamente descrito por propriedades. Fazendo isso, podemos manter uma descri&ccedil;&atilde;o externa e verific&aacute;vel do comportamento da fun&ccedil;&atilde;o, de modo que modifica&ccedil;&otilde;es futuras n&atilde;o quebrar&atilde;o as invariantes b&aacute;sicas.</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">prop_char c &nbsp; = char c == Char c</span></p><p class="c3"><span class="c2">prop_text s &nbsp; = text s == if null s then Empty else Text s</span></p><p class="c3"><span class="c2">prop_line &nbsp; &nbsp; = line == Line</span></p><p class="c3"><span class="c2">prop_double d = double d == text (show d)</span></p><p class="c3"><span class="c8"> </span></p><p class="c1"><span class="c4">Essas propriedades s&atilde;o suficientes para testar completamente a estrutura retornada pelos operadores b&aacute;sicos de documentos. Testar o restante da biblioteca requer mais esfor&ccedil;o.</span></p><p class="c0"><span class="c4"> </span></p><p class="c0"><span class="c10">Usando Listas como Modelos</span></p><p class="c1"><span class="c4">Fun&ccedil;&otilde;es de alta ordem s&atilde;o a base de programas reus&aacute;veis, e a nossa biblioteca de pretty-printing n&atilde;o &eacute; exce&ccedil;&atilde;o &ndash; uma fun&ccedil;&atilde;o fold customizada &eacute; usada internamente para implementar tanto concatena&ccedil;&atilde;o quanto intercala&ccedil;&atilde;o de separadores entre peda&ccedil;os de documentos. O </span><span class="c2">fold</span><span class="c4"> definido para documentos recebe uma lista de peda&ccedil;os de documentos e os uni de acordo com uma fun&ccedil;&atilde;o de combina&ccedil;&atilde;o:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Prettify2.hs</span></p><p class="c3"><span class="c2">fold :: (Doc -&gt; Doc -&gt; Doc) -&gt; [Doc] -&gt; Doc</span></p><p class="c3"><span class="c2">fold f = foldr f empty</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Podemos escrever testes em isolamento para inst&acirc;ncias espec&iacute;ficas de fold facilmente. A concatena&ccedil;&atilde;o horizontal de documentos, por exemplo, &eacute; f&aacute;cil de ser especificada escrevendo-se uma implementa&ccedil;&atilde;o de refer&ecirc;ncia sobre listas:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">prop_hcat xs = hcat xs == glue xs</span></p><p class="c3"><span class="c2">where</span></p><p class="c3"><span class="c2">glue [] = empty</span></p><p class="c3"><span class="c2">glue (d:ds) = d &lt;&gt; glue ds</span></p><p class="c3"><span class="c8"> </span></p><p class="c1"><span class="c4">Acontece uma hist&oacute;ria similar com </span><span class="c2">punctuate</span><span class="c4">, onde podemos modelar a inser&ccedil;&atilde;o de pontua&ccedil;&atilde;o com intercala&ccedil;&atilde;o de listas (</span><span class="c2">intersperse</span><span class="c4">, de </span><span class="c2">Data.List</span><span class="c4">,&eacute; uma fun&ccedil;&atilde;o que recebe um elemento e o intercala entre outros elementos da lista):</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">prop_punctuate s xs = punctuate s xs == intersperse s xs</span></p><p class="c3"><span class="c2"> </span></p><p class="c1"><span class="c4">Embora pare&ccedil;a correta, a execu&ccedil;&atilde;o revela uma falha na nossa l&oacute;gica:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">ghci&gt; quickCheck prop_punctuate</span></p><p class="c3"><span class="c2">Falsifiable, after 6 tests:</span></p><p class="c3"><span class="c2">Empty</span></p><p class="c3"><span class="c2">[Line,Text &quot;&quot;,Line]</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">A biblioteca de pretty-printing aperfei&ccedil;oa documentos vazios redundantes, algo que o modelo de implementa&ccedil;&atilde;o n&atilde;o faz, logo precisaremos aumentar o nosso modelo para satisfazer a realidade. Primeiro, intercalamos a pontua&ccedil;&atilde;o pela lista de documentos, e ent&atilde;o eliminamos os documentos Empty espalhados pela lista, desta maneira:</span></p><p class="c0"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs</span></p><p class="c3"><span class="c2">prop_punctuate&#39; s xs = punctuate s xs == combine (intersperse s xs)</span></p><p class="c3"><span class="c2">where</span></p><p class="c3"><span class="c2">combine [] = []</span></p><p class="c3"><span class="c2">combine [x] = [x]</span></p><p class="c3"><span class="c2">combine (x:Empty:ys) = x : combine ys</span></p><p class="c3"><span class="c2">combine (Empty:y:ys) = y : combine ys</span></p><p class="c3"><span class="c2">combine (x:y:ys) = x `Concat` y : combine ys</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c4">Executando isso no GHCi, podemos confirmar o resultado. &Eacute; reconfortante que o framework de testes consiga localizar falhas em nossa l&oacute;gica expressa no c&oacute;digo &ndash; exatamente o que estamos procurando:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">ghci&gt; quickCheck prop_punctuate&#39;</span></p><p class="c3"><span class="c2">passed 100 tests.</span></p><p class="c3"><span class="c4"> </span></p><p class="c0"><span class="c10">Juntando Todas as Pe&ccedil;as</span></p><p class="c0"><span class="c4"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Podemos colocar todos estes testes juntos em um &uacute;nico arquivo e execut&aacute;-los simplesmente usando uma das fun&ccedil;&otilde;es de processamento de QuickCheck. Existem v&aacute;rias, inclusive ligadas a paralelismo. Entretanto, o processamento serial normalmente &eacute; bom o suficiente. Tudo o que precisamos &eacute; criar alguns par&acirc;metros de teste, e ent&atilde;o listas as fun&ccedil;&otilde;es que queremos testar:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">-- file: ch11/Run.hs</span></p><p class="c3"><span class="c2">import Prettify2</span></p><p class="c3"><span class="c2">import Test.QuickCheck.Batch</span></p><p class="c3"><span class="c2"> </span></p><p class="c3"><span class="c2">options = TestOptions</span></p><p class="c3"><span class="c2">{ no_of_tests = 200</span></p><p class="c3"><span class="c2">, length_of_tests = 1</span></p><p class="c3"><span class="c2">, debug_tests = False }</span></p><p class="c3"><span class="c2"> </span></p><p class="c3"><span class="c2">main = do</span></p><p class="c3"><span class="c2">runTests &quot;simple&quot; options</span></p><p class="c3"><span class="c2">[ run prop_empty_id</span></p><p class="c3"><span class="c2">, run prop_char</span></p><p class="c3"><span class="c2">, run prop_text</span></p><p class="c3"><span class="c2">, run prop_line</span></p><p class="c3"><span class="c2">, run prop_double</span></p><p class="c3"><span class="c2">]</span></p><p class="c3"><span class="c2">runTests &quot;complex&quot; options</span></p><p class="c3"><span class="c2">[ run prop_hcat</span></p><p class="c3"><span class="c2">, run prop_puncutate&#39;</span></p><p class="c3"><span class="c2">]</span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Aqui, estruturamos o c&oacute;digo como um script separado e aut&ocirc;nomo, com instancias e propriedades em seus pr&oacute;prios arquivos, separados do c&oacute;digo da biblioteca. Isso &eacute; t&iacute;pico para projetos de biblioteca, em que testes s&atilde;o mantidos separados da biblioteca em si, e eles importam a biblioteca de acordo com o sistema de m&oacute;dulos. O script de teste pode ent&atilde;o ser compilado e executado:</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c2">$ </span><span class="c2 c18">ghc --make Run.hs</span></p><p class="c3"><span class="c2">$ </span><span class="c2 c18">./Run</span></p><p class="c3"><span class="c2"> simple : ..... &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1000)</span></p><p class="c3"><span class="c2">complex : .. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(400)</span></p><p class="c3"><span class="c4"> </span></p><p class="c3"><span class="c4"> </span></p><p class="c1"><span class="c4">Um total de 1400 testes individuais foram criados, o que &eacute; reconfortante. Podemos aumentar a profundidade facilmente, mas para saber exatamente qu&atilde;o bem o c&oacute;digo est&aacute; sendo testado, devemos usar a ferramenta embutida de cobertura de c&oacute;digo, HPC, que pode afirmar com precis&atilde;o o que est&aacute; acontecendo.</span></p><p class="c0"><span class="c9">Medir a cobertura de teste com HPC</span></p><p class="c1"><span class="c4">O HPC (Haskell Program Coverage) &eacute; uma extens&atilde;o para que o compilador observe quais partes do c&oacute;digo foram realmente executadas durante a execu&ccedil;&atilde;o do programa dado. Isso &eacute; &uacute;til no contexto de teste, pois nos permite observar com precis&atilde;o quais as fun&ccedil;&otilde;es, ramos e express&otilde;es foram avaliadas. O resultado &eacute; um conhecimento preciso sobre o percentual de c&oacute;digo testado que &eacute; facilmente obtido. O HPC vem com um utilit&aacute;rio simples para gerar gr&aacute;ficos &uacute;teis de cobertura do programa, tornando mais f&aacute;cil para verificar os pontos fracos no conjunto de testes.</span></p><p class="c1"><span class="c4">Para a obten&ccedil;&atilde;o de dados de cobertura de testes, tudo o que precisamos fazer &eacute; adicionar a </span><span class="c4 c5">flag </span><span class="c2">-fhpc</span><span class="c4"> na linha de comando, ao compilar os testes :</span></p><p class="c0"><span class="c2">$ ghc -fhpc Run.hs &ndash;make</span></p><p class="c1"><span class="c4">Em seguida, executar os testes normalmente:</span></p><p class="c3 c6"><span class="c2">$ ./Run</span></p><p class="c3 c6"><span class="c2">simple : ..... (1000)</span></p><p class="c0"><span class="c2">complex : .. (400)</span></p><p class="c1"><span class="c4">Durante a execu&ccedil;&atilde;o do teste, o tra&ccedil;o do programa &eacute; escrito em arquivos </span><span class="c2">.tix</span><span class="c4"> e </span><span class="c2">.mix</span><span class="c4"> no diret&oacute;rio em quest&atilde;o. Depois disso, estes arquivos s&atilde;o usados pela ferramenta de linha de comando, </span><span class="c2">hpc</span><span class="c4">, para mostras as v&aacute;rias estat&iacute;sticas sobre o que aconteceu. A interface b&aacute;sica &eacute; textual. Para come&ccedil;ar, podemos ter um resumo do c&oacute;digo testado durante a execu&ccedil;&atilde;o usando a </span><span class="c4 c5">flag</span><span class="c4"> </span><span class="c2">report</span><span class="c4"> para </span><span class="c2">hpc</span><span class="c4">. Excluiremos os programas de teste(usando a </span><span class="c4 c5">flag</span><span class="c4"> </span><span class="c2">--exclude</span><span class="c4">), para nos concentrarmos somente no c&oacute;digo da biblioteca pretty-printer. Entrando com o seguinte c&oacute;digo no console:</span></p><p class="c3 c6"><span class="c2">$ hpc report Run --exclude=Main --exclude=QC </span></p><p class="c3 c6"><span class="c2">18% expressions used (30/158)</span></p><p class="c3 c6"><span class="c2">0% boolean coverage (0/3)</span></p><p class="c3 c13 c6"><span class="c2">0% guards (0/3), 3 unevaluated </span></p><p class="c3 c13 c6"><span class="c2">100% &#39;if&#39; conditions (0/0)</span></p><p class="c3 c13 c6"><span class="c2">100% qualifiers (0/0)</span></p><p class="c3 c6"><span class="c2">23% alternatives used (8/34)</span></p><p class="c3 c6"><span class="c2">0% local declarations used (0/4)</span></p><p class="c0"><span class="c2">42% top-level declarations used (9/21)</span></p><p class="c1"><span class="c4">N&oacute;s vemos que, na &uacute;ltima linha, 42% das defini&ccedil;&otilde;es de alto-n&iacute;vel foram executadas durante a execu&ccedil;&atilde;o do teste. Nada mal para a primeira tentativa. Conforme testamos mais e mais fun&ccedil;&otilde;es da biblioteca, estes n&uacute;meros ir&atilde;o aumentar. A vers&atilde;o textual &eacute; &uacute;til para uma resumo r&aacute;pido, mas para ver realmente o que est&aacute; acontecendo, &eacute; melhor olhar para a sa&iacute;da marcada. Para gerar isto, iremos usar a </span><span class="c4 c5">flag</span><span class="c4"> </span><span class="c2">markup</span><span class="c4">:</span></p><p class="c0"><span class="c2">$ hpc markup Run --exclude=Main --exclude=QC</span></p><p class="c1"><span class="c4">Isto ir&aacute; gerar um arquivo HTML para cada arquivo de c&oacute;digo Haskell, e alguns arquivos de &iacute;ndices. Carregando o arquivo </span><span class="c2">hpc_index.html </span><span class="c4">em um navegador, podemos ver alguns belos gr&aacute;ficos de cobertura de c&oacute;digo. Veja a figura 11-1.</span></p><p class="c1"><img height="78.0" src="images/image2.png" width="596.0"></p><p class="c1"><span class="c4">Nada mal. Clicando no m&oacute;dulo, vemos que o c&oacute;digo real do programa, com marca&ccedil;&otilde;es em negrito e amarelo para c&oacute;digo que n&atilde;o foi testado e apenas em negrito para c&oacute;digo que foi executado.</span></p><p class="c1"><span class="c4">&nbsp;</span></p><p class="c1"><span class="c4">&nbsp;</span></p><p class="c1"><span class="c4">&nbsp;</span></p><p class="c1"><span class="c4">&nbsp;</span></p><p class="c1"><img height="413.0" src="images/image1.png" width="455.0"></p><p class="c1"><span class="c4">Esquecemos de testar a inst&acirc;ncia </span><span class="c2">Monoid</span><span class="c4">, por exemplo, e algumas fun&ccedil;&otilde;es mais complicadas. HPC nos ajuda a manter a su&iacute;te de testes honesta. Vamos adicionar um teste para inst&acirc;ncia de </span><span class="c2">Monoid</span><span class="c4">, a classe de tipos que suportam concatena&ccedil;&atilde;o e elementos vazios:</span></p><p class="c3"><span class="c2">-- file: ch11/QC.hs<br>prop_mempty_id x =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mempty `mappend` x == x<br> &nbsp;&amp;&amp;</span></p><p class="c12"><span class="c2">x `mappend` mempty == (x :: Doc)</span></p><p class="c1"><span class="c4">Executamos esta propriedade no </span><span class="c2">ghci</span><span class="c4">, para checar que est&aacute; correta:</span></p><p class="c11"><span class="c2">ghci&gt; quickCheck prop_mempty_id<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00, passed 100 tests.</span></p><p class="c0"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Podemos agora recompilar e executar os testes. &Eacute; importante remover o antigo </span><span class="c2">.tix</span><span class="c4"> arquivo primeiro, ou um erro ir&aacute; ocorrer j&aacute; que o HPC tenta combinar as estat&iacute;sticas de execu&ccedil;&otilde;es separadas:</span></p><p class="c3 c6"><span class="c2">$ ghc -fhpc Run.hs --make -no-recomp </span></p><p class="c3 c6"><span class="c2">$ ./Run </span></p><p class="c3 c6"><span class="c2">Hpc failure: inconsistent number of tick boxes </span></p><p class="c3 c6"><span class="c2">(perhaps remove Run.tix file?) </span></p><p class="c3 c6"><span class="c2">$ rm *.tix </span></p><p class="c3 c6"><span class="c2">$ ./Run </span></p><p class="c14 c6"><span class="c2">simple : ..... (1000) </span></p><p class="c0 c13"><span class="c2">complex : ... (600)</span></p><p class="c6 c14"><span class="c4">Outros 200 testes foram adicionados &agrave; su&iacute;te, e nossas estat&iacute;sticas de cobertura subiu para 52% do c&oacute;digo base. (veja Figura 11-3).</span></p><p class="c14 c6"><img height="70.0" src="images/image0.png" width="590.0"></p><p class="c14 c6"><span class="c4">HPC garante que n&oacute;s sejamos honestos em nossos testes, assim qualquer c&oacute;digo com menos de 100% de cobertura ir&aacute; ser assinalado com uma cor diferenciada. Em particular, isso garante que o programador ter&aacute; de pensar sobre casos de erro, ramifica&ccedil;&otilde;es complicadas com condi&ccedil;&otilde;es obscuras, e qualquer forma de </span><span class="c4 c5">code smell</span><span class="c4">. Quando combinado com um sistema de gera&ccedil;&atilde;o de testes exaustivos, como o QuickCheck, testes se tornam uma atividade gratificante, e uma parte essencial do desenvolvimento Haskell.</span></p><p class="c1"><span class="c4">&nbsp;</span></p></body></html>