
<!-- saved from url=(0090)https://docs.google.com/document/pub?id=1uO2MU85rfD5waXHo0n2iVa0bai_NEQIVTwfmDL5xAMA&pli=1 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript">
(function(){var a="start";function b(e){this.t={};this.tick=function(f,g,c){this.t[f]=[c?c:(new Date).getTime(),g]};this.tick(a,null,e)}var d=new b;window.jstiming={Timer:b,load:d};try{var h=null;if(window.chrome&&window.chrome.csi)h=Math.floor(window.chrome.csi().pageT);if(h==null)if(window.gtbExternal)h=window.gtbExternal.pageT();if(h==null)if(window.external)h=window.external.pageT;if(h)window.jstiming.pt=h}catch(i){};})()
</script><script type="text/javascript">var KX_timer = new window.jstiming.Timer(); KX_timer.name = 'published';</script><title>Tradução do cpítulo 27 Sockets and syslog</title><style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      iframe {
        border: 0;
        frameborder: 0;
        height: 100%;
        width: 100%;
      }

      #header, #footer {
        background: #f0f0f0;
        padding: 10px 10px;
      }

      #header {
        border-bottom: 1px #ccc solid;
      }

      #footer {
        border-top: 1px #ccc solid;
        border-bottom: 1px #ccc solid;
        font-size: 13;
      }

      #contents {
        margin: 6px;
      }

      .dash {
        padding: 0 6px;
      }
    </style></head><body><div id="header">Tradução do cpítulo 27 Sockets and syslog</div><div id="contents"><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c0{color:#45818e;font-style:italic;font-size:11pt;font-family:Arial;font-weight:bold}.c11{color:#38761d;font-style:italic;font-size:11pt;font-family:Arial}.c4{color:#45818e;font-style:italic;font-size:11pt;font-family:Arial}.c13{padding-left:0pt;line-height:1.15;direction:ltr;margin-left:36.0pt}.c5{color:#000000;font-size:18pt;font-family:Arial;font-weight:bold}.c2{color:#0000ff;font-style:italic;font-size:11pt;font-family:Arial}.c6{color:#bf9000;font-style:italic;font-size:11pt;font-family:Arial}.c1{color:#000000;font-size:11pt;font-family:Arial}.c12{padding-top:24.0pt;text-align:center;padding-bottom:6.0pt}.c9{color:#bf9000;font-size:11pt;font-family:Arial}.c10{color:#000000;font-size:24pt;font-family:Arial}.c17{color:#45818e;font-size:11pt;font-family:Arial}.c3{line-height:1.15;text-indent:0pt;direction:ltr}.c8{padding-top:18.0pt;padding-bottom:4.0pt}.c15{list-style-type:disc}.c7{font-weight:bold}.c16{font-style:italic}.c18{background-color:#ffffff}.c14{text-align:center}</style><div><p class="c3 c14"><span class="c1">Cezar T. Kavassaka-13094</span></p><p class="c3 c14"><span class="c1">Marcel Mendonça Grilo-13106</span></p><p class="c3 c14"><span class="c1">Júnio Salomé - 13105</span></p></div><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c12"><a name="h.h8n9ct-1cizxw"></a><span class="c7 c10">Capítulo 27 Sockets e syslog</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.3phfl7-vmc6m8"></a><span class="c5">Básico de redes:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Nos capítulos anteriores deste livro discutimos sobre os serviços que operam em uma rede. Exemplos:</span></p><ol class="c15"><li class="c13" value="1"><span class="c1">Bancos de dados cliente / servidor </span></li><li class="c13"><span class="c1"> web services. </span></li></ol><p class="c3"><span class="c1">Quando surge a necessidade de elaborar um novo protocolo, ou se comunicar com um protocolo que não possui uma biblioteca auxiliar existente em Haskell, você vai precisar usar as ferramentas de rede de baixo nível na biblioteca Haskell. </span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Neste capítulo, vamos discutir ferramentas de baixo nível. comunicação em rede é um tema amplo, com livros inteiros dedicados a ele. Vamos mostrar também, como usar Haskell para aplicaçar conhecimento &nbsp;de baixo nível numa rede que já exsta.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">As funções de rede em Haskell, quase sempre tem correspondência direta com as chamadas de função na linguagem C. Como a maioria das outras linguagens também tem camada em cima de C, você deve encontrar essa interface familiar. </span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.4esajy-tl6kwh"></a><span class="c5">Comunicando-se com UDP</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">UDP divide os dados em pacotes. Não garante que os dados chegam ao seu destino, ou chegam apenas uma vez. Ele faz uso de checksum para garantir que os pacotes que chegam, não estejam corrompidos. UDP tende a ser usado em aplicações que têm menos desempenho ou sejam sensíveis à latência, em que cada pacote individual de dados é menos importante do que o desempenho global do sistema. Também pode ser utilizado quando o comportamento do TCP não é o mais eficiente, como os que enviam mensagens curtas e discretas. Exemplos de sistemas que tendem a usar UDP incluem conferências de áudio e vídeo, sincronização de tempo, sistemas de arquivos baseados em rede e sistemas de registro.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.lgbqpb-h2q6r2"></a><span class="c5">Exemplo UDP Client: syslog</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">O serviço syslog tradicional no Unix permite que programas enviem mensagens de log através de uma rede para um servidor central que irá grava-los. Alguns programas são muito sensíveis ao desempenho, e podem gerar um grande volume de mensagens. Nestes programas, pode ser mais importante ter o registro e impor uma sobrecarga de desempenho mínimo para garantir que cada mensagem é registrada. Além disso, pode ser desejável para continuar a operação do programa, mesmo se o servidor de registro é inacessível. Por esta razão, o UDP é um dos protocolos suportados pelo syslog para a transmissão de mensagens de log. O protocolo é simples e nós apresentamos uma implementação de Haskell de um cliente.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c2">-- file: ch27/syslogclient.hs</span></p><p class="c3"><span class="c2">import Data.Bits</span></p><p class="c3"><span class="c2">import Network.Socket</span></p><p class="c3"><span class="c2">import Network.BSD</span></p><p class="c3"><span class="c2">import Data.List</span></p><p class="c3"><span class="c2">import SyslogTypes</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2">data SyslogHandle =</span></p><p class="c3"><span class="c2"> &nbsp; SyslogHandle {slSocket :: Socket,</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slProgram :: String,</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slAddress :: SockAddr}</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2">openlog :: HostName &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- ^ Remote hostname, or localhost</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- ^ Port number or name; 514 is default</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- ^ Name to log under</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; IO SyslogHandle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- ^ Handle to use for logging</span></p><p class="c3"><span class="c2">openlog hostname port progname =</span></p><p class="c3"><span class="c2"> &nbsp; do -- Look up the hostname and port. &nbsp;Either raises an exception</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- or returns a nonempty list. &nbsp;First element in that list</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- is supposed to be the best option.</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addrinfos &lt;- getAddrInfo Nothing (Just hostname) (Just port)</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let serveraddr = head addrinfos</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Establish a socket for communication</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock &lt;- socket (addrFamily serveraddr) Datagram defaultProtocol</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Save off the socket, program name, and server address in a handle</span></p><p class="c3"><span class="c2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $ SyslogHandle sock progname (addrAddress serveraddr)</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2">syslog :: SyslogHandle -&gt; Facility -&gt; Priority -&gt; String -&gt; IO ()</span></p><p class="c3"><span class="c2">syslog syslogh fac pri msg =</span></p><p class="c3"><span class="c2"> &nbsp; sendstr sendmsg</span></p><p class="c3"><span class="c2"> &nbsp; where code = makeCode fac pri</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendmsg = "&lt;" ++ show code ++ "&gt;" ++ (slProgram syslogh) ++</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;": " ++ msg</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Send until everything is done</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendstr :: String -&gt; IO ()</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendstr [] = return ()</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendstr omsg = do sent &lt;- sendTo (slSocket syslogh) omsg</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(slAddress syslogh)</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendstr (genericDrop sent omsg)</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p class="c3"><span class="c2">closelog :: SyslogHandle -&gt; IO ()</span></p><p class="c3"><span class="c2">closelog syslogh = sClose (slSocket syslogh)</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c2">{- | Convert a facility and a priority into a syslog code -}</span></p><p class="c3"><span class="c2">makeCode :: Facility -&gt; Priority -&gt; Int</span></p><p class="c3"><span class="c2">makeCode fac pri =</span></p><p class="c3"><span class="c2"> &nbsp; let faccode = codeOfFac fac</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pricode = fromEnum pri</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in</span></p><p class="c3"><span class="c2"> &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(faccode `shiftL` 3) .|. pricode</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c1">Isto requer ainda um &nbsp;SyslogTypes.hs, como segue:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c2">-- file: ch27/SyslogTypes.hs<br>module SyslogTypes where<br>{- | Priorities define how important a log message is. -}<br><br>data Priority = <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DEBUG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Debug messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| INFO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Information<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| NOTICE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Normal runtime conditions<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| WARNING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ General Warnings<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ERROR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ General Errors<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| CRITICAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Severe situations<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALERT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Take immediate action<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| EMERGENCY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ System is unusable<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;deriving (Eq, Ord, Show, Read, Enum)<br><br>{- | Facilities are used by the system to determine where messages<br>are sent. -}<br><br>data Facility = <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KERN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Kernel messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| USER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ General userland messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| MAIL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ E-Mail system<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| DAEMON &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Daemon (server process) messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| AUTH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Authentication or security messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| SYSLOG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Internal syslog messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LPR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Printer messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| NEWS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Usenet news<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| UUCP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ UUCP messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| CRON &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Cron messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| AUTHPRIV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Private authentication messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| FTP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ FTP messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL1<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL2<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL3<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL4<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL5<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL6<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| LOCAL7<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;deriving (Eq, Show, Read)<br><br>facToCode = [ <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (KERN, 0),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (USER, 1),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MAIL, 2),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DAEMON, 3),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AUTH, 4),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (SYSLOG, 5),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LPR, 6),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (NEWS, 7),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (UUCP, 8),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (CRON, 9),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AUTHPRIV, 10),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (FTP, 11),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL0, 16),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL1, 17),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL2, 18),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL3, 19),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL4, 20),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL5, 21),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL6, 22),<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (LOCAL7, 23)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]<br><br>codeToFac = map (\(x, y) -&gt; (y, x)) facToCode<br><br><br>{- | We can't use enum here because the numbering is discontiguous -}<br>codeOfFac :: Facility -&gt; Int<br>codeOfFac f = case lookup f facToCode of<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Just x -&gt; x<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_ -&gt; error $ "Internal error in codeOfFac"<br><br>facOfCode :: Int -&gt; Facility<br>facOfCode f = case lookup f codeToFac of<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Just x -&gt; x<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_ -&gt; error $ "Invalid code in facOfCode"</span></p><p class="c3"><span class="c2">&nbsp;</span></p><p class="c3"><span class="c1">Com ghci, você pode enviar uma mensagem para um servidor syslog local. Você pode usar tanto o servidor syslog do exemplo apresentado neste capítulo, ou um servidor de syslog existentes, como você faria normalmente para encontrar no Linux ou outros sistemas POSIX. Note que a maioria destes desativam a porta UDP por padrão e pode ser necessário que se permita(ative) a porta UDP antes que seu fornecedor daemon do syslog exibia as mensagens recebidas.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Se você estiver enviando uma mensagem para um servidor syslog no sistema local, você pode usar um comando como segue:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c4">ghci&gt; </span><span class="c0">:load syslogclient.hs</span><span class="c4"><br>[1 of 2] Compiling SyslogTypes &nbsp; &nbsp; &nbsp;( SyslogTypes.hs, interpreted )<br>[2 of 2] Compiling Main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( syslogclient.hs, interpreted )<br>Ok, modules loaded: SyslogTypes, Main.<br>ghci&gt; </span><span class="c0">h &lt;- openlog "localhost" "514" "testprog"</span><span class="c4"><br>Loading package parsec-2.1.0.0 ... linking ... done.<br>Loading package network-2.1.0.0 ... linking ... done.<br>ghci&gt; </span><span class="c0">syslog h USER INFO "This is my message"</span><span class="c4"><br>ghci&gt; </span><span class="c0">closelog h</span></p><p class="c3"><span class="c7 c11">&nbsp;</span></p><p class="c3 c8"><a name="h.uck90c-5h5ykd"></a><span class="c5">Servidor UDP &nbsp;Syslog</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Servidores UDP &nbsp;se ligarão a uma porta específica na máquina servidora. Eles vão aceitar pacotes direcionados a essa porta e processá-los. Como UDP é um protocolo stateless e packet-oriented, os programadores utilizam normalmente uma chamada como recvfrom para receber tanto os dados quanto informações sobre a máquina que o enviou, e é usado para enviar de volta uma resposta.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c2">-- file: ch27/syslogserver.hs<br>import Data.Bits<br>import Network.Socket<br>import Network.BSD<br>import Data.List<br><br>type HandlerFunc = SockAddr -&gt; String -&gt; IO ()<br><br>serveLog :: String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Port number or name; 514 is default<br> &nbsp; &nbsp; &nbsp; &nbsp; -&gt; HandlerFunc &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Function to handle incoming messages<br> &nbsp; &nbsp; &nbsp; &nbsp; -&gt; IO ()<br>serveLog port handlerfunc = withSocketsDo $<br> &nbsp; &nbsp;do -- Look up the port. &nbsp;Either raises an exception or returns<br> &nbsp; &nbsp; &nbsp; -- a nonempty list. &nbsp;<br> &nbsp; &nbsp; &nbsp; addrinfos &lt;- getAddrInfo <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Just (defaultHints {addrFlags = [AI_PASSIVE]}))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Nothing (Just port)<br> &nbsp; &nbsp; &nbsp; let serveraddr = head addrinfos<br><br> &nbsp; &nbsp; &nbsp; -- Create a socket<br> &nbsp; &nbsp; &nbsp; sock &lt;- socket (addrFamily serveraddr) Datagram defaultProtocol<br><br> &nbsp; &nbsp; &nbsp; -- Bind it to the address we're listening to<br> &nbsp; &nbsp; &nbsp; bindSocket sock (addrAddress serveraddr)<br><br> &nbsp; &nbsp; &nbsp; -- Loop forever processing incoming data. &nbsp;Ctrl-C to abort.<br> &nbsp; &nbsp; &nbsp; procMessages sock<br> &nbsp; &nbsp;where procMessages sock =<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do -- Receive one UDP packet, maximum length 1024 bytes,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- and save its content into msg and its source<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- IP and port into addr<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (msg, _, addr) &lt;- recvFrom sock 1024<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- Handle it<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handlerfunc addr msg<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- And process more messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procMessages sock<br><br>-- A simple handler that prints incoming packets<br>plainHandler :: HandlerFunc<br>plainHandler addr msg = <br> &nbsp; &nbsp;putStrLn $ "From " ++ show addr ++ ": " ++ msg</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Você pode executar no ghci. Uma chamada para serveLog "1514" plainHandler vai configurar um servidor UDP na porta 1514 que irá utilizar plainHandler para imprimir todos os pacotes UDP de entrada nessa porta. Ctrl-C irá encerrar o programa.</span></p><p class="c3"><span class="c9"></span><span class="c6">Em caso de problemas</span></p><p class="c3"><span class="c6">Primeiros efeitos: permissão negada ao testar? Certifique-se de usar um número de porta maior que 1024. Alguns sistemas operacionais permitem que apenas o usuário root possa ligar em portas a menores de 1024.</span></p><p class="c3"><span class="c9">&nbsp;</span></p><p class="c3 c8"><a name="h.uykf77-vsewfe"></a><span class="c5">Comunicando-se com TCP</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">O protocolo TCP foi projetado para fazer a transferência de dados através da Internet o mais confiável possível. O tráfego TCP é um fluxo de dados. Embora essa corrente é quebrada em pacotes individuais pelo sistema operacional, os limites dos pacotes não eram conhecidos nem relevantes para as aplicações. O protocolo TCP garante que, se o tráfego é entregue à aplicação de qualquer forma, que chegara intacto, inalterado, exatamente uma vez, e em ordem. Obviamente, as coisas tal como um fio quebrado podem resultar que o tráfego de dados seja quebrado, e nenhum protocolo pode superar essas limitações.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Isso traz algumas desvantagens em comparação com UDP. Primeiro de tudo, existem alguns pacotes que devem ser enviados no início da conversa TCP para estabelecer o link. Para conversas muito curtas, então, o UDP teria uma vantagem de desempenho. Além disso, o TCP se esforça muito para obter os dados. Se um lado de uma conversa tenta enviar dados para um lado remoto, mas não recebe uma confirmação de volta, serão periodicamente retransmitidos os dados por algum tempo antes de o protocolo desistir. Isso faz com que o TCP seja robusto no que se trata da perda de pacotes. No entanto, isso também significa que o TCP não é a melhor escolha em tempo real, ou seja, protocolos que envolvam coisas como o áudio ao vivo ou vídeo.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.nrgdwf-nie0v5"></a><span class="c5">Manipulação de múltiplos fluxos TCP</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Com o TCP, as conexões são stateful. Isso significa que há um "canal" lógico dedicado entre um cliente e servidor, ao invés de apenas atirar pacotes como em UDP. Isso torna as coisas fáceis para os desenvolvedores do lado cliente. Os aplicativos de servidor quase sempre irão querer ser capazes de lidar com mais de uma conexão TCP ao mesmo tempo. Como então fazer isso?</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">No lado do servidor, você primeiro cria um socket e liga a uma porta, assim como UDP. Em vez de ouvir várias vezes os dados a partir de qualquer localização, o loop principal será em torno de aceitar(accept) o convite. Cada vez que um cliente se conecta, o servidor do sistema operacional aloca um novo socket para ele. Portanto, temos a tomada principal, usado apenas para escutar as conexões de entrada, e nunca para transmitir dados. Temos também o potencial de múltiplos soquetes filhos para serem usado ao mesmo tempo, cada um correspondendo a uma conversa TCP lógica. </span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Em Haskell, normalmente você vai usar forkIO para criar um segmento separado e leve para lidar com cada conversa com um filho. Haskell tem uma implementação interna &nbsp;eficiente é que executada muito bem.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.ovqo8o-i586wt"></a><span class="c5">Servidor TCP Syslog</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Digamos que queremos implementar syslog usando TCP em vez de UDP. Poderíamos dizer que uma única mensagem não é definida por estar em um único pacote, mas é encerrada por um caractere de nova linha '\ n'. Um determinado cliente pode enviar 0 ou mais mensagens para o servidor usando uma determinada conexão TCP. Veja como podemos escrever isso.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c2">-- file: ch27/syslogtcpserver.hs<br>import Data.Bits<br>import Network.Socket<br>import Network.BSD<br>import Data.List<br>import Control.Concurrent<br>import Control.Concurrent.MVar<br>import System.IO<br><br>type HandlerFunc = SockAddr -&gt; String -&gt; IO ()<br><br>serveLog :: String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- ^ Port number or name; 514 is default<br> &nbsp; &nbsp; &nbsp; &nbsp; -&gt; HandlerFunc &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Function to handle incoming messages<br> &nbsp; &nbsp; &nbsp; &nbsp; -&gt; IO ()<br>serveLog port handlerfunc = withSocketsDo $<br> &nbsp; &nbsp;do -- Look up the port. &nbsp;Either raises an exception or returns<br> &nbsp; &nbsp; &nbsp; -- a nonempty list. &nbsp;<br> &nbsp; &nbsp; &nbsp; addrinfos &lt;- getAddrInfo <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Just (defaultHints {addrFlags = [AI_PASSIVE]}))<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Nothing (Just port)<br> &nbsp; &nbsp; &nbsp; let serveraddr = head addrinfos<br><br> &nbsp; &nbsp; &nbsp; -- Create a socket<br> &nbsp; &nbsp; &nbsp; sock &lt;- socket (addrFamily serveraddr) Stream defaultProtocol<br><br> &nbsp; &nbsp; &nbsp; -- Bind it to the address we're listening to<br> &nbsp; &nbsp; &nbsp; bindSocket sock (addrAddress serveraddr)<br><br> &nbsp; &nbsp; &nbsp; -- Start listening for connection requests. &nbsp;Maximum queue size<br> &nbsp; &nbsp; &nbsp; -- of 5 connection requests waiting to be accepted.<br> &nbsp; &nbsp; &nbsp; listen sock 5<br><br> &nbsp; &nbsp; &nbsp; -- Create a lock to use for synchronizing access to the handler<br> &nbsp; &nbsp; &nbsp; lock &lt;- newMVar ()<br><br> &nbsp; &nbsp; &nbsp; -- Loop forever waiting for connections. &nbsp;Ctrl-C to abort.<br> &nbsp; &nbsp; &nbsp; procRequests lock sock<br><br> &nbsp; &nbsp;where<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- | Process incoming connection requests<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;procRequests :: MVar () -&gt; Socket -&gt; IO ()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;procRequests lock mastersock = <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do (connsock, clientaddr) &lt;- accept mastersock<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handle lock clientaddr<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"syslogtcpserver.hs: client connnected"<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkIO $ procMessages lock connsock clientaddr<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procRequests lock mastersock<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- | Process incoming messages<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;procMessages :: MVar () -&gt; Socket -&gt; SockAddr -&gt; IO ()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;procMessages lock connsock clientaddr =<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do connhdl &lt;- socketToHandle connsock ReadMode<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hSetBuffering connhdl LineBuffering<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; messages &lt;- hGetContents connhdl<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapM_ (handle lock clientaddr) (lines messages)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hClose connhdl<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handle lock clientaddr <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"syslogtcpserver.hs: client disconnected"<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- Lock the handler before passing data to it.<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;handle :: MVar () -&gt; HandlerFunc<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- This type is the same as<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- handle :: MVar () -&gt; SockAddr -&gt; String -&gt; IO ()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;handle lock clientaddr msg =<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;withMVar lock <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (\a -&gt; handlerfunc clientaddr msg &gt;&gt; return a)<br><br>-- A simple handler that prints incoming packets<br>plainHandler :: HandlerFunc<br>plainHandler addr msg = <br> &nbsp; &nbsp;putStrLn $ "From " ++ show addr ++ ": " ++ msg</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Para a nossa implementação SyslogTypes, consulte a secção "Exemplo UDP Client: syslog"</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Vamos olhar para este código. Nosso circuito principal é em procRequests, onde loop sempre espera por novas conexões dos clientes. A aceitação chama blocos até que um cliente se conecte. Quando um cliente liga(conecta), temos um novo socket e o endereço do cliente. Passamos uma mensagem para o manipulador sobre isso, então use forkIO criar uma thread para lidar com os dados desse cliente. Esta discussão é executado procMessages</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Quando se trata de dados em TCP, muitas vezes é conveniente converter um socket em um handle no Haskell.O que fazemos aqui é definir explicitamente o buffer, um ponto importante para a comunicação TCP. Em seguida, montamos uma “leitura preguiçosa” do handler do socket. Para cada linha de entrada, passamos o handler para lidar com ela. Quando não há mais dados - porque o user remoto fechou o socket- temos uma mensagem sobre isso como saida.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Como estamos lidando com várias mensagens recebidas de uma vez, temos de garantir que não estamos escrevendo várias mensagens de uma só vez no manipulador(handler). Isso poderia resultar em saída ilegível. Nós usamos um bloqueio simples para serializar o acesso para o manipulador, e escrever um nhandler simples para lidarmos com a função.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Você pode testar isso com o cliente que vamos apresentar em seguida, ou você ainda pode usar o programa telnet para se conectar a esse servidor. Cada linha de texto que você enviar para ele será impresso na tela pelo servidor. Vamos testá-lo:</span></p><p class="c3"><span class="c4">&nbsp;</span></p><p class="c3"><span class="c4">ghci&gt; </span><span class="c0">:load syslogtcpserver.hs</span><span class="c4"><br>[1 of 1] Compiling Main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( syslogtcpserver.hs, interpreted )<br>Ok, modules loaded: Main.<br>ghci&gt; </span><span class="c0">serveLog "10514" plainHandler</span><span class="c4"><br>Loading package parsec-2.1.0.0 ... linking ... done.<br>Loading package network-2.1.0.0 ... linking ... done.</span><span class="c1"></span></p><p class="c3"><span class="c1">Neste ponto, o servidor irá começar a escutar as conexões na porta 10514. Ele não irá aparecer para fazer nada até que um cliente se conecte. Nós poderíamos usar telnet para se conectar ao servidor:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c4">~$ </span><span class="c0">telnet localhost 10514</span><span class="c4"><br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is '^]'.</span><span class="c0">Test message</span><span class="c4"></span><span class="c0">^]</span><span class="c4"><br>telnet&gt; </span><span class="c0">quit</span><span class="c4"><br>Connection closed.</span><span class="c6"></span></p><p class="c3"><span class="c1">Enquanto isso, no nosso terminal em execução, o servidor TCP, você verá algo como isto:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c4">From 127.0.0.1:38790: syslogtcpserver.hs: client connnected<br>From 127.0.0.1:38790: Test message<br>From 127.0.0.1:38790: syslogtcpserver.hs: client disconnected</span></p><p class="c3"><span class="c6">&nbsp;</span></p><p class="c3"><span class="c1">Isto mostra um cliente conectado a partir da porta 38.790 na máquina local (127.0.0.1). Depois de conectado, ele enviou uma mensagem, e desconectou. Quando você está agindo como um cliente TCP, o sistema operacional atribui uma porta não utilizada para você. Este número de porta normalmente será diferente a cada vez que você executar o programa.</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3 c8"><a name="h.k2lqzn-wpqzwh"></a><span class="c5">TCP Client Syslog</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Agora, vamos escrever um cliente para o nosso protocolo TCP syslog. Este cliente será semelhante ao cliente UDP, mas há algumas mudanças. Em primeiro lugar, uma vez que o TCP é um protocolo de streaming, podemos enviar dados através de um identificador em vez de utilizar as operações de tomada de baixo nível. Em segundo lugar, não precisamos mais armazenar o endereço de destino no SyslogHandle já que estaremos usando um </span><span class="c1 c16">connect </span><span class="c1">para estabelecer a conexão TCP. Finalmente, temos uma maneira de saber onde termina uma mensagem e começa o próximo. Com o UDP, que foi fácil, porque cada mensagem era um pacote lógico discreto. Com o TCP, vamos usar o caractere de nova linha '\ n' como o marcador de fim-de-mensagem, embora isso não signifique que cada mensagem possa conter a nova linha. Aqui está o nosso código:</span></p><p class="c3"><span class="c1"></span><span class="c2">-- file: ch27/syslogtcpclient.hs<br>import Data.Bits<br>import Network.Socket<br>import Network.BSD<br>import Data.List<br>import SyslogTypes<br>import System.IO<br><br>data SyslogHandle = <br> &nbsp; &nbsp;SyslogHandle {slHandle :: Handle,<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;slProgram :: String}<br><br>openlog :: HostName &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Remote hostname, or localhost<br> &nbsp; &nbsp; &nbsp; &nbsp;-&gt; String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Port number or name; 514 is default<br> &nbsp; &nbsp; &nbsp; &nbsp;-&gt; String &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- ^ Name to log under<br> &nbsp; &nbsp; &nbsp; &nbsp;-&gt; IO SyslogHandle &nbsp; &nbsp; &nbsp;-- ^ Handle to use for logging<br>openlog hostname port progname =<br> &nbsp; &nbsp;do -- Look up the hostname and port. &nbsp;Either raises an exception<br> &nbsp; &nbsp; &nbsp; -- or returns a nonempty list. &nbsp;First element in that list<br> &nbsp; &nbsp; &nbsp; -- is supposed to be the best option.<br> &nbsp; &nbsp; &nbsp; addrinfos &lt;- getAddrInfo Nothing (Just hostname) (Just port)<br> &nbsp; &nbsp; &nbsp; let serveraddr = head addrinfos<br><br> &nbsp; &nbsp; &nbsp; -- Establish a socket for communication<br> &nbsp; &nbsp; &nbsp; sock &lt;- socket (addrFamily serveraddr) Stream defaultProtocol<br><br> &nbsp; &nbsp; &nbsp; -- Mark the socket for keep-alive handling since it may be idle<br> &nbsp; &nbsp; &nbsp; -- for long periods of time<br> &nbsp; &nbsp; &nbsp; setSocketOption sock KeepAlive 1<br><br> &nbsp; &nbsp; &nbsp; -- Connect to server<br> &nbsp; &nbsp; &nbsp; connect sock (addrAddress serveraddr)<br><br> &nbsp; &nbsp; &nbsp; -- Make a Handle out of it for convenience<br> &nbsp; &nbsp; &nbsp; h &lt;- socketToHandle sock WriteMode<br><br> &nbsp; &nbsp; &nbsp; -- We're going to set buffering to BlockBuffering and then<br> &nbsp; &nbsp; &nbsp; -- explicitly call hFlush after each message, below, so that<br> &nbsp; &nbsp; &nbsp; -- messages get logged immediately<br> &nbsp; &nbsp; &nbsp; hSetBuffering h (BlockBuffering Nothing)<br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; -- Save off the socket, program name, and server address in a handle<br> &nbsp; &nbsp; &nbsp; return $ SyslogHandle h progname<br><br>syslog :: SyslogHandle -&gt; Facility -&gt; Priority -&gt; String -&gt; IO ()<br>syslog syslogh fac pri msg =<br> &nbsp; &nbsp;do hPutStrLn (slHandle syslogh) sendmsg<br> &nbsp; &nbsp; &nbsp; -- Make sure that we send data immediately<br> &nbsp; &nbsp; &nbsp; hFlush (slHandle syslogh)<br> &nbsp; &nbsp;where code = makeCode fac pri<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sendmsg = "&lt;" ++ show code ++ "&gt;" ++ (slProgram syslogh) ++<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;": " ++ msg<br><br>closelog :: SyslogHandle -&gt; IO ()<br>closelog syslogh = hClose (slHandle syslogh)<br><br>{- | Convert a facility and a priority into a syslog code -}<br>makeCode :: Facility -&gt; Priority -&gt; Int<br>makeCode fac pri =<br> &nbsp; &nbsp;let faccode = codeOfFac fac<br> &nbsp; &nbsp; &nbsp; &nbsp;pricode = fromEnum pri <br> &nbsp; &nbsp; &nbsp; &nbsp;in<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(faccode `shiftL` 3) .|. pricode</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c1">Nós podemos testá-lo sob ghci. Se você ainda tiver o servidor de mais cedo TCP em execução, a sessão pode parecer algo como isto:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c4">ghci&gt; </span><span class="c0">:load syslogtcpclient.hs</span><span class="c4"><br>Loading package base ... linking ... done.<br>[1 of 2] Compiling SyslogTypes &nbsp; &nbsp; &nbsp;( SyslogTypes.hs, interpreted )<br>[2 of 2] Compiling Main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( syslogtcpclient.hs, interpreted )<br>Ok, modules loaded: Main, SyslogTypes.<br>ghci&gt; </span><span class="c0">openlog "localhost" "10514" "tcptest"</span><span class="c4"><br>Loading package parsec-2.1.0.0 ... linking ... done.<br>Loading package network-2.1.0.0 ... linking ... done.<br>ghci&gt; </span><span class="c0">sl &lt;- openlog "localhost" "10514" "tcptest"</span><span class="c4"><br>ghci&gt; </span><span class="c0">syslog sl USER INFO "This is my TCP message"</span><span class="c4"><br>ghci&gt; </span><span class="c0">syslog sl USER INFO "This is my TCP message again"</span><span class="c4"><br>ghci&gt; </span><span class="c0">closelog sl</span></p><p class="c3"><span class="c6 c7">&nbsp;</span></p><p class="c3"><span class="c1">Over on the server, you'll see something like this:</span></p><p class="c3"><span class="c1">No servidor você verá algo como isto:</span></p><p class="c3"><span class="c1">&nbsp;</span></p><p class="c3"><span class="c17">From 127.0.0.1:46319: syslogtcpserver.hs: client connnected<br>From 127.0.0.1:46319: &lt;9&gt;tcptest: This is my TCP message<br>From 127.0.0.1:46319: &lt;9&gt;tcptest: This is my TCP message again<br>From 127.0.0.1:46319: syslogtcpserver.hs: client disconnected</span><span class="c1"></span></p><p class="c3"><span class="c1">O </span><span class="c4">&lt;9&gt;</span><span class="c1"> é a prioridade e o código de instanciação que está sendo enviado junto, assim como foi com UDP.</span></p><p class="c3"><span class="c1">&nbsp;</span></p></div><div id="footer"><a target="_blank" title="Tradu&ccedil;&atilde;o do cp&iacute;tulo 27 Sockets and syslog" href="https://docs.google.com/document/d/1uO2MU85rfD5waXHo0n2iVa0bai_NEQIVTwfmDL5xAMA/edit">Editar esta página</a>, se você tiver permissão<span class="dash">–</span><span>Publicado por <a target="_blank" title="Learn more about Google Docs" href="https://docs.google.com/">Google Docs</a>
</span><span class="dash">–</span><a href="https://docs.google.com/abuse?id=1uO2MU85rfD5waXHo0n2iVa0bai_NEQIVTwfmDL5xAMA">Denunciar abuso</a><span class="dash">–</span><span>5Atualizado automaticamente a cada </span> minutos</div><script type="text/javascript">
(function(){var g="",i="&srt=",l="&tran=",m="&p=s",n="&npn=1",o="&apa=1",r="&",s="start",t="_",u=".",v="=",w="http://csi.gstatic.com/csi",x="?v=3",y="&s=",z="kix",A="&action=",B="&it=",C=",",D="&rt=";
if(window.jstiming){window.jstiming.a={};window.jstiming.c=1;var E=function(b,c,e){var a=b.t[c],h=b.t.start;if(a&&(h||e)){a=b.t[c][0];h=e!=undefined?e:h[0];return a-h}},G=function(b,c,e){var a=g;if(window.jstiming.pt){a+=i+window.jstiming.pt;delete window.jstiming.pt}try{if(window.external&&window.external.tran)a+=l+window.external.tran;else if(window.gtbExternal&&window.gtbExternal.tran)a+=l+window.gtbExternal.tran();else if(window.chrome&&window.chrome.csi)a+=l+window.chrome.csi().tran}catch(h){}var d=
window.chrome;if(d)if(d=d.loadTimes){if(d().wasFetchedViaSpdy)a+=m;if(d().wasNpnNegotiated)a+=n;if(d().wasAlternateProtocolAvailable)a+=o}if(b.b)a+=r+b.b;d=b.t;var F=d.start,p=[],j=[],f;for(f in d)if(f!=s)if(f.indexOf(t)!=0){var k=d[f][1];if(k)d[k]&&j.push(f+u+E(b,f,d[k][0]));else F&&p.push(f+u+E(b,f))}delete d.start;if(c)for(var q in c)a+=r+q+v+c[q];return[e?e:w,x,y+(window.jstiming.sn||z)+A,b.name,j.length?B+j.join(C):g,g,a,D,p.join(C)].join(g)};window.jstiming.report=function(b,c,e){b=G(b,c,e);
if(!b)return g;c=new Image;var a=window.jstiming.c++;window.jstiming.a[a]=c;c.onload=c.onerror=function(){delete window.jstiming.a[a]};c.src=b;c=null;return b}};})()
</script><script type="text/javascript">KX_timer.tick('tl'); if (document.location.protocol == 'https:') {window.jstiming.report(KX_timer, undefined , 'https://gg.google.com/csi');} else {window.jstiming.report(KX_timer);}</script></body></html>