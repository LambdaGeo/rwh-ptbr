<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Capítulo&nbsp;3.&nbsp;Definindo os tipos e entendendo as funções</title>

  
  
  <link rel="stylesheet" href="support/styles.css" type="text/css">

  
  <meta name="generator" content="Bluefish 1.0.7">

  
  <link rel="start" href="index.html" title="Real World Haskell">

  
  <link rel="up" href="index.html" title="Real World Haskell">

  
  <link rel="prev" href="types-and-functions.html" title="Chapter&nbsp;2.&nbsp;Types and Functions">

  
  <link rel="next" href="functional-programming.html" title="Chapter&nbsp;4.&nbsp;Functional programming">

  
  <link rel="alternate" type="application/atom+xml" title="Comments" href="/feeds/comments/">

  
  <link rel="shortcut icon" type="image/png" href="support/figs/favicon.png">

  
  <script type="text/javascript" src="support/jquery-min.js"></script>
  
  <script type="text/javascript" src="support/form.js"></script>
  
  <script type="text/javascript" src="support/hsbook.js"></script>
</head><body style="color: black; background-color: white;" alink="#0000ff" link="#0000ff" vlink="#840084">
<div class="navheader">
<h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2>
</div>

<div class="navheader">
<table summary="Navigation header" width="100%">
  <tbody>
    <tr>
      <th colspan="3" align="center">Capítulo&nbsp;3.&nbsp;Definir os
tipos, racionalizando as funções<br>
      </th>
    </tr>
    <tr>
      <td align="left" width="20%"><a accesskey="p" href="types-and-functions.html">Prev</a>&nbsp;</td>
      <th align="center" width="60%">&nbsp;<br>
      </th>
      <td align="right" width="20%">&nbsp;<a accesskey="n" href="functional-programming.html">Next</a></td>
    </tr>
  </tbody>
</table>
</div>

<div class="chapter" id="deftypes" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title">Capítulo&nbsp;3.&nbsp;Definindo os tipos e entendendo
as funções</h2>
</div>
</div>
</div>
<div class="toc">
<p><b>Índice analítico</b></p>
<dl>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.data">Definir
um tipo de dado novo</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id582783">Nomenclatura
de tipos e valores</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.alias">Sinónimos
de tipo</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.adt">Tipos
de dado algébricos</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id583233">Tuplas,
tipos de dado algébricos, e quando utilizar cada</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.adt.comp">Análogos
aos tipos de dado algébricos em outras línguas</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dd>
        <dl>
          <dt><span class="sect3"><a href="defining-types-streamlining-functions.html#id583523">A estrutura</a></span><br>
            <br>
            <br>
            <br>
          <br>
</dt>
          <dt><span class="sect3"><a href="defining-types-streamlining-functions.html#id583611">A enumeração</a></span><br>
            <br>
            <br>
            <br>
          <br>
</dt>
          <dt><span class="sect3"><a href="defining-types-streamlining-functions.html#id583781">A união
discriminada</a></span><br>
            <br>
            <br>
            <br>
          <br>
</dt>
        </dl>
        <br>
        <br>
        <br>
        <br>
      <br>
</dd>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.pattern">Casamento
de padrões</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id584277">Construção
e desconstrução</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id584453">Outras
aventuras</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id584746">Nomenclatura
de variáveis dos padrões</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.wildcard">O
padrão de curinga</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.patterns.nonexhaustive">Padrões
exaustivas e curingas</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.record">Sintaxe
record</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.paramtypes">Tipos
parametrizados</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.recursive">Tipos
recursivos</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id585938">Exercícios</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.error">Relatando
erros</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.morecontrolled">Uma
abordagem mais controlada</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.locals">Introdução
das variáveis locais</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id586544">Sombreamento</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id586728">A cláusula
where</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.locals.functions">Funções
locais, variáveis globais</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.offside">A
regra offside e espaço em branco em uma expressão</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.tabs">Uma
nota sobre guias versus espaços</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#deftypes.block">A
regra de impedimento não é obrigatório</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.case">A
cláusula case</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.pattern.limits">Erros
comuns dos novatos com os padrões</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dd>
    <dl>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id587485">Correspondência
incorretamente contra uma variável</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
      <dt><span class="sect2"><a href="defining-types-streamlining-functions.html#id587613">Tentando
comparar a igualdade incorretamente</a></span><br>
        <br>
        <br>
        <br>
      <br>
</dt>
    </dl>
    <br>
    <br>
    <br>
    <br>
  <br>
</dd>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#deftypes.guard">Avaliação
condicional com guardas</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
  <dt><span class="sect1"><a href="defining-types-streamlining-functions.html#id587860">Exercícios</a></span><br>
    <br>
    <br>
    <br>
  <br>
</dt>
</dl>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.data">Definir um
tipo de dado novo</h2>
</div>
</div>
</div>
<p id="x_C4"><a name="x_C4"></a> Embora as listas e tuplas são úteis,
muitas vezes vamos querer
construir nosso próprios tipos de dadis. Isto permite-nos estruturar os
valores em nossos programas. Em vez de usar uma tupla anônimo, podemos
dar a uma coleção de valores relacionados um nome e um tipo distinto.
Definindo nossopróprios tipos também melhoramos a segurança do nosso
código: Haskell não permitirá misturar acidentalmente valores de dois
tipos que são estruturalmente semelhantes, mas têm nomes diferentes. </p>
<p id="x_Cf"><a name="x_Cf"></a> Depois motivação, vamos
considerar alguns tipos de dados que uma pequena livraria on-line
poderia necessitar para o seu gerenciamento. Não faremos qualquer
tentativa de uma completa ou realista definições dedados, mas pelo
menos estaremos ligando-os ao mundo real. </p>
<p id="x_Df"><a name="x_Df"></a> Nós definimos um novo tipo de dado
usando o palavra-chave <code class="code">data</code>. </p>
<a name="BookStore.hs:BookInfo"></a>
<pre id="BookStore.hs:BookInfo" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>data InfoLivro = Livro Int String [String]<br>               deriving Show</pre>
<p id="x_D4"><a name="x_D4"></a> O <span class="type">InfoLivro</span>
após a palavra-chave <code class="code">data</code> é o nome do nosso
novo tipo. Chamamos <span class="type">InfoLivro</span> um <span class="emphasis"><em>construtor de tipo</em></span>.
Assim que tiver definido um tipo, usaremos o construtor de tipo para se
referir a ela. Como já mencionado, um nome de tipo e, portanto, um
construtor de tipo, deve começar com uma letra maiúscula. </p>
<p id="x_pB1"><a name="x_pB1"></a> O <code class="code">Livro</code>
que se segue é o nome do <span class="emphasis"><em>construtor de valor</em></span>
(às vezes chamado um construtor de dados). Nós usamos isso para criar
um valor do tipo <span class="type">InfoLivro</span>. Um nome de um
construtor de valor também deve iniciar com uma letra maiúscula. </p>
<p id="x_Ef"><a name="x_Ef"></a> Depois <code class="code">Livro</code>,
os <span class="type">Int</span>, <span class="type">String</span>, e
<span class="type">[String]</span> que se seguem são os <span class="emphasis"><em>componentes</em></span> do tipo. Um componente
tem a mesma finalidade em Haskell como um campo de uma estrutura ou
classe em outra linguagem: é um “<span class="quote">espaço</span>”
onde mantemos um valor. (Nós geralmente nos referimos aos componentes
como campos.) </p>
<p id="x_Ff"><a name="x_Ff"></a> Neste exemplo, o <span class="type">Int</span>
representa um identificador (por exemplo, usado no banco de dados de
estoque) de um livro, <span class="type">String</span> seu título, e <span class="type">[String]</span> os nomes de seus autores. </p>
<p id="x_Gf"><a name="x_Gf"></a> Para fazer o link para um conceito já
vimos, o tipo <span class="type">InfoLivro</span> contém os mesmos
componentes como a 3-tupla do tipo <span class="type">(Int, String,
[String])</span>,
mas tem um tipo distinto. Não podemos acidentalmente (ou
deliberadamente) usar um em um contexto onde um outro tipo é o
esperado. Por exemplo, uma livraria também é passível de ter revistas. </p>
<a name="BookStore.hs:MagazineInfo"></a>
<pre id="BookStore.hs:MagazineInfo" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>data InfoRevista = Revista Int String [String]<br>                 deriving Show</pre>
<p id="x_qB1"><a name="x_qB1"></a> Mesmo que este tipo <span class="type">InfoRevista</span> tem a mesma estrutura que o nosso tipo
<span class="type">InfoLivro</span>, Haskell trata os tipos come
distintos porque a sua natureza e construtores de valor têm nomes
diferentes. </p>
<div class="note">
<table summary="Note: Deriving what?" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">Derivando o quê?</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_E4"><a name="x_E4"></a> Nós vamos explicar o significado
completo de <code class="code">deriving Show</code> depois, em <a class="xref" href="using-typeclasses.html#typeclasses.wellknown.show" title="Show">seção denominada “Show”</a>. Por enquanto, é o suficiente
saber que precisamos disso em uma declaração deste tipo para que o <span class="command"><strong>ghci</strong></span> automaticamente saiba
como imprimir um valor deste tipo. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_F4"><a name="x_F4"></a> Podemos criar um novo valor do tipo <span class="type">InfoLivro</span> tratando <code class="function">Livro</code>
como uma função, e aplicá-lo com argumentos do tipo <span class="type">Int</span>,
<span class="type">String</span>, e <span class="type">[String]</span>.
</p>
<a name="BookStore.hs:myInfo"></a>
<pre id="BookStore.hs:myInfo" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>meuInfo = Livro 9780135072455 "Algebra of Programming"<br>                ["Richard Bird", "Oege de Moor"]</pre>
<p id="x_G4"><a name="x_G4"></a> Uma vez que tenhamos definido um
modelo, podemos experimentar-lo com o <span class="command"><strong>ghci</strong></span>.
Nós começamos usando o comando <span class="command"><strong>:load</strong></span>
ou <span class="command"><strong>:l</strong></span> para carregar
nosso arquivo de origem. </p>
<a name="bookstore.ghci:load"></a>
<pre id="bookstore.ghci:load" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:l Livraria</code></strong><br>[1 of 1] Compiling Main             ( Livraria.hs, interpreted )<br>Ok, modules loaded: Main.<br></pre>
<p id="x_H4"><a name="x_H4"></a> Lembre-se que a variável <code class="code">meuInfo</code>&nbsp; é definida no nosso arquivo fonte.
Aqui está ela. </p>
<a name="bookstore.ghci:myInfo"></a>
<pre id="bookstore.ghci:myInfo" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>meuInfo</code></strong><br>Livro 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t meuInfo</code></strong><br>meuInfo :: InfoLivro<br></pre>
<p id="x_I4"><a name="x_I4"></a> Podemos construir novos valores
interativamente no <span class="command"><strong>ghci</strong></span>
também. </p>
<a name="bookstore.ghci:newValue"></a>
<pre id="bookstore.ghci:newValue" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Livro 0 "O Livro dos Seres Imaginários" ["Jorge Luis Borges"]</code></strong><br>Book 0 "O Livro dos Seres Imaginários" ["Jorge Luis Borges"]<br></pre>
<p id="x_AL"><a name="x_AL"></a> O comando <span class="command"><strong>ghci</strong></span>
<span class="command"><strong>:type</strong></span> ou <span class="command"><strong>:t</strong></span> nos permite ver o tipo de
expressão é. </p>
<a name="bookstore.ghci:valueType"></a>
<pre id="bookstore.ghci:valueType" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t Livro 1 "Cosmicomics" ["Italo Calvino"]</code></strong><br>Livro 1 "Cosmicomics" ["Italo Calvino"] :: InfoLivro<br></pre>
<p id="x_rB1"><a name="x_rB1"></a> Lembre-se que, se quisermos definir
uma nova variável dentro do <span class="command"><strong>ghci</strong></span>,
a sintaxe é ligeiramente diferente daquela de um arquivo fonte Haskell:
é preciso colocar um <code class="literal">let</code> na frente da
variável. </p>
<a name="bookstore.ghci:newVar"></a>
<pre id="bookstore.ghci:newVar" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>let livro = Book 173 "Use of Weapons" ["Iain M. Banks"]</code></strong>
</pre>
<p id="x_J4"><a name="x_J4"></a> Para saber mais sobre um tipo, podemos
usar alguns <span class="command"><strong>ghci</strong></span>
capabilidades de browsing. O comando <span class="command"><strong>:info</strong></span>
ou <span class="command"><strong>:i</strong></span> recebe informações
do <span class="command"><strong>ghci</strong></span> para nos dizer
tudo o que se sabe sobre um determinado nome. </p>
<a name="bookstore.ghci:info"></a>
<pre id="bookstore.ghci:info" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:i InfoLivro</code></strong><br>data InfoLivro = Livro Int String [String]<br>  	-- Defined at Livraria.hs:4:5-12<br>instance Show InfoLivro -- Defined at Livraria.hs:4:5-12<br></pre>
<p id="x_K4"><a name="x_K4"></a> Podemos também descobrir como usamos <code class="function">Livro</code> para construir um novo valor do tipo <span class="type">InfoLivro</span>. </p>
<a name="bookstore.ghci:type"></a>
<pre id="bookstore.ghci:type" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t Livro</code></strong><br>Livro :: Int -&gt; String -&gt; [String] -&gt; InfoLivro<br></pre>
<p id="x_L4"><a name="x_L4"></a> Podemos tratar um construtor de
valor como uma outra função qualquer, o que ele faz é criar e retornar
um novo valor do tipo que desejamos. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id582783">Nomenclatura de tipos e valores</h3>
</div>
</div>
</div>
<p id="x_Hf"><a name="x_Hf"></a> Quando introduzimos o tipo de <span class="type">InfoLivro</span>, nos deliberadamente escolhemos dar ao
construtor do tipo <span class="type">InfoLivro</span> um nome
diferente a partir do construtor valor <code class="code">Livro</code>,
apenas para torná-lo evidente quem era quem. </p>
<p id="x_If"><a name="x_If"></a>No entanto, em Haskell, os nomes dos
tipos e valores são independentes
uns dos outros. Nós só usamos um construtor de tipo (ou seja, nome do
tipo) em uma declaração do tipo ou em umaassinatura do tipo. Nós só
usamos um construtor de valor em código real. Porque estes
usos são distintos, não há ambigüidade se dermos a um construtor de
tipo econstrutor valor o mesmo nome. Se estamos escrevendo uma
assinatura de tipo, então estamos referindo a um construtor de tipo. Se
estamos escrevendo uma expressão, então estamos usando o construtor de
valor. </p>
<a name="BookStore.hs:BookReview"></a>
<pre id="BookStore.hs:BookReview" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs<br>-- Vamos apresentar o tipo de IDCliente em breve.</code><br>data RevisãoLivro = RevisãoLivro InfoLivro IDCliente String</pre>
<p id="x_Kf"><a name="x_Kf"></a> Esta definição diz que o tipo chamado <span class="type">RevisãoLivro</span> tem um construtor de valor que também
é chamado <code class="code">RevisãoLivro</code>. </p>
<p id="x_Lf"><a name="x_Lf"></a> Não só é <span class="emphasis"><em>legal</em></span>
para um construtor de valor para ter o mesmo nome de seu construtor de
tipo, como é <span class="emphasis"><em>normal</em></span>: você vai
ver isso o tempo todo em código Haskell. </p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.alias">Sinónimos de
tipo</h2>
</div>
</div>
</div>
<p id="x_Mf"><a name="x_Mf"></a>Podemos introduzir um <span class="emphasis"><em>sinônimo</em></span> para um tipo existente em
qualquer momento, para dar um tipo de nome mais descritivo. Por
exemplo, o tipo <span class="type">String</span> no nosso tipo <span class="type">RevisãoLivro</span> não nos diz para que a string é
usada, mas podemos esclarecer isso.</p>
<a name="BookStore.hs:BetterReview"></a>
<pre id="BookStore.hs:BetterReview" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>type IDCliente = Int<br>type CorpoRevisão = String<br><br>data RevisãoLivroMelhor = RevisãoLivroMelhor InfoLivro IDCliente CorpoRevisão</pre>
<p id="x_Nf"><a name="x_Nf"></a>O palavra-chave <code class="literal">type</code>
apresenta um sinônimo tipo. O novo nome é do lado esquerdo da <code class="code">=</code>, com o nome existente do lado direito. Os dois
nomes identificam o mesmo tipo, então sinônimos&nbsp; são usados <span class="emphasis"><em>apenas</em></span> para tornar o código mais
legível. </p>
<p id="x_Of"><a name="x_Of"></a> Nós também podemos usar um sinônimo de
tipo para criar um nome mais curto para um modelo detalhado. </p>
<a name="BookStore.hs:BookRecord"></a>
<pre id="BookStore.hs:BookRecord" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>type NotaLivro = (InfoLivro, RevisãoLivro)</pre>
<p id="x_Pf"><a name="x_Pf"></a> Isto indica que podemos utilizar <span class="type">NotaLivro</span> como um sinônimo para a tupla <span class="type">(nfoLivro, RevisãoLivro)</span>. Um sinônimo de tipo só
cria um novo nome que se refere a um tipo existente<sup>[<a name="id582956" href="#ftn.id582956" class="footnote">7</a>]</sup>.
Continuamos a usar os mesmos construtores de valor para criar um valor
do tipo. </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.adt">Tipos de dado
algébricos</h2>
</div>
</div>
</div>
<p id="x_M4"><a name="x_M4"></a> O nosso conhecido <span class="type">Bool</span>
é o mais comum e simples exemplo de uma categoria de tipo chamada <span class="emphasis"><em>tipo de dado algébricos</em></span>. Um tipo de
dado algébrico pode ter mais de um construtor de valor. </p>
<a name="Bool.hs:Bool"></a>
<pre id="Bool.hs:Bool" class="programlisting"><code class="codecomment">-- arquivo: ca03/Bool.hs</code><br>data Bool = False | True</pre>
<p id="x_N4"><a name="x_N4"></a> O tipo <span class="type">Bool</span>
tem dois construtores, os valores <code class="code">True</code> e <code class="code">False</code>. Cada construtor de valor é separado na
definição por um caracter <code class="literal">|</code>, que pode
ler-se “<span class="quote">ou</span>”: nós podemos construir um <span class="type">Bool</span> que tem o valor <code class="code">True</code>,
ou o valor <code class="code">False</code>. Quando um tipo tem mais de
um construtor de valor, são normalmente referido como <span class="emphasis"><em>alternativas</em></span> ou <span class="emphasis"><em>casos</em></span>. Podemos usar qualquer uma das
alternativas para criar um valor desse tipo. </p>
<div class="note">
<table summary="Note: A note about naming" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">Uma nota sobre nomeação</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_Qf"><a name="x_Qf"></a> Embora a expressão “<span class="quote">tipo de dado algébrico</span>” seja longa, nós estamos
tendo o cuidado de evitar o uso da sigla “<span class="quote">TAD</span>”.
Essa sigla já é amplamente entendida como suporte para o “<span class="quote">tipo <span class="emphasis"><em>abstrato</em></span> de
dado</span>”.
Desde que Haskell suporte ambos, tipos de dados algébricos e tipos de
dados abstratos, vamos ser explícito e evitar a sigla inteiramente. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_O4"><a name="x_O4"></a>Cada um dos construtores de valor de um
tipo de dados algébricos podem ter
zero ou mais argumentos. Por exemplo, aqui está uma forma que poderia
representar informações de faturas. </p>
<a name="BookStore.hs:BillingInfo"></a>
<pre id="BookStore.hs:BillingInfo" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>type TitularCartao = String<br>type NumeroCartao = String<br>type Endereço = [String]<br><br>data InfoFatura = CartãoCrédito NumeroCartao TitularCartao Endereço<br>                     | PagamentoContraEntrega<br>                     | Fatura IDCliente<br>                     deriving Show</pre>
<p id="x_P4"><a name="x_P4"></a>Aqui, nós estamos dizendo que
suportamos três formas de faturar as compras dos
nossos clientes. Se quiser pagar com cartão de crédito, deve
fornecer o número do cartão, o nome do titular, e endereço do titular
da
fatura como argumentos para o construtor do valor <code class="code">CartãoCrédito</code>.
Alternativamente, é possível pagar a pessoa que entregou a sua
encomenda. Uma vez que não precisamos guardar qualquer informação
adicional neste caso, nós não especificamos nenhum argumento para o
construtor <code class="code">PagamentoContraEntrega</code>. Por
último, poderemos enviar uma fatura para o cliente especificado,neste
caso precisamos do seu <span class="type">IDCliente</span> como
argumento para o construtor <code class="code">Fatura</code>. </p>
<p id="x_Rf"><a name="x_Rf"></a> Quando usamos um construtor de valor
para criar um valor do tipo <span class="type">InfoFaturamento</span>,
devemos fornecer os argumentos que ele necessita. </p>
<a name="bookstore.ghci:billingInfo"></a>
<pre id="bookstore.ghci:billingInfo" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t CartãoCrédito</code></strong><br>CartãoCrédito :: NumeroCartao -&gt; TitularCartao -&gt; Endereço -&gt; InfoFaturamento<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>CartãoCrédito "2901650221064486" "Doralice de Araújo Chaves" ["Rio de Janeiro", "Brasil"]</code></strong><br>CartãoCrédito "2901650221064486" "Doralice de Araújo Chaves" ["Rio de Janeiro", "Brasil"]<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t it</code></strong><br>it :: InfoFaturamento<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Fatura</code></strong><br><br>&lt;interactive&gt;:1:0:<br>    No instance for (Show (IDCliente -&gt; InfoFaturamento))<br>      arising from a use of `print' at &lt;interactive&gt;:1:0-6<br>    Possible fix:<br>      add an instance declaration for (Show (IDCliente -&gt; InfoFaturamento))<br>    In the expression: print it<br>    In a 'do' expression: print it<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t it</code></strong><br>it :: InfoFaturamento<br></pre>
<p id="x_bO1"><a name="x_bO1"></a> A mensagem de erro <code class="code">No instance</code> surgiu porque nós não fornecemos um
argumento para o construtor <code class="code">Fatura</code>. Como
resultado, nós estávamos tentando imprimir o construtor <code class="code">Fatura</code>
de si mesmo. Construtor que requer um argumento e retorna um valor, por
isso é uma função. Nós não podemos imprimir funções em Haskell, que é
basicamente a razão pela qual o intérprete reclamou. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id583233">Tuplas, tipos de dado algébricos, e
quando utilizar cada</h3>
</div>
</div>
</div>
<p id="x_Sf"><a name="x_Sf"></a>Há alguma sobreposição entre tuplas e
definidas pelo usuário tipos de
dado algébricos. Se quiséssemos, poderíamos representar o nosso tipo de
<span class="type">InfoLivro</span> anteriormente como um tupla <span class="type">(Int, String, [String])</span>. </p>
<a name="bookstore.ghci:tuple"></a>
<pre id="bookstore.ghci:tuple" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Livro 2 "A Riqueza das Redes" ["Yochai Benkler"]</code></strong><br>Livro 2 "A Riqueza das Redes" ["Yochai Benkler"]<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>(2, "A Riqueza das Redes", ["Yochai Benkler"])</code></strong><br>(2,"A Riqueza das Redes",["Yochai Benkler"])<br></pre>
<p id="x_Tf"><a name="x_Tf"></a> Tipos de dado algébrica nos
permite distinguir entre idênticas partes umw informação.
Duas tuplas com elementos do mesmo tipo são estruturalmente idênticos,
então elas tem o mesmo tipo. </p>
<a name="Distinction.hs:tuples"></a>
<pre id="Distinction.hs:tuples" class="programlisting"><code class="codecomment">-- arquivo: ca03/Distinção.hs</code><br>a = ("Golfinho", "Cinza")<br>b = ("Mesa", "Carvalho")</pre>
<p id="x_tB1"><a name="x_tB1"></a>Uma vez que eles têm nomes
diferentes, dois tipos de dados algébrica
tem tipos distintos, mesmo que sejam estruturalmente
equivalentes. </p>
<a name="Distinction.hs:data"></a>
<pre id="Distinction.hs:data" class="programlisting"><code class="codecomment">-- arquivo: ca03/Distinção.hs</code><br>data Cetáceo = Cetáceo String String<br>data Mobiliário = Mobiliário String String<br><br>c = Cetáceo "Golfinho" "Cinza"<br>d = Mobiliário "Mesa" "Carvalho"</pre>
<p id="x_uB1"><a name="x_uB1"></a>Isso nos permite trazer ao sistema de
tipos a possibilidade de escrever programas
com menos erros. Com as tuplas definidos acima, poderíamos passar uma
descrição de uma baleia para uma função que esperava uma cadeira, e o
sistema de tipos não poderia nos ajudar. Com os tipos de
dados algébricos, não há essa possibilidade de confusão. </p>
<p id="x_vB1"><a name="x_vB1"></a> Aqui está um exemplo mais sutil.
Considere as seguintes representações de um vetor de duas dimensões. </p>
<a name="AlgebraicVector.hs:types"></a>
<pre id="AlgebraicVector.hs:types" class="programlisting"><code class="codecomment">-- arquivo: ca03/VetorAlgébrico.hs<br>-- Coordenadas x e y ou comprimentos:</code><br>data Cartesiano2D = Cartesiano2D Double Double<br>                    deriving (Eq, Show)<br><code class="codecomment">-- Ângulo e distância (magnituda).</code><br>data Polar2D = Polar2D Double Double<br>               deriving (Eq, Show)</pre>
<p id="x_Uf"><a name="x_Uf"></a> As formas polares e cartesianas usam
os mesmos tipos para seus dois elementos. No entanto, os <span class="emphasis"><em>significados</em></span> dos elementos são
diferentes. Porque <span class="type">Cartesiano2D</span> e <span class="type">Polar2D</span> são tipos distintos, o sistema de tipos
não vai nos deixar acidentalmente usar um valor <span class="type">Cartesian2D</span>
onde um <span class="type">Polar2D</span> é esperado, ou vice-versa. </p>
<a name="algebraicvector.ghci:typed"></a>
<pre id="algebraicvector.ghci:typed" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Cartesiano2D (sqrt 2) (sqrt 2) == Polar2D (pi/4) 2</code></strong><br><br>&lt;interactive&gt;:1:33:<br>    Couldn't match expected type `Cartesiano2D'<br>           against inferred type `Polar2D'<br>    In the second argument of `(==)', namely `Polar2D (pi / 4) 2'<br>    In the expression:<br>          Cartesiano2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2<br>    In the definition of `it':<br>        it = Cartesiano2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2<br></pre>
<p id="x_Vf"><a name="x_Vf"></a> O operador <code class="function">(==)</code>
exige que os seus argumentos sejam do mesmo tipo. </p>
<div class="tip">
<table summary="Tip: Comparing for equality" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="support/figs/tip.png"></td>
      <th align="left">Comparando-se a igualdade</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_cf"><a name="x_cf"></a>Observe que no cláusule <code class="code">deriving</code> de vector tipos nossa, nós adicionamos
uma outra palavra, <code class="code">Eq</code>. Isso faz com que a
aplicação Haskell para gerar o código que nos permite comparar os
valores de igualdade. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_Wf"><a name="x_Wf"></a>Se usássemos tuplas para representar
esses valores, podemos rapidamente
nos terrenos em água quente, misturando as duas representações de forma
inadequada. </p>
<a name="algebraicvector.ghci:tupled"></a>
<pre id="algebraicvector.ghci:tupled" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>(1, 2) == (1, 2)</code></strong><br>True<br></pre>
<p id="x_Xf"><a name="x_Xf"></a> O sistema de tipos não pode salvar-nos
aqui: na medida em que se preocupa, estamos comparando dois <span class="type">(Double, Double)</span>
pares, que é uma coisa perfeitamente válido para fazer. Na verdade, não
podemos dizer que pela inspeção desses valores é suposto ser polar ou
cartesiana, mas <code class="code">(1,2)</code> tem um significado
diferente em cada representação. </p>
<p id="x_Yf"><a name="x_Yf"></a>Não há nenhuma régua dura e rápida para
decidir quando é melhor usar
uma tupla ou um tipo de dados distintas, mas aqui é uma regra a seguir.
Se você estiver usando valores compostos amplamente em seu código (como
quase todos os programas não-trivial fazer), acrescentando data das
declarações vai beneficiar você em ambos os tipo de segurança e
legibilidade. Para os mais pequenos, usa localizada, uma tupla é
geralmente fina. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.adt.comp">Análogos aos tipos de dado
algébricos em outras línguas</h3>
</div>
</div>
</div>
<p id="x_Q4"><a name="x_Q4"></a>Tipos de dado algébricos fornecer uma
poderosa forma única para
descrever tipos de dados. Outras línguas muitas vezes precisam de
várias características diferentes para atingir o mesmo grau de
expressividade. Aqui estão alguns análogos de C e C++, o que pode
tornar mais claro o que podemos fazer com os tipos de dados algébricos,
e como eles se relacionam com os conceitos que poderia ser mais
familiar. </p>
<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title" id="id583523">A estrutura</h4>
</div>
</div>
</div>
<p id="x_R4"><a name="x_R4"></a>Com apenas um construtor, um tipo de
dados algébrico é semelhante a uma
tupla: ele agrupa os valores relacionados juntos em um valor composto.
Corresponde a uma <code class="code">struct</code> em C ou C++, e seus
componentes correspondem aos campos de uma <code class="code">struct</code>.
e seus componentes correspondem aos campos do tipo <span class="type">InfoLivro</span>
que definimos anteriormente. </p>
<a name="types.c:book_info"></a>
<pre id="types.c:book_info" class="programlisting">struct info_livro {<br>    int id;<br>    char *nome;<br>    char **autores;<br>};</pre>
<p id="x_Zf"><a name="x_Zf"></a> A diferença principal entre os dois é
que os campos do tipo Haskell são anônimos e de posicionamento. </p>
<pre id="id583567" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>data InfoLivro = Livro Int String [String]<br>               deriving Show</pre>
<p id="x_af"><a name="x_af"></a> Por <span class="emphasis"><em>posicional</em></span>,
queremos dizer que o número de seção é o primeiro campo do tipo
Haskell, eo título é na segunda. Nós nos referimos a eles pelo local, e
não pelo nome. </p>
<p id="x_bf"><a name="x_bf"></a> Na <a class="xref" href="defining-types-streamlining-functions.html#deftypes.pattern" title="Pattern matching">seção chamada “casamento de padrões”</a>,
veremos como acessar os campos de um valor <span class="type">Livraria</span>.
Na <a class="xref" href="defining-types-streamlining-functions.html#deftypes.record" title="Record syntax"> seção intitulada “Sintaxe record”</a>, vamos
introduzir uma sintaxe alternativa para a definição de tipos de dados
que parece um pouco mais similar a C. </p>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title" id="id583611">A enumeração</h4>
</div>
</div>
</div>
<p id="x_U4"><a name="x_U4"></a> Tipos de dado algébrica também servir
onde usaria um <code class="code">enum</code>
em C ou C + +, para representar um conjunto de valores simbólicos.
Esses tipos de dados algébricos são muitas vezes referidos como tipos
de enumeração. Aqui está um exemplo de C. </p>
<a name="types.c:roygbiv"></a>
<pre id="types.c:roygbiv" class="programlisting">enum vlavaiv {<br>    vermelho,<br>    laranja,<br>    amarelo,<br>    verde,<br>    azul,<br>    indigo,<br>    violeta,<br>};</pre>
<p id="x_EL"><a name="x_EL"></a> E aqui está um equivalente Haskell. </p>
<a name="Roygbiv.hs:Roygbiv"></a>
<pre id="Roygbiv.hs:Roygbiv" class="programlisting"><code class="codecomment">-- arquivo: ca03/Vlavaiv.hs</code><br>data Vlavaiv = Vermelho<br>             | Laranja<br>             | Amarelo<br>             | Verde<br>             | Azul<br>             | Indigo<br>             | Violeta<br>             deriving (Eq, Show)</pre>
<p id="x_wB1"><a name="x_wB1"></a> Podemos tentar estes no <span class="command"><strong>ghci</strong></span>. </p>
<a name="roygbiv.ghci:using"></a>
<pre id="roygbiv.ghci:using" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t Amarelo</code></strong><br>Amarelo :: Vlavaiv<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t Vermelho</code></strong><br>Vermelho :: Vlavaiv<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Vermelho == Amarelo</code></strong><br>False<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Verde == Verde</code></strong><br>True<br></pre>
<p id="x_df"><a name="x_df"></a> Em C, os elementos de um <code class="code">enum</code> são inteiros. Podemos usar um número inteiro
em um contexto onde um <code class="code">enum</code>
é esperado, e vice-versa: de um compilador C automaticamente converter
valores entre os dois tipos. Isto pode ser uma fonte de bugs. Em
Haskell, esse tipo de problema não ocorre. Por exemplo, nós não podemos
usar um valor <span class="type">Vlavaiv</span> onde um <code class="code">Int</code> é esperado. </p>
<a name="roygbiv.ghci:types"></a>
<pre id="roygbiv.ghci:types" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>take 3 "foobar"</code></strong><br>"foo"<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>take Vermelho "foobar"</code></strong><br><br>&lt;interactive&gt;:1:5:<br>    Couldn't match expected type `Int' against inferred type `Vlavaiv'<br>    In the first argument of `take', namely `Vermelho'<br>    In the expression: take Vermelho "foobar"<br>    In the definition of `it': it = take Vermelho "foobar"<br></pre>
</div>
<div class="sect3" lang="en">
<div class="titlepage">
<div>
<div>
<h4 class="title" id="id583781">A união discriminada</h4>
</div>
</div>
</div>
<p id="x_S4"><a name="x_S4"></a> Se um tipo de dados algébrico tem
várias alternativas, podemos pensar nele como semelhante a uma <code class="code">union</code>
em C ou C + +. A grande diferença entre os dois é que um sindicato não
nos diz qual a alternativa que está realmente presente, temos de forma
explícita e controlar manualmente qual a alternativa que estamos
usando, normalmente em outro campo de uma estrutura envolvente. Isto
significa que os sindicatos podem ser fontes de bugs, onde a nossa
noção de qual a alternativa que nós devemos usar está incorrecto. </p>
<a name="types.c:shape"></a>
<pre id="types.c:shape" class="programlisting">enum tipo_forma {<br>    forma_circulo,<br>    forma_poligono,<br>};<br><br>struct circulo {<br>    struct vetor centro;<br>    float raio;<br>};<br><br>struct poligono {<br>    size_t num_vertices;<br>    struct vetor *vertices;<br>};<br><br>struct forma <br>{<br>    enum tipo_forma tipo;<br>    union {<br>	struct circulo circulo;<br>	struct poligono poligono;<br>    } forma;<br>};</pre>
<p id="x_ef"><a name="x_ef"></a> No exemplo acima, a <code class="code">union</code>
pode conter dados válidos para qualquer um <code class="code">struct
circulo</code> ou um <code class="code">struct poligono</code>. Nós
temos que usar o <code class="code">enum shape_type</code> com a mão
para indicar que tipo de valor está armazenado na <code class="code">union</code>.
</p>
<p id="x_ff"><a name="x_ff"></a> A versão em Haskell deste código é
tanto drasticamente mais curta e mais segura do que o equivalente C. </p>
<a name="ShapeUnion.hs:Shape"></a>
<pre id="ShapeUnion.hs:Shape" class="programlisting"><code class="codecomment">-- arquivo: ca03/UnionForma.hs</code><br>type Vetor = (Double, Double)<br><br>data Forma = Circulo Vetor Double<br>           | Poligono [Vetor]</pre>
<p id="x_T4"><a name="x_T4"></a> Se criarmos um valor <span class="type">Forma</span> usando o construtor <code class="code">Circulo</code>,
o fato de que nós criamos um <code class="code">Circulo</code> é
armazenado. Quando mais tarde usar um <code class="code">Circulo</code>,
não podemos tratá-la acidentalmente, como um <code class="code">Quadrado</code>.
Vamos ver por que <a class="xref" href="defining-types-streamlining-functions.html#deftypes.pattern" title="Pattern matching">o “Casamento de padrões”</a>.</p>
<div class="tip">
<table summary="Tip: A few notes" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="support/figs/tip.png"></td>
      <th align="left">Algumas notas</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_V4"><a name="x_V4"></a> Da leitura dos capítulos
anteriores, que agora deve ficar claro que <span class="emphasis"><em>todos</em></span>
os tipos de dados que define a palavra-chave <code class="code">data</code>
são os tipos de dados algébricos. Alguns podem ter apenas uma
alternativa, enquanto outros têm vários, mas eles estão todos usando as
mesmas máquinas. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.pattern">Casamento
de padrões</h2>
</div>
</div>
</div>
<p id="x_Z5"><a name="x_Z5"></a>Agora que vimos como a construção de
valores com os tipos de dados
algébricos, vamos discutir como podemos trabalhar com esses valores. Se
tivermos um valor de algum tipo, há duas coisas que gostaria de ser
capaz de fazer. </p>
<div class="itemizedlist">
<ul type="disc">
  <li>
    <p id="x_gf"><a name="x_gf"></a>Se o tipo tem mais de um construtor
de valor, é preciso ser capaz de
dizer qual construtor de valor foi usado para criar o valor. </p>
  </li>
  <li>
    <p id="x_hf"><a name="x_hf"></a> Se o construtor de valor tem
componentes de dados, precisamos ser capazes de extrair esses valores. </p>
  </li>
</ul>
</div>
<p id="x_if"><a name="x_if"></a> Haskell tem um recurso simples, mas
extremament útil, que é o <span class="emphasis"><em>casamento de
padrões</em></span>, que nos permite fazer essas duas coisas. </p>
<p id="x_a5"><a name="x_a5"></a>Um padrão nos permite olhar para dentro
de um valor e variáveis de
vinculação com os dados que ele contém. Aqui está um exemplo de
combinação de padrões em ação em um valor <span class="type">Bool</span>:
vamos reproduzir a função <code class="function">not</code>. </p>
<a name="add.hs:myNot"></a>
<pre id="add.hs:myNot" class="programlisting"><code class="codecomment">-- arquivo: ca03/soma.hs</code><br>meuNot True  = False<br>meuNot False = True</pre>
<p id="x_e5"><a name="x_e5"></a> Pode parecer que temos duas funções
chamado <code class="function">meuNot</code> aqui, mas Haskell nos
permite definir uma função como uma <span class="emphasis"><em>série
de equações</em></span>:
estes dois são cláusulas que definem o comportamento da mesma função
para diferentes padrões de entrada. Em cada linha, os padrões são os
itens a seguir ao nome da função, até o símbolo <code class="code">=</code>.
</p>
<p id="x_jf"><a name="x_jf"></a> Para entender como funciona o
casamento de padrões, vamos percorrer um exemplo, digamos <code class="code">meuNot False</code>. </p>
<p id="x_kf"><a name="x_kf"></a> Quando aplicamos <code class="function">meuNot</code>,
o runtime Haskell verifica o valor que fornecemos contra o construtor
de valor no primeiro padrão. Isto não corresponde, por isso tenta
contra o segundo padrão. Essa correspondência é bem sucedida, por isso
usa o lado direito da equação, como resultado da aplicação da função. </p>
<p id="x_xB1"><a name="x_xB1"></a> Aqui está um exemplo um pouco mais
prolongado. Essa função adiciona os elementos de uma lista. </p>
<a name="add.hs:sumList"></a>
<pre id="add.hs:sumList" class="programlisting"><code class="codecomment">-- arquivo: ca03/soma.hs</code><br>somaLista (x:xs) = x + somaLista xs<br>somaLista []     = 0</pre>
<p id="x_yB1"><a name="x_yB1"></a> Vamos passo a passo através da
avaliação de <code class="code">somaLista [1,2]</code>. A notação de
lista <code class="code">[1,2]</code> é uma abreviação para a
expressão <code class="code">(1:(2:[]))</code>. Começamos por tentar
compatibilizar o padrão da primeira equação da definição de <code class="code">somaLista</code>. No padrão <code class="code">(x:xs)</code>,
o “<span class="quote"><code class="code">:</code></span>” é o
construtor da lista familiar, <code class="function">(:)</code>.
Estamos agora a usá-lo para casar contra um valor, não para construir
um . O valor <code class="code">(1:(2:[]))</code> foi construído com <code class="code">(:)</code>,então o construtor do valor corresponde ao
construtor no padrão. Dizemos que o padrão <span class="emphasis"><em>casou</em></span>,
ou que o casamento foi <span class="emphasis"><em>bem-sucedido</em></span>.
</p>
<p id="x_zB1"><a name="x_zB1"></a> As variáveis <code class="varname">x</code>
e <code class="varname">xs</code> agora são <span class="quote"></span>vinculada
pelo construtor de argumentos, então a <code class="varname">x</code>
é atribuído o valor <code class="code">1</code>, e a <code class="code">xs</code> o valor <code class="code">2:[]</code>. </p>
<p id="x_lf"><a name="x_lf"></a> A expressão que estamos avaliando
agora é <code class="code">1 + somaLista (2:[])</code>. Devemos agora
aplicar recursivamente <code class="function">somaLista</code> para o
valor <code class="code">2:[]</code>. Mais uma vez, este foi
construído utilizando <code class="code">(:)</code>, assim o casamento
foi bem-sucedido. Em nossa aplicação recursiva de <code class="function">somaLista</code>, <code class="varname">x</code> é
agora ligado a <code class="code">2</code>, e <code class="varname">xs</code>
para <code class="code">[]</code>. </p>
<p id="x_d5"><a name="x_d5"></a> Estamos avaliando agora <code class="code">1 + (2 + somaLista [])</code>. Nesta aplicação recursiva
de <code class="function">somaLista</code>, o valor que estamos
buscando para casar <code class="code">[]</code>. O valor do
construtor não coincide com o construtor do primeiro padrão, então
vamos pular essa equação. Em vez disso “<span class="quote">caimos</span>”
para o padrão seguinte, que corresponde. O lado direito desta equação
é, portanto, escolhido como o resultado dessa aplicação. </p>
<p id="x_mf"><a name="x_mf"></a> O resultado da <code class="code">somaLista
[1,2]</code> é, portanto <code class="code">1 + (2 + (0))</code>, ou <code class="code">3</code>. </p>
<div class="note">
<table summary="Note: Ordering is important" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">A ordenação é importante</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_m5"><a name="x_m5"></a>Como já mencionado, a
implementação Haskell checa o padrão para casar
na&nbsp; mesma ordem em que especificá-mos em nossas funções.
Procedimento de "casamento" é de cima para baixo, e termina no primeiro
sucesso. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_nf"><a name="x_nf"></a> Como nota final, já existe uma função
padrão chamada <code class="function">sum</code>, que realiza esta
soma de lista para nós. Nossa <code class="function">somaLista</code>
é meramente ilustrativa. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id584277">Construção e deconstrução</h3>
</div>
</div>
</div>
<p id="x_of"><a name="x_of"></a> Damos um passo a trás e daremos uma
olhada na relação entre a construção de um valor e o seu casamento de
padrão. </p>
<p id="x_pf"><a name="x_pf"></a> Nós aplicamos um construtor de valor
para construir um valor. A expressão <code class="code">Livro 9 "Close
Calls" ["John Long"]</code> aplica-se o construtor <code class="function">Livro</code> para os valores <code class="code">9</code>,
<code class="code">"Close Calls"</code> e <code class="code">["John
Long"]</code> para produzir um novo valor do tipo <span class="type">InfoLivro</span>.
</p>
<p id="x_qf"><a name="x_qf"></a> Quando casamos o padrão sobre o
construtor <code class="function">Livro</code>, nós <span class="emphasis"><em>invertemos</em></span>
o processo de construção. Primeiro de tudo, verificamos se o valor foi
criado usando aquele construtor. Se for, nós inspecioná-lo para obter
os valores individuais que foi originalmente fornecido para o
construtor,
quando criamos o valor. </p>
<p id="x_rf"><a name="x_rf"></a> Vamos considerar o que acontece se o
casamento de padrão <code class="code">(Livro id nome autores)</code>
sobre a nossa expressão do exemplo. </p>
<div class="itemizedlist">
<ul type="disc">
  <li>
    <p id="x_sf"><a name="x_sf"></a> O casamento terá êxito, porque o
construtor no valor corresponde a um do nosso padrão. </p>
  </li>
  <li>
    <p id="x_tf"><a name="x_tf"></a> A variável <code class="varname">id</code>
será vinculada a <code class="code">9</code>. </p>
  </li>
  <li>
    <p id="x_uf"><a name="x_uf"></a> A variável <code class="varname">nome</code>
será vinculada a <code class="code">"Close Calls"</code>. </p>
  </li>
  <li>
    <p id="x_vf"><a name="x_vf"></a> A variável <code class="varname">autores</code>
será vinculada a <code class="code">["John Long"]</code>. </p>
  </li>
</ul>
</div>
<p id="x_wf"><a name="x_wf"></a> Como o padrão combina age como o
inverso da construção, é por vezes referido como <span class="emphasis"><em>de</em></span>construção.
</p>
<div class="note">
<table summary="Note: Deconstruction doesn't destroy anything" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">A desconstrução não destrói nada</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_xf"><a name="x_xf"></a>Se você está mergulhada em
programação orientada a objeto jargão, não
confunda a desconstrução com destruição! Correspondência de um
padrão não tem nenhum efeito sobre o valor que estamos examinando: só
nos permite “<span class="quote">olhar para dentro</span>” dele. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id584453">Outras aventuras</h3>
</div>
</div>
</div>
<p id="x_f5"><a name="x_f5"></a>A sintaxe de casamento de padrões em
uma tupla é similar à
sintaxe para a construção de uma tupla. Aqui está uma função que
retorna o último elemento de uma 3-tuplo. </p>
<a name="Tuple.hs:third"></a>
<pre id="Tuple.hs:third" class="programlisting"><code class="codecomment">-- arquivo: ca03/Tuplo.hs</code><br>terceiro (a, b, c) = c</pre>
<p id="x_g5"><a name="x_g5"></a> Não há limite para o tão “<span class="quote">profundo</span>”
dentro de um valor padrão podemos olhar. Esta definição olha tanto
dentro de uma tupla quanto dentro de uma lista em uma tupla. </p>
<a name="Tuple.hs:complicated"></a>
<pre id="Tuple.hs:complicated" class="programlisting"><code class="codecomment">-- arquivo: ca03/Tuplo.hs</code><br>complicado (True, a, x:xs, 5) = (a, xs)</pre>
<p id="x_h5"><a name="x_h5"></a> Podemos tentar fazer isso de forma
interativa. </p>
<a name="tuple.ghci:complicated"></a>
<pre id="tuple.ghci:complicated" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:l Tuplo.hs</code></strong><br>[1 of 1] Compiling Main             ( Tuplo.hs, interpreted )<br>Ok, modules loaded: Main.<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>complicado (True, 1, [1,2,3], 5)</code></strong><br>(1,[2,3])<br></pre>
<p id="x_i5"><a name="x_i5"></a> Sempre que um valor literal está
presente em um padrão (<code class="literal">True</code> e <code class="literal">5</code>
do padrão da tupla acima), esse valor tem de corresponder exatamente ao
padrão para ter sucesso. Se o padrão dentro de uma série
de equações não corresponde ao valor de entrada, temos então um erro de
execução. </p>
<a name="tuple.ghci:nomatch"></a>
<pre id="tuple.ghci:nomatch" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>complicado (False, 1, [1,2,3], 5)</code></strong><br>*** Exception: Tuplo.hs:10:0-39: Non-exhaustive patterns in function complicated<br><br></pre>
<p id="x_yf"><a name="x_yf"></a> Para uma explicação sobre essa
mensagem de erro, avance um pouco, para <a class="xref" href="defining-types-streamlining-functions.html#deftypes.patterns.nonexhaustive" title="Exhaustive patterns and wild cards"> a seção chamada “Padrões
exaustivos e curingas”</a>. </p>
<p id="x_j5"><a name="x_j5"></a> Nós podemos casar padrões em um tipo
de dados algébrico usando o valor seus construtores. Lembrando-se do
tipo <span class="type">InfoLivro</span> definido anteriormente:
podemos extrair os valores de um <span class="type">InfoLivro</span>
como se segue. </p>
<a name="BookStore.hs:accessors"></a>
<pre id="BookStore.hs:accessors" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>idLivro      (Livro id título autores) = id<br>títuloLivro  (Livro id título autores) = título<br>autoresLivro (Livro id título autores) = autores</pre>
<p id="x_k5"><a name="x_k5"></a> Vamos vê-lo em ação. </p>
<a name="bookstore.ghci:unwrap"></a>
<pre id="bookstore.ghci:unwrap" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>idLivro (Livro 3 "Probability Theory" ["E.T.H. Jaynes"])</code></strong><br>3<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>títuloLivro (Livro 3 "Probability Theory" ["E.T.H. Jaynes"])</code></strong><br>"Probability Theory"<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>autoresLivro (Livro 3 "Probability Theory" ["E.T.H. Jaynes"])</code></strong><br>["E.T.H. Jaynes"]<br></pre>
<p id="x_l5"><a name="x_l5"></a> O compilador pode inferir os tipos de
funções de acesso baseado no construtor que estamos usando no nosso
padrão. </p>
<a name="bookstore.ghci:unwrap.types"></a>
<pre id="bookstore.ghci:unwrap.types" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t idLivro</code></strong><br>idLivro :: InfoLivro -&gt; Int<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t títuloLivro</code></strong><br>títuloLivro :: InfoLivro -&gt; String<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t autoresLivro</code></strong><br>autoresLivro :: InfoLivro -&gt; [String]<br></pre>
<p id="x_IL"><a name="x_IL"></a> Se usarmos um valor literal em
um padrão, a parte correspondente ao valor que estamos combinando
deverá conter um valor idêntico. Por exemplo, o padrão <code class="code">(3:xs)</code> antes de mais nada é verificado se um valor
é uma lista não vazia, casando com o construtor <code class="function">(:)</code>.
Ele também garante que a cabeça da lista tem o valor exato <code class="literal">3</code>. Se ambas as condições obtivere exitos, a
cauda da lista encontra-se vinculada à variável <code class="varname">xs</code>.
</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id584746">Nomenclatura de variáveis em padrões</h3>
</div>
</div>
</div>
<p id="x_zf"><a name="x_zf"></a> A media que você lê funções que fazem
casamento de lista, você vai encontrar
muitas vezes que os nomes das variáveis dentro de um padrão é&nbsp;
semelhante a <code class="code">(x:xs)</code> ou <code class="code">(d:ds)</code>.
Trata-se de uma convenção de nomenclatura popular. A idéia é que o nome
do <code class="varname">xs</code> tem um “<span class="quote"><code class="code">s</code></span>” no final de seu nome como se fosse o “<span class="quote">plural</span>” de <code class="varname">x</code>,
porque <code class="varname">x</code> contém a cabeça da lista, e <code class="varname">xs</code> os elementos restantes. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.wildcard">O padrão curinga</h3>
</div>
</div>
</div>
<p id="x_o5"><a name="x_o5"></a> Podemos indicar que não importa o que
está presente em parte de um padrão. A notação para isto é o caractere
sublinhado “<span class="quote"><code class="code">_</code></span>”,
que chamamos de um <span class="emphasis"><em>curinga</em></span> ou <span class="emphasis"><em>wild card</em></span>. Vamos utilizá-lo como se
segue. </p>
<a name="BookStore.hs:niceAccessors"></a>
<pre id="BookStore.hs:niceAccessors" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>idAgradável      (Livro id _      _      ) = id<br>títuloAgradável  (Livro _  título _      ) = título<br>autoresAgradável (Livro _  _      autores) = autores</pre>
<p id="x_p5"><a name="x_p5"></a>Aqui, temos versões limpas das funções
de assessor apresentada
anteriormente. Agora, não há dúvida sobre qual o elemento que estamos
usando em cada função. </p>
<p id="x_KL"><a name="x_KL"></a> Em um padrão, o curinga
funciona de maneira similar a uma variável, mas não é vinculada a uma
nova
variável. Como nos exemplos acima, podemos usar mais de um wild
card em um único padrão. </p>
<p id="x_LL"><a name="x_LL"></a> Outra vantagem do padrão curinga é que
um compilador Haskell pode nos avisar se nós introduzimos um
nome de variável em um padrão, mas não usamos-as no corpo de uma
função. Definindo uma variável, mas esquecendo-se de usá-lo, muitas
vezes pode
indicar a presença de um erro, por isso este é um recurso útil. Se
usarmos um wild card, em vez de uma variável que não temos a intenção
de usar, o compilador não vai reclamar. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.patterns.nonexhaustive">Padrões
exaustivos e curingas</h3>
</div>
</div>
</div>
<p id="x_Ag"><a name="x_Ag"></a>Ao escrever uma série de padrões, é
importante cobrir todos os
construtores de um tipo. Por exemplo, se nós estamos inspecionando uma
lista, devemos ter uma equação que coincide com o construtor não-vazio <code class="function">(:)</code>, e que coincide com o construtor lista
vazia <code class="function">[]</code>. </p>
<p id="x_Bg"><a name="x_Bg"></a>Vamos ver o que acontece se não
conseguimos cobrir todos os casos.
Aqui, nós deliberadamente omitimos a&nbsp; verificação para o
construtor <code class="function">[]</code>. </p>
<a name="BadPattern.hs:badExample"></a>
<pre id="BadPattern.hs:badExample" class="programlisting"><code class="codecomment">-- arquivo: ca03/PadrãoMau.hs</code><br>exemploMau (x:xs) = x + exemploMau xs</pre>
<p id="x_Cg"><a name="x_Cg"></a>Se aplicarmos isso a um valor que não
pode corresponder, vamos receber
um erro em tempo de execução: o nosso software tem um bug! </p>
<a name="badpattern.ghci:error"></a>
<pre id="badpattern.ghci:error" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>exemploMau []</code></strong><br>*** Exception: PadrãoMau.hs:4:0-36: Non-exhaustive patterns in function badExample<br><br></pre>
<p id="x_Dg"><a name="x_Dg"></a> Neste exemplo, nenhuma equação na
definição da função coincide com o valor <code class="code">[]</code>.
</p>
<div class="tip">
<table summary="Tip: Warning about incomplete patterns" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="support/figs/tip.png"></td>
      <th align="left">Aviso sobre padrões incompletos</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_Eg"><a name="x_Eg"></a> <span class="application">GHC</span>
oferece uma opção de compilação útil <code class="option">-fwarn-incomplete-patterns</code>,
que fará com que ele imprime um aviso durante a compilação se uma
seqüência de padrões não correspondem a todos tipo de valor de um
construtor. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_Fg"><a name="x_Fg"></a>Se nós precisamos de fornecer um
comportamento padrão nos casos em que
não se preocupam com os construtores específicos, podemos utilizar um
padrão curinga. </p>
<a name="BadPattern.hs:goodExample"></a>
<pre id="BadPattern.hs:goodExample" class="programlisting"><code class="codecomment">-- arquivo: ca03/PadrãoMau.hs</code><br>exemploBom (x:xs) = x + exemploBom xs<br>exemploBom _      = 0</pre>
<p id="x_Gg"><a name="x_Gg"></a> A curinga acima irá coincidir com o
construtor <code class="code">[]</code>, para a aplicação dessa função
não conduzir a um erro. </p>
<a name="badpattern.ghci:ok"></a>
<pre id="badpattern.ghci:ok" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>exemploBom []</code></strong><br>0<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>exemploBom [1,2]</code></strong><br>3<br></pre>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.record">Sintaxe de
registro</h2>
</div>
</div>
</div>
<p id="x_Hg"><a name="x_Hg"></a> Escrevendo funções de acesso para cada
componentes de um tipo de dado pode ser repetitivo e enfadonho. </p>
<pre id="id585051" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>idAgradável      (Livro id _      _      ) = id<br>títuloAgradável  (Livro _  título _      ) = título<br>autoresAgradável (Livro _  _      autores) = autores</pre>
<p id="x_Ig"><a name="x_Ig"></a> Chamamos esse tipo de código <span class="emphasis"><em>boilerplate (clichê)</em></span>:
necessário, mas volumoso e cansativo. Haskell programadores não gostam
de clichês. Felizmente, a linguagem resolve este problema particular:
Podemos definir um tipo de dados, e assessores para cada um dos
seus componentes, ao mesmo tempo. (As posições das vírgulas é uma
questão de preferência. Se você gostar, coloque-os no final de uma
linha, em vez do começo.) </p>
<a name="BookStore.hs:Customer"></a>
<pre id="BookStore.hs:Customer" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>data Cliente = Cliente { idCliente:: IDCliente<br>                       , nomeCliente:: String<br>                       , endereçoCliente:: Endereço<br>                       } deriving Show</pre>
<p id="x_Jg"><a name="x_Jg"></a> Isso é quase exatamente idêntico em
significado a seguinte forma mais familiar. </p>
<a name="AltCustomer.hs:Customer"></a>
<pre id="AltCustomer.hs:Customer" class="programlisting"><code class="codecomment">-- arquivo: ca03/ClienteAlt.hs</code><br>data Cliente = Cliente Int String [String]<br>             deriving Show<br><br>idCliente:: Cliente-&gt; Int<br>idCliente (Cliente id _ _) = id<br><br>nomeCliente:: Cliente-&gt; String<br>nomeCliente (Cliente _ nome _) = nome<br><br>endereçoCliente:: Cliente-&gt; [String]<br>endereçoCliente (Cliente _ _ endereço) = endereço</pre>
<p id="x_Kg"><a name="x_Kg"></a> Para cada um dos campos que nós
nomeamos, na nossa definição de tipo, Haskell cria uma função de
assessor com esse nome. </p>
<a name="bookstore.ghci:accessor.type"></a>
<pre id="bookstore.ghci:accessor.type" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t idCliente</code></strong><br>idCliente :: Cliente -&gt; IDCliente<br></pre>
<p id="x_Lg"><a name="x_Lg"></a> Podemos ainda usar a aplicação da
sintaxe usual para criar um valor deste tipo. </p>
<a name="BookStore.hs:customer1"></a>
<pre id="BookStore.hs:customer1" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>cliente1 = Cliente 271828 "J.R. Hacker"<br>           ["255 Syntax Ct",<br>            "Milpitas, CA 95134",<br>            "USA"]</pre>
<p id="x_Mg"><a name="x_Mg"></a>A sintaxe de registor adiciona uma
notação mais detalhada para a criação de
um valor. Isto às vezes pode tornar o código mais legível. </p>
<a name="BookStore.hs:customer2"></a>
<pre id="BookStore.hs:customer2" class="programlisting"><code class="codecomment">-- arquivo: ca03/Livraria.hs</code><br>cliente2 = Cliente { idCliente= 271828<br>                   , endereçoCliente= ["1048576 Disk Drive",<br>                                       "Milpitas, CA 95134",<br>                                       "USA"]<br>                   , nomeCliente= "Jane Q. Citizen" }</pre>
<p id="x_AC1"><a name="x_AC1"></a>Se usarmos esta forma, podemos variar
a ordem em que&nbsp; nós listamos
os campos. Aqui, temos movido o nome e os campos de endereço das suas
posições na declaração do tipo. </p>
<p id="x_Ng"><a name="x_Ng"></a> Quando definimos um tipo utilizando a
sintaxe registro, ele também muda a forma como o tipo de valores são
impressos. </p>
<a name="bookstore.ghci:customer1"></a>
<pre id="bookstore.ghci:customer1" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>cliente1</code></strong><br>Cliente {idCliente = 271828, nomeCliente = "J.R. Hacker", endereçoCliente = ["255 Syntax Ct","Milpitas, CA 95134","USA"]}<br></pre>
<p id="x_Og"><a name="x_Og"></a> Para efeito de comparação, vamos olhar
para um valor <span class="type">InfoLivro</span>; que definimos sem a
sintaxe de registro. </p>
<a name="bookstore.ghci:cities"></a>
<pre id="bookstore.ghci:cities" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>livro</code></strong><br>Livro 173 "Use of Weapons" ["Iain M. Banks"]<br></pre>
<p id="x_Pg"><a name="x_Pg"></a> As funções de acesso que recebemos “<span class="quote">de graça</span>” quando usamos a sintaxe registro
realmente são funções normais Haskell. </p>
<a name="bookstore.ghci:accessor"></a>
<pre id="bookstore.ghci:accessor" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t nomeCliente</code></strong><br>nomeCliente :: Cliente -&gt; String<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>nomeCliente cliente1</code></strong><br>"J.R. Hacker"<br></pre>
<p id="x_Bn"><a name="x_Bn"></a> A módulo padrão <code class="literal">System.Time</code>
faz bom uso da sintaxe de registro. Aqui está um tipo definido nesse
módulo: </p>
<pre id="id585295" class="programlisting">data CalendarTime = CalendarTime { ctYear:: Int,<br>                                 , ctMonth:: Month,<br>                                 , ctDay, ctHour, ctMin, ctSec:: Int,<br>                                 , ctPicosec:: Integer,<br>                                 , ctWDay:: Day,<br>                                 , ctYDay:: Int,<br>                                 , ctTZName:: String,<br>                                 , ctTZ:: Int,<br>                                 , ctIsDST:: Bool }<br>    </pre>
<p id="x_Cn"><a name="x_Cn"></a>Na ausência de registro de sintaxe,
seria doloroso extrair campos
específicos de um tipo como este. A notação torna mais fácil trabalhar
com grandes estruturas. </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.paramtypes">Tipos
parametrizados</h2>
</div>
</div>
</div>
<p id="x_Z4"><a name="x_Z4"></a>Nós temos repetidamente dito que o tipo
de lista é polimórfico: os
elementos de uma lista pode ser de qualquer tipo. Podemos acrescentar
ao nosso polimorfismo tipos próprios. Para fazer isso, introduzimos
variáveis de tipo em uma declaração de tipo. O Prelude define um tipo
chamado <span class="type">Maybe</span>:
nós podemos usar-lo para representar um valor que poderia estar
presente ou ausente, por exemplo, um campo em uma linha do banco de
dados que podem ser nulos. </p>
<a name="Nullable.hs:Nullable"></a>
<pre id="Nullable.hs:Nullable" class="programlisting"><code class="codecomment">-- arquivo: ca03/Nulable.hs</code><br>data Maybe a = Just a<br>             | Nothing</pre>
<p id="x_a4"><a name="x_a4"></a> Aqui, a variável <code class="varname">a</code>
não é uma variável regular: é uma variável de tipo. Ela indica que o
tipo <span class="type">Maybe</span> tem outro tipo como seu
parâmetro. Isso permite-nos usar <span class="type">Maybe</span> em
valores de qualquer tipo. </p>
<a name="Nullable.hs:wrappedTypes"></a>
<pre id="Nullable.hs:wrappedTypes" class="programlisting"><code class="codecomment">-- arquivo: ca03/Nulable.hs</code><br>umBool= Just True<br><br>umString= Just "algo"</pre>
<p id="x_b4"><a name="x_b4"></a> Como de costume, podemos experimentar
este tipo com o <span class="command"><strong>ghci</strong></span>. </p>
<a name="nullable.ghci:experiment"></a>
<pre id="nullable.ghci:experiment" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Just 1.5</code></strong><br>Just 1.5<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Nothing</code></strong><br>Nothing<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t Just "bicicleta invisível"</code></strong><br>Just "bicicleta invisível" :: Maybe [Char]<br></pre>
<p id="x_c4"><a name="x_c4"></a><span class="type"> Maybe</span> é do
tipo polimórfico, ou genérico. Nós damos ao construtor de tipo <span class="type">Maybe</span> um parâmetro para criar um tipo específico,
como <span class="type">Maybe Int</span> ou <span class="type">Maybe
[Bool]</span>. Como seria de esperar, estes tipos são distintos. </p>
<p id="x_e4"><a name="x_e4"></a>Podemos usar tipos parametrizados um
dentro do outra, mas
quando o fizermos, pode ser necessário usar parênteses para dizer ao
compilador Haskell como analisar a nossa expressão. </p>
<a name="Nullable.hs:parens"></a>
<pre id="Nullable.hs:parens" class="programlisting"><code class="codecomment">-- arquivo: ca03/Nulable.hs</code><br>embrulhado = Just (Just "embrulhado")</pre>
<p id="x_d4"><a name="x_d4"></a>Para prorrogar mais uma vez uma
analogia com linguagens mais comuns,
tipos parametrizados tem algumas semelhanças com templates em C++, e
generics em Java. Esteja ciente de que esta é uma analogia superficial.
Templates e generics foram adicionados às suas respectivas linguagems
tempo depois que as linguagems foram inicialmente definidas, e tem uma
aspecto desajeitado. Tipos parametrizada do Haskell são mais simples e
fácil de usar, como a linguagem foi projetada com eles desde o início. </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.recursive">Tipos
recursivos</h2>
</div>
</div>
</div>
<p id="x_Rg"><a name="x_Rg"></a> O tipo familiar lista é <span class="emphasis"><em>recursivo</em></span>: ele é definido em termos
de si mesmo. Para entender isso, vamos criar o nosso próprio tipo
lista. Usaremos <code class="code">Cons</code> no lugar do construtor <code class="function">(:)</code> e <code class="code">Nulo</code> no lugar
de <code class="code">[]</code>. </p>
<a name="ListADT.hs:List"></a>
<pre id="ListADT.hs:List" class="programlisting"><code class="codecomment">-- arquivo: ca03/TADLista.hs</code><br>data Lista a = Cons a (Lista a)<br>             | Nulo<br>             deriving Show</pre>
<p id="x_Sg"><a name="x_Sg"></a> Como <span class="type">Lista a</span>
aparece à esquerda e à direita do simbolo <code class="code">=</code>,
a definição do tipo se refere a si mesma. Se quisermos usar o
construtor <code class="code">Cons</code> para criar um novo
valor,&nbsp; devemos fornecer um valor do tipo <code class="varname">a</code>,
e outro do tipo <code class="varname">Lista a</code>. Vamos ver onde
isso nos leva, na prática. </p>
<p id="x_Tg"><a name="x_Tg"></a> O valor mais simples de um tipo de <span class="type">Lista a</span> que podemos criar é <code class="code">Nulo</code>.
Salve a definição do tipo em um arquivo, e em seguida, carregue-o no <span class="command"><strong>ghci</strong></span>. </p>
<a name="listadt.ghci:empty"></a>
<pre id="listadt.ghci:empty" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Nulo</code></strong><br>Nulo<br></pre>
<p id="x_Ug"><a name="x_Ug"></a> Porque <code class="code">Nulo</code>
tem um tipo <span class="type">Lista a</span> , podemos utilizá-lo
como um parâmetro para <code class="code">Cons</code>. </p>
<a name="listadt.ghci:tiny"></a>
<pre id="listadt.ghci:tiny" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Cons 0 Nulo</code></strong><br>Cons 0 Nulo<br></pre>
<p id="x_Vg"><a name="x_Vg"></a> E porque <code class="code">Cons 0
Nulo</code> tem o tipo <span class="type">Lista a</span>, nós podemos
usar isso como um parâmetro para <code class="code">Cons</code>. </p>
<a name="listadt.ghci:two"></a>
<pre id="listadt.ghci:two" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Cons 1 it</code></strong><br>Cons 1 (Cons 0 Nulo)<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Cons 2 it</code></strong><br>Cons 2 (Cons 1 (Cons 0 Nulo))<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Cons 3 it</code></strong><br>Cons 3 (Cons 2 (Cons 1 (Cons 0 Nulo)))<br></pre>
<p id="x_Wg"><a name="x_Wg"></a> Poderíamos continuar dessa maneira
indefinidamente, criando cada vez mais cadeias <code class="code">Cons</code>,
cada uma com um único <code class="code">Nulo</code> no final. </p>
<div class="tip">
<table summary="Tip: Is List an acceptable list?" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="support/figs/tip.png"></td>
      <th align="left">É Lista uma lista aceitável?</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_Xg"><a name="x_Xg"></a> Nós podemos facilmente provar a
nós mesmos que o nosso tipo <span class="type">List a</span> tem a
mesma forma que o tipo lista <span class="type">[a]</span> existente
no ghc. Para fazer isso, nós escrevemos uma função que recebe um valor
do tipo <span class="type">[a]</span>, e produzimos um valor de um
tipo <span class="type">Lista a</span>. </p>
      <a name="ListADT.hs:fromList"></a>
      <pre id="ListADT.hs:fromList" class="programlisting"><code class="codecomment">-- arquivo: ca03/TADLista.hs</code><br>doList (x:xs) = Cons x (doList xs)<br>doList []     = Nulo</pre>
      <p id="x_Yg"><a name="x_Yg"></a> Por inspeção, é evidente que
substituimos uma <code class="code">Cons</code> para cada <code class="function">(:)</code>, e um <code class="code">Nil</code> para
cada <code class="code">[]</code>. Isto abrange ambas as built-in do
tipo lista de construtores. Os dois tipos são <span class="emphasis"><em>isomorfos</em></span>;
pois eles têm a mesma forma. </p>
      <a name="listadt.ghci:fromList"></a>
      <pre id="listadt.ghci:fromList" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>doList "durian"</code></strong><br>Cons 'd' (Cons 'u' (Cons 'r' (Cons 'i' (Cons 'a' (Cons 'n' Nulo)))))<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>doList [Just True, Nothing, Just False]</code></strong><br>Cons (Just True) (Cons Nothing (Cons (Just False) Nulo))<br>      </pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_K5"><a name="x_K5"></a> Para um terceiro exemplo de que é um
tipo recursivo, aqui está uma definição do tipo de árvore binária. </p>
<a name="Tree.hs:Tree"></a>
<pre id="Tree.hs:Tree" class="programlisting"><code class="codecomment">-- arquivo: ca03/Árvore.hs</code><br>data Arvore a = Nodo a (Arvore a) (Arvore a)<br>              | Vazia<br>              deriving Show</pre>
<p id="x_BC1"><a name="x_BC1"></a> Uma árvore binária ou é um nó com
dois filhos, que são tambem árvores binárias, ou um valor vazio. </p>
<p id="x_Zg"><a name="x_Zg"></a>Desta vez, vamos comparar com uma
definição em uma linguagem mais familiar. Aqui está uma definição de
classe
similares em Java. </p>
<a name="Tree.java:Tree"></a>
<pre id="Tree.java:Tree" class="programlisting">class Árvore&lt;A&gt;<br>{<br>    A valor;<br>    Árvore&lt;A&gt; esquerda;<br>    Árvore&lt;A&gt; direita;<br><br>    public Árvore(A v, Árvore&lt;A&gt; l, Árvore&lt;A&gt; r)<br>    {<br>	valor = v;<br>	esquerda = l;<br>	direita = r;<br>    }<br>}</pre>
<p id="x_ag"><a name="x_ag"></a> A única diferença significativa é que
o Java nos permite usar o valor especial <code class="code">null</code>
para indicar qualquer lugar “<span class="quote">nada</span>”, então
podemos usar <code class="code">null</code>
para indicar que um nó está faltando um filho a direita ou à
esquerda. Aqui está uma pequena função que constrói uma árvore com duas
folhas (uma folha, por convenção, não tem filhos). </p>
<a name="Tree.java:Example"></a>
<pre id="Tree.java:Example" class="programlisting">class Exemplo<br>{<br>    static Árvore&lt;String&gt; arvoreSimples()<br>    {<br>	return new Árvore&lt;String&gt;(<br>            "raiz",<br>	    new Árvore&lt;String&gt;("filho esquerdo", null, null),<br>	    new Árvore&lt;String&gt;("filho direito", null, null));<br>    }<br>}</pre>
<p id="x_bg"><a name="x_bg"></a> Em Haskell, não temos um equivalente
ao <code class="code">null</code>. Nós poderíamos usar o tipo <span class="type">Maybe</span>
para fornecer um efeito similar, mas o que incharia o casamento de
padrão. Ao invés disso, nós decidimos usar um construtor sem argumento <code class="code">Vazio</code>. Onde o exemplo Java usamos <code class="code">null</code> para o construtor de <span class="type">Arvore</span>,
nós usamos o <code class="code">Vazio</code> em Haskell. </p>
<a name="Tree.hs:simpleTree"></a>
<pre id="Tree.hs:simpleTree" class="programlisting"><code class="codecomment">-- arquivo: ca03/Árvore.hs</code><br>arvoreSimples= Árvore "raiz" (Nó "filha" Vazio Vazio)<br>                             (Nó "filho" Vazio Vazio)</pre>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id585938">Exercícios</h3>
</div>
</div>
</div>
<div class="qandaset">
<table summary="Q and A Set" border="0">
  <col align="left" width="1%"><tbody>
    <tr class="question">
      <td align="left" valign="top"><a name="id585948"></a><a name="id585950"></a>
      <p> <b>1.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_cg"><a name="x_cg"></a> Escreva o inverso do <code class="function">doList</code> para o tipo de <span class="type">Lista</span>:
uma função que recebe uma <span class="type">Lista a</span> e gere um <span class="type">[a]</span>. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id585978"></a><a name="id585980"></a>
      <p> <b>2.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_dg"><a name="x_dg"></a>Definir um tipo de árvore que tem
somente um construtor, como o nosso exemplo Java. Em vez do construtor <code class="code">Vazio</code>, use o tipo <span class="type">Maybe</span>
para se referir a um nó de filhos. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.error">Relatando
erros</h2>
</div>
</div>
</div>
<p id="x_w3"><a name="x_w3"></a> Haskell oferece uma função padrão <code class="function">error:: String-&gt; a</code>,
que podemos chamar quando algo saiu terrivelmente errado no nosso
código. Damos-lhe um parâmetro string, que é a mensagem de erro para
mostrar. Sua assinatura de tipo parece peculiar: como pode produzir um
valor de qualquer tipo de <code class="varname">a</code> dado somente
uma cadeia de caracteres ? </p>
<p id="x_x3"><a name="x_x3"></a> Ela tem um resultado do tipo <code class="varname">a</code>
modo que podemos chamá-lo em qualquer lugar e sempre terá o tipo certo.
No entanto, ele não retorna um valor como uma função normal: em vez
disso, ele <span class="emphasis"><em>aborta avaliação imediatamente</em></span>,
e imprime a mensagem de erro que lhe damos. </p>
<p id="x_eg"><a name="x_eg"></a> A função <code class="function">meuSegundo</code>
retorna o segundo elemento da sua lista de entrada, mas ela falha caso
a sua lista de entrada não é tiver o tamanho suficiente. </p>
<a name="MySecond.hs:mySecond"></a>
<pre id="MySecond.hs:mySecond" class="programlisting"><code class="codecomment">-- arquivo: ca03/SegundoMeu.hs</code><br><code class="function">meuSegundo</code>:: [a]-&gt; a<br><br><code class="function">meuSegundo</code> xs = if null (tail xs)<br>                then error "lista curta demais"<br>                else head (tail xs)</pre>
<p id="x_y3"><a name="x_y3"></a> Como de costume, nós podemos ver como
isso funciona na prática <span class="command"><strong>ghci</strong></span>.
</p>
<a name="error.ghci:mySecond"></a>
<pre id="error.ghci:mySecond" class="screen"><code class="prompt">ghci&gt; </code><code style="font-weight: bold;" class="function">meuSegundo</code><strong class="userinput"><code> "xi"</code></strong><br>'i'<br><code class="prompt">ghci&gt; </code><code style="font-weight: bold;" class="function">meuSegundo</code><strong class="userinput"><code> [2]</code></strong><br>*** Exception: lista curta demais<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>head (segundoMeu [[9]])</code></strong><br>*** Exception: lista curta demais<br></pre>
<p id="x_z3"><a name="x_z3"></a> Observe que o terceiro caso acima,
onde nós tentamos usar o resultado da chamada para <code class="function">meuSegundo</code> como argumento para outra função.
Avaliação ainda termina e cai-nos de volta ao prompt <span class="command"><strong>ghci</strong></span>. Esta é a grande fraqueza
do uso de <code class="function">error</code>:
não deixar o nosso interlocutor distinguir entre um erro recuperável e
um problema tão grave que ele realmente deve encerrar o nosso programa.
</p>
<p id="x_CC1"><a name="x_CC1"></a> Como nós já vimos, o padrão de
casamento falha e provoca um similar erro irreparável. </p>
<a name="error.ghci:myError"></a>
<pre id="error.ghci:myError" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>segundoMeu []</code></strong><br>*** Exception: Prelude.tail: empty list<br></pre>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.morecontrolled">Uma abordagem mais
controlada</h3>
</div>
</div>
</div>
<p id="x_fg"><a name="x_fg"></a> Podemos usar o tipo <span class="type">Maybe</span>
para representar a possibilidade de um erro. </p>
<p id="x_gg"><a name="x_gg"></a> Se queremos indicar que uma operação
falhou, nós podemos usar o construtor <code class="function">Nothing</code>.
Caso contrário, nós envolvemos o nosso valor com o construtor <code class="function">Just</code>. </p>
<p id="x_hg"><a name="x_hg"></a> Vamos ver como a nossa função <code class="function">meu</code><code class="function">Segundo</code>&nbsp;
muda se nós retornamos um valor <span class="type">Maybe</span> ao
invés da chamada <code class="function">error</code>. </p>
<a name="MySecond.hs:safeSecond"></a>
<pre id="MySecond.hs:safeSecond" class="programlisting"><code class="codecomment">-- arquivo: ca03/SegundoMeu.hs</code><br>segundoSeguro:: [a]-&gt; Maybe a<br><br>segundoSeguro [] = Nothing<br>segundoSeguro xs = if null (tail xs)<br>                   then Nothing<br>                   else Just (head (tail xs))</pre>
<p id="x_ig"><a name="x_ig"></a> Se a lista que você passou é muito
curta, voltamos <code class="code">Nothing</code> a nosso
interlocutor. Isso permite que eles decidam o que fazer, onde uma
chamada para <code class="function">error</code> forçaria uma queda. </p>
<a name="error.ghci:safeSecond"></a>
<pre id="error.ghci:safeSecond" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>segundoSeguro []</code></strong><br>Nothing<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>segundoSeguro [1]</code></strong><br>Nothing<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>segundoSeguro [1,2]</code></strong><br>Just 2<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>segundoSeguro [1,2,3]</code></strong><br>Just 2<br></pre>
<p id="x_jg"><a name="x_jg"></a> Para retornar a um tópico anterior,
podemos melhorar a legibilidade desta função com a casamento de
padrões. </p>
<a name="MySecond.hs:tidySecond"></a>
<pre id="MySecond.hs:tidySecond" class="programlisting"><code class="codecomment">-- arquivo: ca03/SegundoMeu.hs</code><br>segundoLimpo:: [a]-&gt; Maybe a<br><br>segundoLimpo (_:x:_) = Just x<br>segundoLimpo _ = Nothing</pre>
<p id="x_kg"><a name="x_kg"></a>O primeiro padrão corresponde somente
se a lista é de pelo menos dois
elementos de comprimento (que contém dois construtores lista), e
vincula-se a variável <code class="varname">x</code> para o segundo
elemento da lista. O segundo padrão é casado se o primeiro falhar. </p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.locals">Introdução
das variáveis locais</h2>
</div>
</div>
</div>
<p id="x_f4"><a name="x_f4"></a> Dentro do corpo de uma função, podemos
introduzir novas variáveis locais sempre que precisamos deles, usando
uma expressão <code class="literal">let</code>.
Aqui é uma simples função que determina se devemos emprestar algum
dinheiro para um cliente. Encontramos uma reserva de dinheiro de pelo
menos 100, voltamos nosso novo equilíbrio depois de subtrair o valor
que têm emprestado. </p>
<a name="Lending.hs:lend"></a>
<pre id="Lending.hs:lend" class="programlisting"><code class="codecomment">-- arquivo: ca03/Emprestar.hs</code><br>emprestado quantidade equilíbrio = let reserva= 100<br>                                       equilíbrioNovo = equilíbrio - quantidade<br>                                   in if equilíbrio &lt; reserva<br>                                      then Nothing<br>                                      else Just equilíbrioNovo</pre>
<p id="x_g4"><a name="x_g4"></a> As palavras-chave a olhar aqui é a <code class="literal">let</code>, que inicia um bloco de declarações de
variáveis, e <code class="code">in</code>, que termina-o. Cada linha
introduz uma nova variável. O nome está do lado esquerdo do <code class="literal">=</code>, e a expressão que ele está vinculada está à
direita. </p>
<div class="note">
<table summary="Note: Special notes" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">Notas especiais</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_ng"><a name="x_ng"></a> Vamos re-enfatizar a nossa
redação: um nome em bloco <code class="literal">let</code>&nbsp; é
vinculado a uma <span class="emphasis"><em>expressão</em></span>, não
a um <span class="emphasis"><em>valor</em></span>.
Porque Haskell é uma linguagem de avaliação preguiçosa, a expressão
associada com
um nome realmente não vai ser avaliado até que seja necessário. No
exemplo acima, não vamos calcular o valor do <code class="varname">equilíbrioNovo</code>
se não cumprir as nossas reservas. </p>
      <p id="x_og"><a name="x_og"></a> Quando definimos uma variável em
um bloco <code class="literal">let</code>, nós referimos a ela como
uma variável <span class="emphasis"><em>vinculação <code class="literal">let</code></em></span> (<span class="emphasis"><em><code class="literal">let</code>-bound</em></span> variable). Isto
simplesmente significa que ele diz: temos vinculado a uma variável em
um bloco <code class="literal">let</code>. </p>
      <p id="x_pg"><a name="x_pg"></a> Além disso, a utilização de
espaço em branco aqui é importante. Falaremos em mais detalhes sobre as
regras de layout <a class="xref" href="defining-types-streamlining-functions.html#deftypes.offside" title="The offside rule and white space in an expression">a seção
chamada “A regra de impedimento e espaço em branco em uma expressão”</a>.
      </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_qg"><a name="x_qg"></a> Podemos usar o nome de uma variável em
bloco <code class="literal">let</code> dentro do bloco de declarações
e na expressão que segue a palavras-chave <code class="code">in</code>.
</p>
<p id="x_rg"><a name="x_rg"></a> Em geral, vamos nos referir aos
lugares dentro de nosso código, onde podemos usar um nome como o nome
do <span class="emphasis"><em>escopo</em></span>. Se nós podemos usar
um nome, ele está <span class="emphasis"><em>no escopo</em></span>,
caso contrário ele está <span class="emphasis"><em>fora de escopo</em></span>.
Se um nome é visível ao longo de um arquivo fonte, dizemos que ele está
no <span class="emphasis"><em>nível superior</em></span>. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id586544">Ocultamento</h3>
</div>
</div>
</div>
<p id="x_i4"><a name="x_i4"></a> Nós podemos “<span class="quote">aninhar</span>”
múltiplos blocos <code class="literal">let</code> dentro do outro em
uma expressão. </p>
<a name="NestedLets.hs:foo"></a>
<pre id="NestedLets.hs:foo" class="programlisting"><code class="codecomment">-- arquivo: ca03/LetsAninhados.hs</code><br>foo= let a= 1<br>     in let b= 2<br>        in a + b</pre>
<p id="x_yg"><a name="x_yg"></a> É perfeitamente legal, mas não
exatamente inteligente, para repetir um nome de variável em uma
expressão <code class="literal">let</code> aninhada. </p>
<a name="NestedLets.hs:bar"></a>
<pre id="NestedLets.hs:bar" class="programlisting"><code class="codecomment">-- arquivo: ca03/LetsAninhados.hs</code><br>bar= let x = 1<br>     in (let x= "foo" in x, x)</pre>
<p id="x_zg"><a name="x_zg"></a> Aqui, o <code class="varname">x</code>
interior está escondido, ou <span class="emphasis"><em>oculto</em></span>,
do <code class="varname">x</code> exterior. Ele tem o mesmo nome, mas
de um tipo diferente e valor. </p>
<a name="nestedlets.ghci:bar"></a>
<pre id="nestedlets.ghci:bar" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>bar</code></strong><br>("foo",1)<br></pre>
<p id="x_Ah"><a name="x_Ah"></a> Nós também podemos ocultar parâmetros
de uma função, levando a resultados ainda desconhecido. Qual é o tipo
desta função? </p>
<a name="NestedLets.hs:quux"></a>
<pre id="NestedLets.hs:quux" class="programlisting"><code class="codecomment">-- arquivo: ca03/LetsAninhados.hs</code><br>quux a = let a = "foo"<br>         in a ++ "eek!"</pre>
<p id="x_Bh"><a name="x_Bh"></a> Porque o argumento da função <code class="varname">a</code> nunca é usado no corpo da função, devido a
estar ocultada&nbsp; pelo<span style="font-family: monospace;"> </span><code class="varname"></code><code class="literal">let-bound a</code>, o
argumento pode ter qualquer tipo. </p>
<a name="nestedlets.ghci:quux"></a>
<pre id="nestedlets.ghci:quux" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:t quux</code></strong><br>quux :: t -&gt; [Char]<br></pre>
<div class="tip">
<table summary="Tip: Compiler warnings are your friends" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="support/figs/tip.png"></td>
      <th align="left">Advertências do compilador são seus amigos</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_Ch"><a name="x_Ch"></a> Ocultamento pode, obviamente,
levar à confusão e bugs, assim <span class="application">GHC</span>
tem um opção útil <code class="option">-fwarn-name-shadowing</code>.
Quando ativado, <span class="application">GHC</span> irá imprimir uma
mensagem de aviso toda vez que ocultarmos um nome. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id586728">A cláusula where</h3>
</div>
</div>
</div>
<p id="x_Dh"><a name="x_Dh"></a> Podemos usar um outro mecanismo para
introduzir variáveis locais: a cláusula <code class="literal">where</code>.
As definições de cláusula <code class="literal">where</code> aplicam
ao código que a <span class="emphasis"><em>antecede</em></span>. Aqui
está uma função semelhante a <code class="function">emprestado</code>,
usando <code class="literal">where</code> em vez de <code class="literal">let</code>. </p>
<a name="Lending.hs:lend2"></a>
<pre id="Lending.hs:lend2" class="programlisting"><code class="codecomment">-- arquivo: ca03/Emprestar.hs</code><br>emprestado2 quantidade equilíbrio = if equilíbrio &lt; reserva * 0.5<br>                                    then Just equilíbrioNovo<br>                                    else Nothing<br>    where reserva= 100<br>          equilíbrioNovo= equilíbrio - quantidade</pre>
<p id="x_Fh"><a name="x_Fh"></a> Enquanto uma cláusula <code class="literal">where</code> pode parecer estranho inicialmente,
oferece uma maravilhosa ajuda a legibilidade. Deixa-nos dirigir o foco
do nosso leitor os detalhes importantes de uma expressão, com as
definições apresentadas a seguir. Depois de um tempo, você pode sentir
falta por não achar cláusulas <code class="literal">where</code> em
linguagens que não as possuem. </p>
<p id="x_l4"><a name="x_l4"></a> Tal como acontece com expressões <code class="literal">let</code>, espaço em branco é significativo nas
cláusulas <code class="literal">where</code>. Nós falaremos mais sobre
as regras de layout em breve, na <a class="xref" href="defining-types-streamlining-functions.html#deftypes.offside" title="The offside rule and white space in an expression">seção
chamada “A regra offside e espaço em branco em uma expressão”</a>. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.locals.functions">Funções locais,
variáveis globais</h3>
</div>
</div>
</div>
<p id="x_FL"><a name="x_FL"></a>Você vai ter notado que a sintaxe
Haskell para definir uma variável é
muito parecido com sua sintaxe para a definição de uma função. Essa
simetria é mantida em blocos <code class="literal">let</code> e <code class="literal">where</code>: podemos definir <span class="emphasis"><em>funções</em></span>
locais tão facilmente quanto as <span class="emphasis"><em>variáveis</em></span>
locais. </p>
<a name="LocalFunction.hs:pluralise"></a>
<pre id="LocalFunction.hs:pluralise" class="programlisting"><code class="codecomment">-- arquivo: ca03/FunçãoLocal.hs</code><br>plurals:: String-&gt; [Int]-&gt; [String]<br>plurals palavra contagens = map plural contagens<br>    where plural 0 = "nenhum " ++ palavra ++ "s"<br>          plural 1 = "um " ++ palavra<br>          plural n = show n ++ " " ++ palavra ++ "s"</pre>
<p id="x_GL"><a name="x_GL"></a> Nós definimos uma função local <code class="function">plural</code>,
que consiste de várias equações. Funções locais podem usar livremente
as variáveis dos escopos onde foram colocá-das: aqui, nós usamos <code class="varname">palavra</code> da definição da função exterior <code class="function">plurals</code>. Na definição de <code class="function">plurals</code>, a função <code class="function">map</code>
(que iremos revisitar no próximo capítulo) aplica-se a função local <code class="function">plural</code> para cada elemento da lista <code class="varname">contagens</code>. </p>
<p id="x_Gh"><a name="x_Gh"></a> Nós também podemos definir variáveis,
bem como as funções, no nível superior de um arquivo fonte. </p>
<a name="GlobalVariable.hs:itemName"></a>
<pre id="GlobalVariable.hs:itemName" class="programlisting"><code class="codecomment">-- arquivo: ca03/VariávelGlobal.hs</code><br>nomeItem= "Weighted Companion Cube"</pre>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.offside">A regra
offside e espaço em branco em uma expressão</h2>
</div>
</div>
</div>
<p id="x_u4"><a name="x_u4"></a> Em nossas definições de <code class="function">emprestado</code> e <code class="function">emprestado2</code>,
na margem esquerda do nosso texto vagava um pouco. Este não foi um
acidente: em Haskell, um espaço em branco tem um significado. </p>
<p id="x_v4"><a name="x_v4"></a> Haskell usa indentação
como uma sugestão para analisar seções de código. Este uso de layout
para transmitir a estrutura é muitas vezes chamado de <span class="emphasis"><em>regra offside</em></span>.
No início de um arquivo fonte, o nível superior em primeiro lugar
declaração ou definição pode começar em qualquer coluna, e o compilador
Haskell ou intérpretador lembra que nível de recuo. Cada nível superior
posterior declaração deve ter a mesma endentação. </p>
<p id="x_w4"><a name="x_w4"></a> Aqui está um exemplo do nível de recuo
norma superior. Nosso primeiro arquivo <code class="filename">IndentaçãoBom.hs</code>,
é bem comportada. </p>
<a name="GoodIndent.hs:good"></a>
<pre id="GoodIndent.hs:good" class="programlisting"><code class="codecomment">-- arquivo: ca03/IndentaçãoBom.hs<br>-- Esta é a coluna da esquerda.</code><br><br>  <code class="codecomment">-- É bom para as declarações de nível superior para iniciar em qualquer coluna...</code><br>  indentaçãoBomPrimeira= 1<br>  <code class="codecomment">-- ... desde que todas as declarações posteriores do, também!</code><br>  indentaçãoBomSegunda= 2</pre>
<p id="x_x4"><a name="x_x4"></a> Nosso segundo, <code class="filename">IndentaçãoMau.hs</code>,
doesn't play by the rules. </p>
<a name="BadIndent.hs:bad"></a>
<pre id="BadIndent.hs:bad" class="programlisting"><code class="codecomment">-- arquivo: ca03/IndentaçãoMau.hs<br>-- Esta é a coluna da esquerda.</code><br><br>    <code class="codecomment">-- Nossa primeira declaração está na coluna 4.</code><br>    indentaçãoMauPrimeira= 1<br>  <code class="codecomment">-- A nossa segunda esquerda do primeiro, que é ilegal!</code><br>  indentaçãoMauSegunda= 2</pre>
<p id="x_y4"><a name="x_y4"></a> Veja o que acontece quando tentamos
carregar os dois arquivos em <span class="command"><strong>ghci</strong></span>.</p>
<a name="indent.ghci:load"></a>
<pre id="indent.ghci:load" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:l IndentaçãoBom.hs</code></strong><br>[1 of 1] Compiling Main             ( IndentaçãoBom.hs, interpreted )<br>Ok, modules loaded: Main.<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:load IndentaçãoMau.hs</code></strong><br>[1 of 1] Compiling Main             ( IndentaçãoMau.hs, interpreted )<br><br>IndentaçãoMau.hs:8:2: parse error on input `indentaçãoBomSegunda'<br>Failed, modules loaded: none.<br></pre>
<p id="x_z4"><a name="x_z4"></a> O seguinte linha vazia é tratada
como uma continuação do item atual, como é uma linha que se segue mais
recuado para a direita. </p>
<p id="x_A5"><a name="x_A5"></a> As regras para expressões <code class="literal">let</code> e as cláusulas <code class="literal">where</code>
são semelhantes. Depois de uma palavra-chave <code class="literal">let</code>
ou <code class="literal">where</code>,
o compilador Haskell ou intérprete recorda o recuo do próximo token que
vê. Se a linha que se segue é vazio, ou o seu recuo é mais para a
direita, considera-se para continuar a linha anterior. Se o recuo é a
mesma do início do item anterior, este é tratado como início de um novo
item no mesmo bloco. </p>
<a name="Indentation.hs:foo"></a>
<pre id="Indentation.hs:foo" class="programlisting"><code class="codecomment">-- arquivo: ca03/Indentação.hs</code><br>foo = let definiçãoPrimeira= blah blah<br>          <code class="codecomment">-- Uma linha de comentário, só é tratado como vazio</code><br>                              continuação blah<br>          <code class="codecomment">-- Nós reduzimos o recuo, pelo que esta é uma nova definição</code><br>          definiçãoSegunda = yada yada<br><br>                             continuação yada<br>      in qualquer</pre>
<p id="x_B5"><a name="x_B5"></a> Aqui estão usas aninhados de <code class="literal">let</code> e <code class="literal">where</code>. </p>
<a name="letwhere.hs:let"></a>
<pre id="letwhere.hs:let" class="programlisting"><code class="codecomment">-- arquivo: ca03/LetWhere.hs</code><br>bar = let b = 2<br>          c = True<br>      in let a = b<br>         in (a, c)</pre>
<p id="x_C5"><a name="x_C5"></a> O nome de <code class="varname">a</code>
só é visível no a expressão <code class="literal">let</code> interior.
Não é visível no <code class="literal">let</code> exterior. Se
tentarmos usar o nome de <code class="varname">a</code>
lá, nós vamos receber um erro de compilação. O recuo nos dá tanto o
compilador e uma sugestão visual, como o que está no espaço. </p>
<a name="letwhere.hs:where"></a>
<pre id="letwhere.hs:where" class="programlisting"><code class="codecomment">-- arquivo: ca03/LetWhere.hs</code><br>foo = x<br>    where x = y<br>              where y = 2</pre>
<p id="x_D5"><a name="x_D5"></a> Do mesmo modo, no âmbito da primeira
cláusula <code class="literal">where</code> é a definição de <code class="varname">foo</code>, mas o escopo do segundo é apenas o
primeiro cláusula <code class="literal">where</code>. </p>
<p id="x_E5"><a name="x_E5"></a> O indentação que usamos para as
cláusulas <code class="literal">let</code> e <code class="literal">where</code>
faz nossas intenções fácil de descobrir. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.tabs">Uma nota sobre tabs versus espaços</h3>
</div>
</div>
</div>
<p id="x_F5"><a name="x_F5"></a>Se você usar um editor de texto ciente
Haskell (eg Emacs), ele
provavelmente já está configurado para usar caracteres de espaço para
todos os espaços em branco quando você editar arquivos fonte Haskell.
Se o editor <span class="emphasis"><em>não</em></span> é
Haskell-conhecimento, você deve configurá-lo para usar apenas
caracteres de espaço. </p>
<p id="x_G5"><a name="x_G5"></a>A razão para isto é a portabilidade. Em
um editor que utiliza uma fonte
de largura fixa, tabulações, por convenção, são colocados em diferentes
intervalos de sistemas Unix-like (a cada oito caracteres) que no
Windows (a cada quatro caracteres). Isto significa que não importa o
que suas crenças pessoais sobre onde guias pertencem, você não pode
confiar em alguém do editor honrar suas preferências. Qualquer avanço
que usa abas está indo olhar quebrado sob a configuração de <span class="emphasis"><em>alguém</em></span>
De fato, isso pode levar a problemas de compilação, como o linguagem
padrão Haskell exige implementações usar o Unix convenção tabulação.
Usando caracteres de espaço evita este problema completamente. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="deftypes.block">A regra offside não é obrigatória</h3>
</div>
</div>
</div>
<p id="x_H5"><a name="x_H5"></a>Podemos usar explícita estruturação de
layout em vez de indicar o que
queremos dizer. Para fazer isso, nós começamos um bloco de equações com
uma chave de abertura; separe cada item com um ponto e vírgula, e
terminar o bloco com uma chave de fechamento. A seguir os dois usos <code class="literal">let</code> têm o mesmo significado. </p>
<a name="Braces.hs:braces"></a>
<pre id="Braces.hs:braces" class="programlisting"><code class="codecomment">-- arquivo: ca03/Chaves.hs</code><br>bar = let a = 1<br>          b = 2<br>          c = 3<br>      in a + b + c<br><br>foo = let { a = 1;  b = 2;<br>        c = 3 }<br>      in a + b + c</pre>
<p id="x_I5"><a name="x_I5"></a>Quando usamos a estruturação explícita,
as regras de distribuição
normal não se aplica, que é por isso que podemos ir longe com recuo
invulgar na expressão <code class="literal">let</code> segunda. </p>
<p id="x_J5"><a name="x_J5"></a> Podemos usar a estruturação explícita
em qualquer lugar que nós normalmente usamos layout. É válido para
cláusulas <code class="literal">where</code>,
e declarações de nível superior mesmo. Basta lembrar que, embora o
mecanismo existe, explícita estruturação quase nunca é realmente <span class="emphasis"><em>utilizada</em></span> em programas Haskell. </p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.case">A expressão
case</h2>
</div>
</div>
</div>
<p id="x_q5"><a name="x_q5"></a> As definições de função não são o
único lugar onde podemos usar a correspondência de padrão. O <code class="literal">case</code> nos permite construir padrões de jogo
dentro de uma expressão. Aqui está o que parece. Esta função (definida
para nós em <code class="code">Data.Maybe</code>) desembrulha um valor
<span class="type">Maybe</span>, usando um padrão se o valor é <code class="code">Nothing</code>. </p>
<a name="Guard.hs:fromMaybe"></a>
<pre id="Guard.hs:fromMaybe" class="programlisting"><code class="codecomment">-- arquivo: ca03/Guarda.hs</code><br>fromMaybe valorDefault embrulhado =<br>    case embrulhado of<br>      Nothing-&gt; valorDefault<br>      Just valor-&gt; valor</pre>
<p id="x_r5"><a name="x_r5"></a> A palavras-chave <code class="code">case</code>
é seguido por uma expressão arbitrária: a correspondência de padrões é
feita contra o resultado desta expressão. O chave <code class="code">of</code>
significa o fim da expressão e do início do bloco de padrões e
expressões. </p>
<p id="x_s5"><a name="x_s5"></a> Cada item no bloco consiste em um
padrão, seguido por uma seta <code class="code">-&gt;</code>,
seguido de uma expressão para avaliar se o padrão de partidas. Estas
expressões devem ter todos o mesmo tipo. O resultado da expressão <code class="code">case</code> é o resultado da expressão associada com o
primeiro padrão a casar. Casamentos são tentadas a partir de cima para
baixo. </p>
<p id="x_t5"><a name="x_t5"></a> Para expressar “<span class="quote">aqui
é a expressão para avaliar se nenhum dos outros padrões match</span>”,
a gente só usa o cartão padrão curinga <code class="code">_</code>
como o último da nossa lista de padrões. Se um jogo padrão falhar,
teremos o mesmo tipo de erro de execução, como vimos anteriormente. </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.pattern.limits">Erros
comuns dos novatos com os padrões</h2>
</div>
</div>
</div>
<p id="x_NL"><a name="x_NL"></a>Existem algumas maneiras em que Haskell
novos programadores podem não
entender ou padrões de utilização indevida. Aqui estão algumas
tentativas de correspondência padrão deu errado. Dependendo do que você
espera que um desses exemplos que fazer, ele pode conter uma surpresa. </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id587485">Correspondência incorretamente contra
uma variável</h3>
</div>
</div>
</div>
<a name="BogusPattern.hs:whichFruit"></a>
<pre id="BogusPattern.hs:whichFruit" class="programlisting"><code class="codecomment">-- arquivo: ca03/PadrãoFalto.hs</code><br>data Fruta = Maçã | Laranja<br><br>maçã = "maçã"<br><br>laranja = "laranja"        <br><br>qualFruta:: String-&gt; Fruit<br>qualFruta f = case f of<br>                 maçã-&gt; Maçã<br>                 laranja-&gt; Laranja</pre>
<p id="x_w5"><a name="x_w5"></a> Um olhar ingênuo sugere que este
código está tentando verificar o valor de <code class="function">f</code>
para ver se corresponde ao valor <code class="varname">maçã</code> ou <code class="varname">laranja</code>. </p>
<p id="x_DC1"><a name="x_DC1"></a> É mais fácil detectar o erro se
reescrever o código em um estilo equacional. </p>
<a name="BogusPattern.hs:equational"></a>
<pre id="BogusPattern.hs:equational" class="programlisting"><code class="codecomment">-- arquivo: ca03/PadrãoFalto.hs</code><br>equacional maçã = Maçã<br>equacional laranja = Laranja</pre>
<p id="x_EC1"><a name="x_EC1"></a>Agora você pode ver o problema? Aqui,
é mais óbvio <code class="varname">maçã</code> não se refere ao valor
mais alto nível o nome <code class="varname">maçã</code>: é uma
variável padrão local. </p>
<div class="note">
<table summary="Note: Irrefutable patterns" border="0">
  <tbody>
    <tr>
      <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="support/figs/note.png"></td>
      <th align="left">IPadrões irrefutáveis</th>
    </tr>
    <tr>
      <td align="left" valign="top">
      <p id="x_y5"><a name="x_y5"></a> Referimo-nos a um padrão que
sempre sucede como <span class="emphasis"><em>irrefutável</em></span>.
Nomes de variáveis simples e um curinga <code class="code">_</code>
são exemplos de padrões irrefutáveis. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p id="x_Ih"><a name="x_Ih"></a> Aqui está uma versão corrigida da
função. </p>
<a name="BogusPattern.hs:betterFruit"></a>
<pre id="BogusPattern.hs:betterFruit" class="programlisting"><code class="codecomment">-- arquivo: ca03/BogusPattern.hs</code><br>frutaMelhor f = case f of<br>                   "maçã"-&gt; Maçã<br>                   "laranja"-&gt; Laranja</pre>
<p id="x_Jh"><a name="x_Jh"></a> Nós fixamos o problema, fazer a
comparação com os valores literal <code class="code">"maçã"</code> e <code class="code">"laranjas"</code>. </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="id587613">Tentando comparar a igualdade
incorretamente</h3>
</div>
</div>
</div>
<p id="x_Kh"><a name="x_Kh"></a> O que se pretende comparar os valores
armazenados em dois nós da <span class="type">Árvore</span>, do tipo,
e retornar um deles se eles são iguais? Aqui está uma tentativa. </p>
<a name="BadTree.hs:bad_nodesAreSame"></a>
<pre id="BadTree.hs:bad_nodesAreSame" class="programlisting"><code class="codecomment">-- arquivo: ca03/ÁrvoreMau.hs</code><br>nósSãoIguaisMau (Nó a _ _) (Nó a _ _) = Just a<br>nósSãoIguaisMau _          _          = Nothing</pre>
<p id="x_A6"><a name="x_A6"></a>Um nome pode aparecer apenas uma vez em
um conjunto de ligações padrão.
Nós não podemos colocar uma variável em várias posições para expressar
a noção de “<span class="quote">este valor e que devem ser idênticos</span>”.
Em vez disso, nós vamos resolver esse problema utilizando <span class="emphasis"><em>guardas</em></span>, outra característica Haskell
inestimável. </p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="deftypes.guard">Avaliação
condicional com guardas</h2>
</div>
</div>
</div>
<p id="x_C6"><a name="x_C6"></a>Correspondência de padrões Limites nos
a realizar testes de valor fixo
de uma forma. Embora isso seja útil, nós, muitas vezes, querem fazer
uma verificação mais expressivo antes de avaliar a função do órgão.
Haskell oferece um recurso, os <span class="emphasis"><em>guardas</em></span>,
que nos dão esta habilidade. Vamos introduzir a idéia de uma
modificação da função que escrevi para comparar dois nós de uma árvore.
</p>
<a name="BadTree.hs:nodesAreSame"></a>
<pre id="BadTree.hs:nodesAreSame" class="programlisting"><code class="codecomment">-- arquivo: ca03/ÁrvoreMau.hs</code><br>nósSãoIguais (Nó a _ _) (Nó b _ _)<br>    | a == b     = Just a<br>nósSãoIguais _ _ = Nothing</pre>
<p id="x_FC1"><a name="x_FC1"></a>Neste exemplo, usamos o padrão de
correspondência para garantir que
estamos olhando para os valores da forma correta, e um guarda para
comparar peças deles. </p>
<p id="x_Lh"><a name="x_Lh"></a> Um padrão pode ser seguido por zero ou
mais guardas, cada uma expressão do tipo <span class="type">Bool</span>.
A guarda é introduzida por um símbolo <code class="code">|</code>.
Isto é seguido pela expressão guarda, em seguida, um símbolo <code class="code">=</code> (ou <code class="code">-&gt;</code> se estamos
em uma expressão <code class="literal">case</code>), então o organismo
a usar a expressão guarda se avalia a <code class="code">True</code>.
Se um padrão casar, cada guarda associados a esse padrão é avaliada, na
ordem em que são escritos. Se um guarda-sucedido, o corpo associada a
ele é usado como o resultado da função. Se não for bem-sucedido de
guarda, o padrão de correspondência se move para o padrão seguinte. </p>
<p id="x_Mh"><a name="x_Mh"></a> Quando um guarda de
expressão é avaliada, de todas as variáveis mencionadas no padrão com o
qual está associado é limitado e pode ser usado. </p>
<p id="x_GC1"><a name="x_GC1"></a> Aqui está uma versão melhorada da
nossa função <code class="function">emprestado</code> que usa as
guardas. </p>
<a name="Lending.hs:lend3"></a>
<pre id="Lending.hs:lend3" class="programlisting"><code class="codecomment">-- arquivo: ca03/Emprestar.hs</code><br>emprestado3 quantidade equilíbrio <br>     | quantidade &lt;= 0 = Nothing<br>     | quantidade &gt; reserva * 0.5 = Nothing<br>     | otherwise = Just equilíbrioNovo<br>    where reserva= 100<br>          equilíbrioNovo= equilíbrio - quantidade</pre>
<p id="x_HC1"><a name="x_HC1"></a> A procura de guarda-expressão
especial <code class="varname">otherwise</code> é simplesmente uma
variável associada ao valor <code class="code">True</code>, para
ajudar a legibilidade. </p>
<p id="x_F6"><a name="x_F6"></a>Podemos usar os guardas em qualquer
lugar que nós podemos usar os
padrões. Escrever uma função como uma série de equações usando a
correspondência de padrão e os guardas podem torná-lo mais claro.
Lembre-se da função <code class="function">meuDrop</code> é definida
na <a class="xref" href="types-and-functions.html#funcstypes.if" title="Conditional evaluation">seção chamada “Avaliação condicional”</a>?
</p>
<a name="myDrop.hs:myDrop1"></a>
<pre id="myDrop.hs:myDrop1" class="programlisting"><code class="codecomment">-- arquivo: ca02/meuDrop.hs</code><br>meuDrop n xs = if n &lt;= 0 || null xs<br>               then xs<br>               else meuDrop (n - 1) (tail xs)</pre>
<p id="x_H6"><a name="x_H6"></a> Aqui está uma reformulação que utiliza
padrões e guardas. </p>
<a name="myDrop.hs:niceDrop"></a>
<pre id="myDrop.hs:niceDrop" class="programlisting"><code class="codecomment">-- arquivo: ca03/meuDrop.hs</code><br>dropAgradável n xs | n &lt;= 0 = xs<br>dropAgradável _ []          = []<br>dropAgradável n (_:xs)      = dropAgradável (n - 1) xs</pre>
<p id="x_Oh"><a name="x_Oh"></a> Esta mudança de estilo nos permite
enumerar <span class="emphasis"><em>se frente</em></span>
os casos em que esperamos uma função para se comportar de maneira
diferente. Se enterrar as decisões dentro de uma função como expressões
<code class="literal">if</code> o código se torna mais difícil de ler. </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;" id="id587860">Exercícios</h2>
</div>
</div>
</div>
<div class="qandaset">
<table summary="Q and A Set" border="0">
  <col align="left" width="1%"><tbody>
    <tr class="question">
      <td align="left" valign="top"><a name="id587870"></a><a name="id587873"></a>
      <p> <b>1.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_IC1"><a name="x_IC1"></a>Escreva uma função que calcula
o número de elementos em uma lista. Para
testá-lo, verifique se ele dá a mesma resposta que o função padrão <code class="function">length</code>. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587891"></a><a name="id587893"></a>
      <p> <b>2.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_JC1"><a name="x_JC1"></a>Adicionar uma assinatura para o
seu tipo de função para o seu arquivo
de origem. Para testá-lo, carregar o arquivo de origem em <span class="command"><strong>ghci</strong></span> novamente. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587912"></a><a name="id587914"></a>
      <p> <b>3.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_KC1"><a name="x_KC1"></a>Escreva uma função que calcula
a média de uma lista, ou seja, a soma de
todos os elementos da lista dividida pelo seu comprimento. (Você pode
precisar usar a função <code class="function">fromIntegral</code> para
converter o tamanho da lista de um número inteiro em um número de ponto
flutuante). </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587933"></a><a name="id587936"></a>
      <p> <b>4.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_LC1"><a name="x_LC1"></a> Vire em uma lista um
palíndromo, ou seja, deve ler-se o mesmo tanto de trás para frente. Por
exemplo, dada a lista <code class="code">[1,2,3]</code>, a sua função
deve retornar <code class="code">[1,2,3,3,2,1]</code>. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587955"></a><a name="id587958"></a>
      <p> <b>5.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_MC1"><a name="x_MC1"></a> Escreva uma função que
determina se a sua lista de entrada é um palíndromo. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587970"></a><a name="id587972"></a>
      <p> <b>6.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_NC1"><a name="x_NC1"></a>Criar uma função que ordena uma
lista de listas com base no comprimento
de cada sublista. (Você pode querer olhar para a função <code class="function">sortBy</code> da módulo <code class="code">Data.List</code>.)
      </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id587994"></a><a name="id587996"></a>
      <p> <b>7.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_OC1"><a name="x_OC1"></a> Definir uma função que se
junta a uma lista de listas, juntamente com um valor de separação. </p>
      <a name="Intersperse.hs:intersperse"></a>
      <pre id="Intersperse.hs:intersperse" class="programlisting"><code class="codecomment">-- arquivo: ca03/Entremeado.hs</code><br>entremeado:: a-&gt; [[a]]-&gt; [a]</pre>
      <p id="x_PC1"><a name="x_PC1"></a>O separador deve aparecer entre
os elementos da lista, mas não deve
seguir o último elemento. Sua função deve se comportar como se segue. </p>
      <a name="intersperse.ghci:intersperse"></a>
      <pre id="intersperse.ghci:intersperse" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:l Entremeado</code></strong><br>[1 of 1] Compiling Main             ( Entremeado.hs, interpreted )<br>Ok, modules loaded: Main.<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>entremeado ',' []</code></strong><br>""<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>entremeado ',' ["foo"]</code></strong><br>"foo"<br><code class="prompt">ghci&gt; </code><strong class="userinput"><code>entremeado ',' ["foo","bar","baz","quux"]</code></strong><br>"foo,bar,baz,quux"<br>      </pre>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id588080"></a><a name="id588082"></a>
      <p><b>8.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_QC1"><a name="x_QC1"></a>Usando o tipo de árvore binária
que definimos anteriormente neste
capítulo, escreva uma função que irá determinar a altura da árvore. A
altura é o maior número de saltos a partir da raiz de um <code class="code">Nada</code>. Por exemplo, a árvore <code class="code">Nada</code>
tem altura zero; <code class="code">Nó "x" Nada Nada</code> tem altura
de um; <code class="code">Nó "x" Nada (Nó "y" Nada Nada)</code> tem
altura de dois, e assim por diante.</p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id588110"></a><a name="id588112"></a>
      <p> <b>9.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_RC1"><a name="x_RC1"></a> Considere treis pontos 2D <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>b</em></span>
e <span class="emphasis"><em>c</em></span>. Se olharmos para o ângulo
formado pelo segmento de linha a partir de <span class="emphasis"><em>a</em></span>
para <span class="emphasis"><em>b</em></span> e o segmento de linha de
      <span class="emphasis"><em>b</em></span> para <span class="emphasis"><em>c</em></span>, que quer virar à esquerda, vire à
direita, ou faz uma linha reta. Definir um tipo de dados <span class="type">Direção</span> que permite representar essas
possibilidades. </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id588154"></a><a name="id588156"></a>
      <p> <b>10.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_SC1"><a name="x_SC1"></a> Escreva uma função que calcula
a curva feita por três pontos 2D e retorna uma <span class="type">Direção</span>.
      </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id588171"></a><a name="id588174"></a>
      <p> <b>11.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_TC1"><a name="x_TC1"></a>Definir uma função que recebe
uma lista de pontos 2D e calcula a
direção de cada sucessivas triplo. Dada uma lista de pontos de <code class="code">[a,b,c,d,e]</code>, ideve começar por calcular a vez
feita por <code class="code">[a,b,c]</code>, então a vez feita por <code class="code">[b,c,d]</code>, então <code class="code">[c,d,e]</code>.
Sua função deve retornar uma lista de <span class="type">Direção</span>.
      </p>
      </td>
    </tr>
    <tr class="question">
      <td align="left" valign="top"><a name="id588205"></a><a name="id588207"></a>
      <p> <b>12.</b></p>
      </td>
      <td align="left" valign="top">
      <p id="x_UC1"><a name="x_UC1"></a>Utilizando o código de nos
últimos três exercícios, implementar
Graham's scan algoritmo para o casco convexo de um conjunto de pontos
2D. Você pode encontrar uma boa descrição do que é um <a class="ulink" href="http://pt.wikipedia.org/wiki/Envolt%C3%B3ria_convexa" target="_top">envoltória convexa</a> e como o <a class="ulink" href="http://pt.wikipedia.org/wiki/Exame_de_Graham" target="_top">exame
de Graham</a> deve trabalhar, na <a class="ulink" href="http://pt.wikipedia.org/" target="_top">Wikipedia</a>. </p>
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div class="footnotes"><br>
<hr align="left" width="100">
<div class="footnote">
<p> <sup>[<a name="ftn.id582956" href="#id582956" class="para">7</a>] </sup>
Se você estiver familiarizado com C ou C++, é análogo a um <code class="code">typedef</code>. </p>
</div>
</div>
</div>

<div class="rwhfooter">
<p><img src="support/figs/rss.png"> Quer ficar atualizado? Assine o
feed comentário para <a id="chapterfeed" class="feed" href="/feeds/comments/">este capítulo</a>, ou o <a class="feed" href="/feeds/comments/">livro inteiro</a>.</p>
<p>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart e John Goerzen.
Esta obra está licenciada sob uma <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons
Attribution-Noncommercial 3.0 License</a>. Ícones por <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>. </p>
</div>

<div class="navfooter">
<table summary="Navigation footer" width="100%">
  <tbody>
    <tr>
      <td align="left" width="40%"><a accesskey="p" href="types-and-functions.html">Anterior</a>&nbsp;</td>
      <td align="center" width="20%">&nbsp;</td>
      <td align="right" width="40%">&nbsp;<a accesskey="n" href="functional-programming.html">Próximo</a></td>
    </tr>
    <tr>
      <td align="left" valign="top" width="40%">Capítulo&nbsp;2.&nbsp;Tipos
e Funções&nbsp;</td>
      <td align="center" width="20%"><a accesskey="h" href="index.html">Casa</a></td>
      <td align="right" valign="top" width="40%">&nbsp;Capítulo 4.
Programação funcional</td>
    </tr>
  </tbody>
</table>
</div>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">_uacct = "UA-1805907-3"; urchinTracker();</script>
</body></html>