<HTML><HEAD><META http-equiv='Content-Type' content='text/html; charset=UTF-8'>
<TITLE>Capítulo <function>. Programação funcional</TITLE>
<link rel='stylesheet' href='support/styles.css' type='text/css'><link rel='start' href='index.html' title='Real World Haskell'><link rel='up' href='index.html' title='Real World Haskell'>
<link rel='prev' href='types-and-functions.html' title='Capítulo 3. Definir os tipos, racionalizando as funções'><link rel='next' href='writing-a-library-working-with-json-data.html' title='Capítulo 5. Escrever uma biblioteca: trabalhar com dados JSON'>
<link rel='alternate' type='application/atom+xml' title='Comments' href='/feeds/comments/'><link rel='shortcut icon' type='image/png' href='support/figs/favicon.png'><script type='text/javascript' src='support/jquery-min.js'></script><script type='text/javascript' src='support/form.js'></script><script type='text/javascript' src='support/hsbook.js'></script></HEAD><BODY bgcolor='white' text='black' link='#0000FF' vlink='#840084' alink='#0000FF'><DIV class='navheader'><H2 class='booktitle'><A href='http://book.realworldhaskell.org/'>Real World Haskell</A><SPAN class='authors'>de Bryan O'Sullivan, Don Stewart, e John Goerzen</SPAN></H2></DIV>
<DIV class='navheader'><TABLE width='100%' summary='Navigation header'><TBODY><TR><TH colspan='3' align='center'>Capítulo <function>. Programação funcional</TH></TR><TR><TD width='20%' align='left'><A accesskey='p' href='types-and-functions.html'>Anterior</A>&nbsp;</TD><TH width='60%' align='center'>&nbsp;</TH><TD width='20%' align='right'>&nbsp;<A accesskey='n' href='writing-a-library-working-with-json-data.html'>Próximo</A></TD></TR></TBODY></TABLE></DIV>


<DIV class='chapter' lang='pt' id='fp'><DIV class='titlepage'><DIV><DIV><H2 class='title'>Capítulo <function>. Programação funcional</H2></DIV></DIV></DIV>


<DIV class='toc' style='position: static; '><P style='opacity: 0.35; '><B>Índice analítico</B></P><P style='display: block; '><A onclick='return loadAllComments()'>Carregue todas as observações (<B>devagar</B>)</A></P><DL style='display: block; '>
<DT><SPAN class='sect1'><A href='#fp.thinking'>Pensando no Haskell</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.framework'>Um framework de linha de comando simples</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.splitlines'>Warming up: Separação das linhas de texto portavel</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#id589136'>Um programa de conversão de fim de linha</A></SPAN></DT>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.infix'>Funções infix</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.lists'>Trabalhar com as listas</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#fp.lists.basic'>Manipulação de listas básica</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.lists.safe'>Trabalhar segura e saudavelmente a com funções crashy</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id590211'>Funções parcial e total</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id590283'>Mais manipulações de listas simples</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id590714'>Trabalhar com sublistas</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.list.search'>Buscando listas</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id591412'>Trabalhando com muitas listas ao mesmo tempo</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.lists.strings'>Funções especiais de manipulação de string</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id591678'>Exercícios</A></SPAN></DT>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.loop'>Como pensar a respeito de loops</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#fp.tailrecursion'>Recursão explícita</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id592265'>Transformando cada peça de input</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id592470'>Mapeando sobre uma lista</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.filter'>Seleção de peças de entrada</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id592937'>Computing uma resposta sobre um conjunto</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.foldl'>A fold esquerda</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id593448'>Por dobras usar folds, maps e filters?</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.foldr.filter'>Folding da direita</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id594142'>Folds esquerdos, preguiça e space leaks</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#fp.fold.exercises'>Exercícios</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id594881'>Leitura complementar</A></SPAN></DT>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.anonymous'>Funções (lambda) anónimos</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.partialapp'>Aplicação da função parcial e currying</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#id596329'>Secções</A></SPAN></DT>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.aspattern'>Padrões As</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.compose'>Reutilização de código através da composição</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#id597329'>Use a cabeça sabiamente</A></SPAN></DT>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.readability'>Dicas para escrever código legível</A></SPAN></DT>
  <DD><DL>
  </DL></DD>
<DT><SPAN class='sect1'><A href='#fp.seq'>Space leaks e avaliação rigorosa</A></SPAN></DT>
  <DD><DL>
  <DT><SPAN class='sect2'><A href='#id597540'>Evitar space leaks com seq</A></SPAN></DT>
  <DT><SPAN class='sect2'><A href='#id597688'>Aprender a usar o seq</A></SPAN></DT>
  </DL></DD>
</DL></DIV>



<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.thinking'>Pensando no Haskell</H2></DIV></DIV></DIV><P id='x_V6'><A name='x_V6'></A>Nossa aprendizagem precoce de Haskell possui dois aspectos distintos. A primeira é chegar a um acordo com a mudança de mentalidade da programação imperativa de funcionamento: temos de substituir a programação de nossos hábitos de outras línguas. Fazemos isso não porque as técnicas imperativos são ruins, mas porque, em uma linguagem funcional de outras técnicas de trabalho melhor. <SPAN id='comments_x_V6' class='comment'><A class='commenttoggle' id='toggle_x_V6' pid='x_V6' onclick='return loadComments(&quot;x_V6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_W6'><A name='x_W6'></A>O nosso segundo desafio é aprender a nossa maneira de contornar o Haskell bibliotecas padrão. Como em qualquer linguagem, bibliotecas de funcionar como alavanca, habilitando-nos a multiplicar a nossa solução de problemas de energia. Bibliotecas Haskell tendem a operar em um nível maior de abstração do que aqueles em muitas outras línguas. Precisaremos trabalhar um pouco difícil aprender usar a bibliotecas, mas na troca eles oferecem uma grande quantidade de poder. <SPAN id='comments_x_W6' class='comment'><A class='commenttoggle' id='toggle_x_W6' pid='x_W6' onclick='return loadComments(&quot;x_W6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_X6'><A name='x_X6'></A>Neste capítulo, vamos introduzir uma série de técnicas de programação funcionais. Nós vamos recorrer a exemplos de linguagens imperativas destacar a mudança no pensamento que vamos precisar fazer. Como o fazemos, nós vamos caminhar por alguns dos fundamentos da norma de bibliotecas Haskell. Nós também intermitentemente cobrir algumas línguas mais recursos no caminho. <SPAN id='comments_x_X6' class='comment'><A class='commenttoggle' id='toggle_x_X6' pid='x_X6' onclick='return loadComments(&quot;x_X6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.framework'>Um framework de linha de comando simples</H2></DIV></DIV></DIV><P id='x_VC1'><A name='x_VC1'></A>Na maioria deste capítulo, que incidirá nos com o código que tem qualquer interacção com o mundo exterior. Manter o foco no código prático, vamos começar por desenvolver uma passagem entre o nosso código “<SPAN class='quote'>puro</SPAN>” eo mundo lá fora. O nosso quadro simplesmente lê o conteúdo de um arquivo, aplicar uma função para o arquivo e escreve o resultado para outro arquivo. <SPAN id='comments_x_VC1' class='comment'><A class='commenttoggle' id='toggle_x_VC1' pid='x_VC1' onclick='return loadComments(&quot;x_VC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='InteractWith.hs:main'></A><PRE id='InteractWith.hs:main' class='programlisting'><code class='codecomment'>-- arquivo: ca04/InteraçãoCom.hs
-- Salvar esta em um arquivo de fonte, por exemplo InteraçãoCom.hs</code>
import System.Environment(getArgs)

interaçãoCom função nomeArquivoInput nomeArquivoOutput = do
  input &lt;-readFile nomeArquivoInput
  writeFile nomeArquivoOutput (função input)

main = mainCom funçãoMea
  where mainCom função = do
          entradas &lt;-getArgs
          case entradas of
            [input,output]-&gt; interaçãoCom função input output
            _-&gt; putStrLn "erro: exactamente dois argumentos necessários"

        <code class='codecomment'>-- substitua "id" com o nome da nossa função inferior</code>
        funçãoMea = id</PRE><SPAN id='comments_InteractWith.hs:main' class='comment'><A class='commenttoggle' id='toggle_InteractWith.hs:main' pid='InteractWith.hs:main' onclick='return loadComments(&quot;InteractWith.hs:main&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_WC1'><A name='x_WC1'></A>Esta é a todos nós necessitamos de escrever simples, mas completa, de arquivo de programas de processamento. Esse é um programa completos. Nós podemos compilá-lo para um executável chamado <CODE class='filename'>InteraçãoCom</CODE>como se segue. <SPAN id='comments_x_WC1' class='comment'><A class='commenttoggle' id='toggle_x_WC1' pid='x_WC1' onclick='return loadComments(&quot;x_WC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id588357'></A><PRE id='id588357' class='screen'><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>ghc --make InteraçãoCom
</CODE></STRONG><code class='machineMsg'>[1 of 1] Compiling Main             ( InteraçãoCom.hs, InteraçãoCom.o )
Linking InteraçãoCom ...
</code></PRE> <SPAN id='comments_id588357' class='comment'><A class='commenttoggle' id='toggle_id588357' onclick='return loadComments(&quot;id588357&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_XC1'><A name='x_XC1'></A>Se executar este programa desde o reservatório ou comandos, que aceita duas nomes de arquivos: o nome da arquivo de ler, o nome e de um arquivo para escrever. <SPAN id='comments_x_XC1' class='comment'><A class='commenttoggle' id='toggle_x_XC1' pid='x_XC1' onclick='return loadComments(&quot;x_XC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id588382'></A><PRE id='id588382' class='screen'><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>./InteraçãoCom
</CODE></STRONG><code class='machineMsg'>erro: exactamente dois argumentos necessários
</code><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>./InteraçãoCom oláIn.txt oláOut.txt
</CODE></STRONG><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>cat oláIn.txt
</CODE></STRONG><code class='machineMsg'>Olá mundo
</code><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>cat oláOut.txt
</CODE></STRONG><code class='machineMsg'>Olá mundo
</code></PRE> <SPAN id='comments_id588382' class='comment'><A class='commenttoggle' id='toggle_id588382' onclick='return loadComments(&quot;id588382&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_YC1'><A name='x_YC1'></A>Algumas das notação no nosso arquivo fonte é nova. O que introduz uma palavra-chave bloco de ações que podem provocar efeitos no mundo real, tais como a leitura ou a escrita de um arquivo. O operador <CODE class='code'>&lt;-</CODE>é o equivalente de uma atribuição dentro um bloco <CODE class='literal'>do</CODE>. Esta é a explicação bastante começar nós começou. Falaremos em mais detalhe muito sobre esses detalhes do notação e de I/O em geral, em <A class='xref' href='io.html' title='Capítulo&nbsp;7,&nbsp;I/O'>Capítulo&nbsp;7, <I>I/O</I></A>. <SPAN id='comments_x_YC1' class='comment'><A class='commenttoggle' id='toggle_x_YC1' pid='x_YC1' onclick='return loadComments(&quot;x_YC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_ZC1'><A name='x_ZC1'></A>Quando se deseja testar uma função que não pode falar com o mundo lá fora, que simplesmente substitui o nome <CODE class='function'>id</CODE>ino código acima com o nome da função que queremos testar. Qualquer que seja nossa função faz, ele precisa ter o tipo de <SPAN class='type'>String-&gt;String</SPAN>: em outras palavras, ela deve aceitar uma string e retornam uma string. <SPAN id='comments_x_ZC1' class='comment'><A class='commenttoggle' id='toggle_x_ZC1' pid='x_ZC1' onclick='return loadComments(&quot;x_ZC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.splitlines'>Warming up: Separação das linhas de texto portavel</H2></DIV></DIV></DIV><P id='x_Y6'><A name='x_Y6'></A>Haskell provê uma função built-in de <CODE class='function'>lines</CODE>, que deixa nós dividir uma string de texto em linha de limites. Ele retorna um lista das cadeias de caracteres com terminação de linha omitida. <SPAN id='comments_x_Y6' class='comment'><A class='commenttoggle' id='toggle_x_Y6' pid='x_Y6' onclick='return loadComments(&quot;x_Y6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:lines'></A><PRE id='splitlines.ghci:lines' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t lines
</CODE></STRONG><code class='machineMsg'>lines :: String -&gt; [String]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>lines "linha 1\nlinha 2"
</CODE></STRONG><code class='machineMsg'>["linha 1","linha 2"]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>lines "foo\n\nbar\n"
</CODE></STRONG><code class='machineMsg'>["foo","","bar"]
</code></PRE> <SPAN id='comments_splitlines.ghci:lines' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:lines' onclick='return loadComments(&quot;splitlines.ghci:lines&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_Z6'><A name='x_Z6'></A>Embora de <CODE class='function'>lines</CODE>parece úteis, se baseia em nós ler um arquivo de em “<SPAN class='quote'>modo texto</SPAN>” para o trabalho. Modo texto é uma característica comum a muitas linguagens: proporciona um comportamento especial quando lêem e escrevem arquivos no Windows. Quando se lê um arquivo em modo de texto, o arquivo de biblioteca I/O traduz a fim de linha de seqüência <CODE class='code'>"\r\n"</CODE>(retorno do carro seguido por nova linha) à <CODE class='code'>"\n"</CODE>(nova linha sozinho), e faz o inverso quando Escrever um arquivo. Em semelhante sistemas do Unix, o modo de texto não exerce qualquer translação. Como resultado desta diferença, se ler um arquivo de uma plataforma que estava escrito em outro o final de linha devem se tornar uma bagunça. (Ambos <CODE class='function'>readFile</CODE>e <CODE class='function'>writeFile</CODE>operar em modo texto). <SPAN id='comments_x_Z6' class='comment'><A class='commenttoggle' id='toggle_x_Z6' pid='x_Z6' onclick='return loadComments(&quot;x_Z6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:lines.cr'></A><PRE id='splitlines.ghci:lines.cr' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>lines "a\r\nb"
</CODE></STRONG><code class='machineMsg'>["a\r","b"]
</code></PRE> <SPAN id='comments_splitlines.ghci:lines.cr' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:lines.cr' onclick='return loadComments(&quot;splitlines.ghci:lines.cr&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_a6'><A name='x_a6'></A>A função <CODE class='function'>lines</CODE>só divide em caracteres de nova linha, deixando retorna carro balançando nas extremidades das linhas de. Se ler um arquivo de texto gerou-Windows em um sistema Linux ou caixa Unix nós vamos arrastando carro retorna no final da cada uma delas. <SPAN id='comments_x_a6' class='comment'><A class='commenttoggle' id='toggle_x_a6' pid='x_a6' onclick='return loadComments(&quot;x_a6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_b6'><A name='x_b6'></A>Nós confortavelmente usado o suporte “<SPAN class='quote'>universal newline</SPAN>” do Python apoio a anos: trata isso de forma transparente Unix e Windows linha que termina as convenções para nós. Gostaríamos de oferecer algo similar em Haskell. <SPAN id='comments_x_b6' class='comment'><A class='commenttoggle' id='toggle_x_b6' pid='x_b6' onclick='return loadComments(&quot;x_b6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_d6'><A name='x_d6'></A>Uma vez que estamos ainda cedo em nossa carreira de leitura de código Haskell, vamos discutir nossa aplicação em Haskell bastante detalhe alguns. <SPAN id='comments_x_d6' class='comment'><A class='commenttoggle' id='toggle_x_d6' pid='x_d6' onclick='return loadComments(&quot;x_d6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SplitLines.hs:splitLines.type'></A><PRE id='SplitLines.hs:splitLines.type' class='programlisting'><code class='codecomment'>-- arquivo: ca04/LinhasSeparadas.hs</code>
linhasSeparadas:: String-&gt; [String]</PRE><SPAN id='comments_SplitLines.hs:splitLines.type' class='comment'><A class='commenttoggle' id='toggle_SplitLines.hs:splitLines.type' pid='SplitLines.hs:splitLines.type' onclick='return loadComments(&quot;SplitLines.hs:splitLines.type&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_aC1'><A name='x_aC1'></A>A assinatura do tipo de nossa função indica que aceita uma única corda, o conteúdo de um arquivo com alguma linha que termina convenção desconhecido. Ele retorna a lista de seqüências de caracteres, que representa cada linha do processo. <SPAN id='comments_x_aC1' class='comment'><A class='commenttoggle' id='toggle_x_aC1' pid='x_aC1' onclick='return loadComments(&quot;x_aC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SplitLines.hs:splitLines'></A><PRE id='SplitLines.hs:splitLines' class='programlisting'><code class='codecomment'>-- arquivo: ca04/LinhasSeparadas.hs</code>
linhasSeparadas [] = []
linhasSeparadas letras =
    let (prefixo,sufixo) = break éSeparadorDeLinhas letras
    in prefixo : case sufixo of 
        ('\r':'\n':resto)-&gt; linhasSeparadas resto
        ('\r':resto)-&gt; linhasSeparadas resto
        ('\n':resto)-&gt; linhasSeparadas resto
        _-&gt; []

éSeparadorDeLinhas letra = 
    letra == '\r' || letra == '\n'</PRE><SPAN id='comments_SplitLines.hs:splitLines' class='comment'><A class='commenttoggle' id='toggle_SplitLines.hs:splitLines' pid='SplitLines.hs:splitLines' onclick='return loadComments(&quot;SplitLines.hs:splitLines&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_bC1'><A name='x_bC1'></A>Antes de nos aprofundarmos em detalhes, como primeira notícia que se organizaram nosso Código. Nós apresentamos as partes importantes de código em primeiro lugar, mantendo a definição de <CODE class='function'>éSeparadorDeLinhas</CODE>depois. Porque demos a função auxiliar um nome readable, que podemos adivinhar o que ele faz ainda antes temos lido, que facilita um “<SPAN class='quote'>fluxo</SPAN>” suave de lendo de código. <SPAN id='comments_x_bC1' class='comment'><A class='commenttoggle' id='toggle_x_bC1' pid='x_bC1' onclick='return loadComments(&quot;x_bC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_e6'><A name='x_e6'></A>O Prelude define uma função chamada <CODE class='function'>break</CODE>que podemos usar para particionar um de lista em duas partes. É preciso uma função que seu primeiro parâmetro. Essa função deverá examinar elementos de lista, e retorna uma <SPAN class='type'>Bool</SPAN>indicar se deseja interromper a lista nesse momento. A função <CODE class='function'>break</CODE>retorna um par, que consiste no sublista consumidos antes do predicado retornado <CODE class='code'>True</CODE>(o <SPAN class='emphasis'><EM>prefixo</EM></SPAN>), eo resto da lista (o <SPAN class='emphasis'><EM>sufixo</EM></SPAN>). <SPAN id='comments_x_e6' class='comment'><A class='commenttoggle' id='toggle_x_e6' pid='x_e6' onclick='return loadComments(&quot;x_e6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:break'></A><PRE id='splitlines.ghci:break' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>break odd [2,4,5,6,8]
</CODE></STRONG><code class='machineMsg'>([2,4],[5,6,8])
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.Char
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>break isUpper "éMaiuscula"
</CODE></STRONG><code class='machineMsg'>("é","Maiuscula")
</code></PRE> <SPAN id='comments_splitlines.ghci:break' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:break' onclick='return loadComments(&quot;splitlines.ghci:break&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_g6'><A name='x_g6'></A>Uma vez que só precisa corresponder a um único transporte de retorno ou nova linha de cada vez, analisar um elemento da lista ao mesmo tempo é bom o suficiente para as necessidades. <SPAN id='comments_x_g6' class='comment'><A class='commenttoggle' id='toggle_x_g6' pid='x_g6' onclick='return loadComments(&quot;x_g6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_cC1'><A name='x_cC1'></A>A equação primeira de <CODE class='function'>linhasSeparadas</CODE>indica que, se coincidir com uma seqüência vazia, não temos nenhum trabalho ainda a fazer. <SPAN id='comments_x_cC1' class='comment'><A class='commenttoggle' id='toggle_x_cC1' pid='x_cC1' onclick='return loadComments(&quot;x_cC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_h6'><A name='x_h6'></A>Na equação do segundo, aplicar primeiro <CODE class='function'>break</CODE>a nossa string de entrada. O prefixo é a substring antes de um terminador de linha, e sufixo é o restante do fio. O sufixo incluirão o terminador linha é eventualmente presentes.<SPAN id='comments_x_h6' class='comment'><A class='commenttoggle' id='toggle_x_h6' pid='x_h6' onclick='return loadComments(&quot;x_h6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_dC1'><A name='x_dC1'></A>A expressão “<SPAN class='quote'><CODE class='code'>prefixo :</CODE></SPAN>” indica-nos que devemos adicionar o valor <CODE class='varname'>prefixo</CODE>para a frente a lista das linhas. Em seguida, use uma expressão de <CODE class='literal'>case</CODE>para inspecionar os sufixos, assim que nós podemos decidir o que fazer. O resultado da expressão <CODE class='literal'>case</CODE>será utilizada como argumento segundo o construtor da lista <CODE class='function'>(:)</CODE>. <SPAN id='comments_x_dC1' class='comment'><A class='commenttoggle' id='toggle_x_dC1' pid='x_dC1' onclick='return loadComments(&quot;x_dC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_i6'><A name='x_i6'></A>O primeiro padrão corresponde a uma seqüência que começa com um regresso transporte, seguido por uma linha nova. A variável de <CODE class='varname'>resto</CODE>está ligado ao restante da cadeia. Os outros padrões são parecidos, então elas devem ser fácil de acompanhar. <SPAN id='comments_x_i6' class='comment'><A class='commenttoggle' id='toggle_x_i6' pid='x_i6' onclick='return loadComments(&quot;x_i6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_k6'><A name='x_k6'></A>Uma descrição em prosa de uma função Haskell não necessariamente fáceis de seguir. Podemos obter uma melhor compreensão por parte entrando <SPAN class='command'><STRONG>ghci</STRONG></SPAN>, e observar o comportamento da função em circunstâncias diferentes. <SPAN id='comments_x_k6' class='comment'><A class='commenttoggle' id='toggle_x_k6' pid='x_k6' onclick='return loadComments(&quot;x_k6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_l6'><A name='x_l6'></A>Começamos a separação por uma seqüência que não contém qualquer separadores de linhas. <SPAN id='comments_x_l6' class='comment'><A class='commenttoggle' id='toggle_x_l6' pid='x_l6' onclick='return loadComments(&quot;x_l6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:splitLines.foo'></A><PRE id='splitlines.ghci:splitLines.foo' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>linhasSeparadas "foo"
</CODE></STRONG><code class='machineMsg'>["foo"]
</code></PRE> <SPAN id='comments_splitlines.ghci:splitLines.foo' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:splitLines.foo' onclick='return loadComments(&quot;splitlines.ghci:splitLines.foo&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_m6'><A name='x_m6'></A>Aqui a nossa aplicação da <CODE class='function'>break</CODE>nunca encontra um terminador de linha, assim que o sufixo retorna vazio. <SPAN id='comments_x_m6' class='comment'><A class='commenttoggle' id='toggle_x_m6' pid='x_m6' onclick='return loadComments(&quot;x_m6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:break.foo'></A><PRE id='splitlines.ghci:break.foo' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>break éSeparadorDeLinhas "foo"
</CODE></STRONG><code class='machineMsg'>("foo","")
</code></PRE> <SPAN id='comments_splitlines.ghci:break.foo' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:break.foo' onclick='return loadComments(&quot;splitlines.ghci:break.foo&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_n6'><A name='x_n6'></A>A expressão <CODE class='literal'>case</CODE>em <CODE class='function'>linhasSeparadas</CODE>como tal devem ser combinados no quarto ramo e estamos acabados. E quanto um caso um pouco mais interessante? <SPAN id='comments_x_n6' class='comment'><A class='commenttoggle' id='toggle_x_n6' pid='x_n6' onclick='return loadComments(&quot;x_n6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:splitLines.foobar'></A><PRE id='splitlines.ghci:splitLines.foobar' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>linhasSeparadas "foo\r\nbar"
</CODE></STRONG><code class='machineMsg'>["foo","bar"]
</code></PRE> <SPAN id='comments_splitlines.ghci:splitLines.foobar' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:splitLines.foobar' onclick='return loadComments(&quot;splitlines.ghci:splitLines.foobar&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_o6'><A name='x_o6'></A>Nossa primeira aplicação de <CODE class='function'>break</CODE>nos oferece um sufixo não vazio. <SPAN id='comments_x_o6' class='comment'><A class='commenttoggle' id='toggle_x_o6' pid='x_o6' onclick='return loadComments(&quot;x_o6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:break.foobar'></A><PRE id='splitlines.ghci:break.foobar' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>break éSeparadorDeLinhas "foo\r\nbar"
</CODE></STRONG><code class='machineMsg'>("foo","\r\nbar")
</code></PRE> <SPAN id='comments_splitlines.ghci:break.foobar' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:break.foobar' onclick='return loadComments(&quot;splitlines.ghci:break.foobar&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_p6'><A name='x_p6'></A>Devido o sufixo começa com um regresso transporte, seguido de uma nova linha, que correspondem a primeira sucursal de a expressão <CODE class='literal'>case</CODE>. Isto dá-nos <CODE class='varname'>prefixo</CODE>ligado a <CODE class='code'>"foo"</CODE>, e <CODE class='varname'>sufixo</CODE>ligado a <CODE class='code'>"bar"</CODE>. Nós aplicar <CODE class='function'>linhasSeparadas</CODE>recursivamente, desta vez no <CODE class='code'>"bar"</CODE>sozinho. <SPAN id='comments_x_p6' class='comment'><A class='commenttoggle' id='toggle_x_p6' pid='x_p6' onclick='return loadComments(&quot;x_p6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:splitLines.bar'></A><PRE id='splitlines.ghci:splitLines.bar' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>linhasSeparadas "bar"
</CODE></STRONG><code class='machineMsg'>["bar"]
</code></PRE> <SPAN id='comments_splitlines.ghci:splitLines.bar' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:splitLines.bar' onclick='return loadComments(&quot;splitlines.ghci:splitLines.bar&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_q6'><A name='x_q6'></A>O resultado é que vamos construir a lista cuja cabeça é <CODE class='code'>"foo"</CODE>e cuja cauda é <CODE class='code'>["bar"]</CODE>. <SPAN id='comments_x_q6' class='comment'><A class='commenttoggle' id='toggle_x_q6' pid='x_q6' onclick='return loadComments(&quot;x_q6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='splitlines.ghci:cons'></A><PRE id='splitlines.ghci:cons' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"foo" : ["bar"]
</CODE></STRONG><code class='machineMsg'>["foo","bar"]
</code></PRE> <SPAN id='comments_splitlines.ghci:cons' class='comment'><A class='commenttoggle' id='toggle_splitlines.ghci:cons' onclick='return loadComments(&quot;splitlines.ghci:cons&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_eC1'><A name='x_eC1'></A>Este tipo de experimentos com <SPAN class='command'><STRONG>ghci</STRONG></SPAN>Este tipo de experimentos com <SPAN class='command'><STRONG>ghci</STRONG></SPAN>, por isso tendem a gravação funciona mais pequenas. Esta pode ainda ajudar a legibilidade do código. <SPAN id='comments_x_eC1' class='comment'><A class='commenttoggle' id='toggle_x_eC1' pid='x_eC1' onclick='return loadComments(&quot;x_eC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_fC1'><A name='x_fC1'></A>Este estilo de criar e de reutilização de partes pequenas, poderoso do código é uma parte fundamental da programação funcional. <SPAN id='comments_x_fC1' class='comment'><A class='commenttoggle' id='toggle_x_fC1' pid='x_fC1' onclick='return loadComments(&quot;x_fC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id589136'>Um programa de conversão de fim de linha</H3></DIV></DIV></DIV><P id='x_gC1'><A name='x_gC1'></A>Deixe de ligar a nossa função <CODE class='function'>linhasSeparadas</CODE>em âmbito pouco que escreveu anteriormente. Faça um cópia do arquivo de fonte <CODE class='filename'>InteraçãoCom.hs</CODE>; vamos chamar o arquivo novo <CODE class='filename'>LinhasAdaptadas.hs</CODE>. Adicione a função <CODE class='function'>linhasSeparadas</CODE>para o novo arquivo de origem. Desde a nossa função precisa elaborar um único <SPAN class='type'>String</SPAN>, temos que costurar a lista de linhas de volta. O Prelude fornece uma função <CODE class='function'>unlines</CODE>que concatena a lista das cadeias, acrescentando uma nova linha para o final de cada um. <SPAN id='comments_x_gC1' class='comment'><A class='commenttoggle' id='toggle_x_gC1' pid='x_gC1' onclick='return loadComments(&quot;x_gC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SplitLines.hs:fixLines'></A><PRE id='SplitLines.hs:fixLines' class='programlisting'><code class='codecomment'>-- arquivo: ch04/LinhasAdaptadas.hs</code>
linhasAdaptadas:: String-&gt; String
linhasAdaptadas input = unlines (splitLines input)</PRE><SPAN id='comments_SplitLines.hs:fixLines' class='comment'><A class='commenttoggle' id='toggle_SplitLines.hs:fixLines' pid='SplitLines.hs:fixLines' onclick='return loadComments(&quot;SplitLines.hs:fixLines&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_hC1'><A name='x_hC1'></A>Se substitui a função <CODE class='function'>id</CODE>com <CODE class='function'>linhasAdaptadas</CODE>, podemos compilar um executável que irá converter um arquivo de texto para a linha materna nosso sistema termina. <SPAN id='comments_x_hC1' class='comment'><A class='commenttoggle' id='toggle_x_hC1' pid='x_hC1' onclick='return loadComments(&quot;x_hC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id589217'></A><PRE id='id589217' class='screen'><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>ghc --make LinhasAdaptadas
</CODE></STRONG><code class='machineMsg'>[1 of 1] Compiling Main             ( LinhasAdaptadas.hs, LinhasAdaptadas.o )
Linking LinhasAdaptadas ...
</code></PRE> <SPAN id='comments_id589217' class='comment'><A class='commenttoggle' id='toggle_id589217' onclick='return loadComments(&quot;id589217&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_iC1'><A name='x_iC1'></A>Se você é em um sistema Windows, localizar e transferir um arquivo texto criado em um sistema Unix (por exemplo <A class='ulink' href='http://www.gnu.org/licenses/gpl-3.0.txt' target='_top'>gpl-3.0.txt</A>). Abrir no editor texto padrão Notepad. As linhas devem correr tudo junto, fazendo o arquivo praticamente ilegível. Process o ficheiro utilizando o <SPAN class='command'><STRONG>LinhasAdaptadas</STRONG></SPAN>mando criado e abra o arquivo de saída no Bloco de notas. As terminações de linha agora deve ser fixada acima. <SPAN id='comments_x_iC1' class='comment'><A class='commenttoggle' id='toggle_x_iC1' pid='x_iC1' onclick='return loadComments(&quot;x_iC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_jC1'><A name='x_jC1'></A>Em semelhantes os sistemas Unix, o padrão pagers e editores esconder terminações de linha de Windows. Isto faz mais difícil de verificar se <SPAN class='command'><STRONG>LinhasAdaptadas</STRONG></SPAN>é realmente eliminá-los. Aqui estão uns poucos comandos que deve ajudar. <SPAN id='comments_x_jC1' class='comment'><A class='commenttoggle' id='toggle_x_jC1' pid='x_jC1' onclick='return loadComments(&quot;x_jC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id589270'></A><PRE id='id589270' class='screen'><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>file gpl-3.0.txt
</CODE></STRONG><code class='machineMsg'>gpl-3.0.txt: ASCII English text
</code><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>unix2dos gpl-3.0.txt
</CODE></STRONG><code class='machineMsg'>unix2dos: converting file gpl-3.0.txt to DOS format ...
</code><CODE class='prompt'>sistema&gt; </CODE><STRONG class='userinput'><CODE>file gpl-3.0.txt
</CODE></STRONG><code class='machineMsg'>gpl-3.0.txt: ASCII English text, with CRLF line terminators
</code></PRE> <SPAN id='comments_id589270' class='comment'><A class='commenttoggle' id='toggle_id589270' onclick='return loadComments(&quot;id589270&quot;)' href='comment: add'>?? comments</A></SPAN></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.infix'>Funções infix</H2></DIV></DIV></DIV><P id='x_K6'><A name='x_K6'></A>Normalmente, quando se define ou aplicar uma função em Haskell, nós escrevemos o nome da função, seguido por seus argumentos. Esta notação é chamada de <SPAN class='emphasis'><EM>prefixo</EM></SPAN>, porque o nome da função vem perante seus argumentos. <SPAN id='comments_x_K6' class='comment'><A class='commenttoggle' id='toggle_x_K6' pid='x_K6' onclick='return loadComments(&quot;x_K6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_Rh'><A name='x_Rh'></A>Caso uma função ou construtor necessários dois ou mais discussões, temos a opção de utilização em formulário <SPAN class='emphasis'><EM>infixo</EM></SPAN>, onde colocar <SPAN class='emphasis'><EM>entre</EM></SPAN>sua argumentos e segundo antes. O que nos permite usar funções como operador infixo. <SPAN id='comments_x_Rh' class='comment'><A class='commenttoggle' id='toggle_x_Rh' pid='x_Rh' onclick='return loadComments(&quot;x_Rh&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_L6'><A name='x_L6'></A>Definir ou aplicar uma função de construtor ou o valor usando a notação infixo, nós coloque seu nome nos personagens backtick (também conhecido como backquotes). Aqui estão as definições infixo simples de uma função e um tipo. <SPAN id='comments_x_L6' class='comment'><A class='commenttoggle' id='toggle_x_L6' pid='x_L6' onclick='return loadComments(&quot;x_L6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Plus.hs:plus'></A><PRE id='Plus.hs:plus' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Plus.hs</code>
e `plus` d = e + d

data e `Par` d = e `Par` d
                 deriving Show
<code class='codecomment'>-- podemos usar o construtor prefixo ou infixo</code>
foo= Par 1 2
bar= True `Par` "quux"</PRE><SPAN id='comments_Plus.hs:plus' class='comment'><A class='commenttoggle' id='toggle_Plus.hs:plus' pid='Plus.hs:plus' onclick='return loadComments(&quot;Plus.hs:plus&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_M6'><A name='x_M6'></A>Dado que a notação infixa é meramente uma conveniência sintático, não muda a função de comportamento um. <SPAN id='comments_x_M6' class='comment'><A class='commenttoggle' id='toggle_x_M6' pid='x_M6' onclick='return loadComments(&quot;x_M6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='infix.ghci:plus'></A><PRE id='infix.ghci:plus' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>1 `plus` 2
</CODE></STRONG><code class='machineMsg'>3
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>plus 1 2
</CODE></STRONG><code class='machineMsg'>3
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>True `Par` "uma coisa"
</CODE></STRONG><code class='machineMsg'>True `Par` "uma coisa"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>Par True "uma coisa"
</CODE></STRONG><code class='machineMsg'>True `Par` "uma coisa"
</code></PRE> <SPAN id='comments_infix.ghci:plus' class='comment'><A class='commenttoggle' id='toggle_infix.ghci:plus' onclick='return loadComments(&quot;infix.ghci:plus&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_N6'><A name='x_N6'></A>A notação Infix pode frequentemente ajudar legibilidade. De exemplo Prelude define uma função, <CODE class='function'>elem</CODE>, que indicam se há um valor presente em um de lista. Se usarmos <CODE class='function'>elem</CODE>com anotação de prefixo, é bastante fácil de ler. <SPAN id='comments_x_N6' class='comment'><A class='commenttoggle' id='toggle_x_N6' pid='x_N6' onclick='return loadComments(&quot;x_N6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='infix.ghci:prefix'></A><PRE id='infix.ghci:prefix' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>elem 'a' "Macumba"
</CODE></STRONG><code class='machineMsg'>True
</code></PRE> <SPAN id='comments_infix.ghci:prefix' class='comment'><A class='commenttoggle' id='toggle_infix.ghci:prefix' onclick='return loadComments(&quot;infix.ghci:prefix&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_Q6'><A name='x_Q6'></A>Se vamos mudar a infixo registo, o código fica até mais fácil de entender. É agora claro que estamos verificando se o valor à esquerda está presente na lista da certo. <SPAN id='comments_x_Q6' class='comment'><A class='commenttoggle' id='toggle_x_Q6' pid='x_Q6' onclick='return loadComments(&quot;x_Q6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='infix.ghci:infix'></A><PRE id='infix.ghci:infix' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>3 `elem` [1,2,4,8]
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_infix.ghci:infix' class='comment'><A class='commenttoggle' id='toggle_infix.ghci:infix' onclick='return loadComments(&quot;infix.ghci:infix&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_kC1'><A name='x_kC1'></A>Vemos uma expressiva melhora mais com algumas funções úteis da módulo <CODE class='code'>Data.List</CODE>. A função <CODE class='function'>isPrefixOf</CODE>diz-nos se numa lista coincide com o começo de outra. <SPAN id='comments_x_kC1' class='comment'><A class='commenttoggle' id='toggle_x_kC1' pid='x_kC1' onclick='return loadComments(&quot;x_kC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='infix.ghci:isPrefixOf'></A><PRE id='infix.ghci:isPrefixOf' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"foo" `isPrefixOf` "foobar"
</CODE></STRONG><code class='machineMsg'>True
</code></PRE> <SPAN id='comments_infix.ghci:isPrefixOf' class='comment'><A class='commenttoggle' id='toggle_infix.ghci:isPrefixOf' onclick='return loadComments(&quot;infix.ghci:isPrefixOf&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_lC1'><A name='x_lC1'></A>As funções <CODE class='function'>isInfixOf</CODE>e <CODE class='function'>isSuffixOf</CODE>corresponder qualquer lugar em um lista e em seu final, respectivamente. <SPAN id='comments_x_lC1' class='comment'><A class='commenttoggle' id='toggle_x_lC1' pid='x_lC1' onclick='return loadComments(&quot;x_lC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='infix.ghci:isInfixOf'></A><PRE id='infix.ghci:isInfixOf' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"agulha" `isInfixOf` "palheiro cheio de agulhas"
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"fim" `isSuffixOf` "o fim"
</CODE></STRONG><code class='machineMsg'>True
</code></PRE> <SPAN id='comments_infix.ghci:isInfixOf' class='comment'><A class='commenttoggle' id='toggle_infix.ghci:isInfixOf' onclick='return loadComments(&quot;infix.ghci:isInfixOf&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_R6'><A name='x_R6'></A>Não há e rápida regra rígida que determina quando você deveria usar infixo versus notação de prefixo, apesar de notação de prefixo é muito mais comuns. É a mais melhor escolher o que faz o seu código mais legível em uma determinada situação. <SPAN id='comments_x_R6' class='comment'><A class='commenttoggle' id='toggle_x_R6' pid='x_R6' onclick='return loadComments(&quot;x_R6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><DIV class='note'><TABLE border='0' summary='Note: Cuidados com anotação familiar em um idioma desconhecido'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Note]' src='support/figs/note.png'></TD><TH align='left'>Cuidados com anotação familiar em um idioma desconhecido</TH></TR><TR><TD align='left' valign='top'><P id='x_Sh'><A name='x_Sh'></A>A algumas outras linguagens de programação utilizar backticks mas, apesar das semelhanças visual, a fim de backticks em Haskell não lembram remotamente o seu significado em, por exemplo: Perl, Python, shell scripts ou Unix. <SPAN id='comments_x_Sh' class='comment'><A class='commenttoggle' id='toggle_x_Sh' pid='x_Sh' onclick='return loadComments(&quot;x_Sh&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_S6'><A name='x_S6'></A>A única coisa legal que podemos fazer com backticks em Haskell é envolver-los ao redor do nome da função. Não pode, por exemplo usá-las para incluir a expressão complexa cujo valor é uma função. Pode ser conveniente, se pudéssemos, mas que não é como a linguagem actual. <SPAN id='comments_x_S6' class='comment'><A class='commenttoggle' id='toggle_x_S6' pid='x_S6' onclick='return loadComments(&quot;x_S6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.lists'>Trabalhar com as listas</H2></DIV></DIV></DIV><P id='x_r6'><A name='x_r6'></A>Como o pão ea manteiga da programação funcional, listas de merecer alguma atenção. O prelúdio norma define dezenas de funções para lidar com listas. Muitos destes serão ferramentas indispensáveis, por isso é importante que eles aprendam desde cedo.<SPAN id='comments_x_r6' class='comment'><A class='commenttoggle' id='toggle_x_r6' pid='x_r6' onclick='return loadComments(&quot;x_r6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_PL'><A name='x_PL'></A>Para melhor ou pior, esta secção vai ler um pouco como uma “<SPAN class='quote'>lista suja</SPAN>” de funções. Por apresentar muitas funções de modo ao mesmo tempo? Essas funções são fáceis de aprender e absolutamente ubíqua. Se não temos essa caixa de ferramentas em nossas mãos, vamos acabar perdendo tempo reinventando funções simples que já estão presentes nas bibliotecas padrão;. Então fique com a gente como nós atravessamos a lista o esforço que você vai economizar se ser enorme.<SPAN id='comments_x_PL' class='comment'><A class='commenttoggle' id='toggle_x_PL' pid='x_PL' onclick='return loadComments(&quot;x_PL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_s6'><A name='x_s6'></A>O módulo <CODE class='code'>Data.List</CODE> e o casa lógica “<SPAN class='quote'>real</SPAN>” de todas as funções da lista. O Prelude meramente re-exporta uma grande subconjunto das funções exportadas pela <CODE class='code'>Data.List</CODE>. Diversas funções úteis no <CODE class='code'>Data.List</CODE> <SPAN class='emphasis'><EM>não</EM></SPAN> são re-exportados pelo prelúdio padrão. Ao andarmos funções de lista nas seções que seguem, vamos mencionar explicitamente aqueles que estão apenas em <CODE class='code'>Data.List</CODE>.<SPAN id='comments_x_s6' class='comment'><A class='commenttoggle' id='toggle_x_s6' pid='x_s6' onclick='return loadComments(&quot;x_s6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:Data.List'></A><PRE id='ch04.list.ghci:Data.List' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG></PRE> <SPAN id='comments_ch04.list.ghci:Data.List' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:Data.List' onclick='return loadComments(&quot;ch04.list.ghci:Data.List&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_t6'><A name='x_t6'></A>Como nenhuma dessas funções é complexo ou tem mais de cerca de três linhas de Haskell para escrever, vamos ser breves nas nossas descrições de cada um. De fato, uma aprendizagem útil e rápido exercício é escrever uma definição de cada função depois que você já leu sobre isso.<SPAN id='comments_x_t6' class='comment'><A class='commenttoggle' id='toggle_x_t6' pid='x_t6' onclick='return loadComments(&quot;x_t6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.lists.basic'>Manipulação de listas básica</H3></DIV></DIV></DIV><P id='x_v6'><A name='x_v6'></A>A função <CODE class='function'>length</CODE> nos informa quantos elementos estão em uma lista.<SPAN id='comments_x_v6' class='comment'><A class='commenttoggle' id='toggle_x_v6' pid='x_v6' onclick='return loadComments(&quot;x_v6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:length'></A><PRE id='ch04.list.ghci:length' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t length
</CODE></STRONG><code class='machineMsg'>length :: [a] -&gt; Int
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>length []
</CODE></STRONG><code class='machineMsg'>0
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>length [1,2,3]
</CODE></STRONG><code class='machineMsg'>3
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>length "strings somos listas, também"
</CODE></STRONG><code class='machineMsg'>22
</code></PRE> <SPAN id='comments_ch04.list.ghci:length' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:length' onclick='return loadComments(&quot;ch04.list.ghci:length&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_mC1'><A name='x_mC1'></A>Se você precisa determinar se uma lista está vazia, use a função <CODE class='function'>null</CODE>.<SPAN id='comments_x_mC1' class='comment'><A class='commenttoggle' id='toggle_x_mC1' pid='x_mC1' onclick='return loadComments(&quot;x_mC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:null'></A><PRE id='ch04.list.ghci:null' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t null
</CODE></STRONG><code class='machineMsg'>null :: [a] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>null []
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>null "plugh"
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:null' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:null' onclick='return loadComments(&quot;ch04.list.ghci:null&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_w6'><A name='x_w6'></A>Para acessar o primeiro elemento de uma lista, usamos a função <CODE class='function'>head</CODE>.<SPAN id='comments_x_w6' class='comment'><A class='commenttoggle' id='toggle_x_w6' pid='x_w6' onclick='return loadComments(&quot;x_w6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:head'></A><PRE id='ch04.list.ghci:head' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t head
</CODE></STRONG><code class='machineMsg'>head :: [a] -&gt; a
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>head [1,2,3]
</CODE></STRONG><code class='machineMsg'>1
</code></PRE> <SPAN id='comments_ch04.list.ghci:head' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:head' onclick='return loadComments(&quot;ch04.list.ghci:head&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_x6'><A name='x_x6'></A>O inverso, <CODE class='function'>tail</CODE>, volta tudo, <SPAN class='emphasis'><EM>mas</EM></SPAN> a cabeça de uma lista.<SPAN id='comments_x_x6' class='comment'><A class='commenttoggle' id='toggle_x_x6' pid='x_x6' onclick='return loadComments(&quot;x_x6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:tail'></A><PRE id='ch04.list.ghci:tail' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t tail
</CODE></STRONG><code class='machineMsg'>tail :: [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tail "foo"
</CODE></STRONG><code class='machineMsg'>"oo"
</code></PRE> <SPAN id='comments_ch04.list.ghci:tail' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:tail' onclick='return loadComments(&quot;ch04.list.ghci:tail&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_y6'><A name='x_y6'></A>Outra função, <CODE class='function'>last</CODE>, retorna o último elemento de uma lista.<SPAN id='comments_x_y6' class='comment'><A class='commenttoggle' id='toggle_x_y6' pid='x_y6' onclick='return loadComments(&quot;x_y6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:last'></A><PRE id='ch04.list.ghci:last' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t last
</CODE></STRONG><code class='machineMsg'>last :: [a] -&gt; a
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>last "bar"
</CODE></STRONG><code class='machineMsg'>'r'
</code></PRE> <SPAN id='comments_ch04.list.ghci:last' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:last' onclick='return loadComments(&quot;ch04.list.ghci:last&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_z6'><A name='x_z6'></A>O inverso da <CODE class='function'>last</CODE> é <CODE class='function'>init</CODE>, que retorna uma lista de todos mas o último elemento de sua entrada.<SPAN id='comments_x_z6' class='comment'><A class='commenttoggle' id='toggle_x_z6' pid='x_z6' onclick='return loadComments(&quot;x_z6&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:init'></A><PRE id='ch04.list.ghci:init' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t init
</CODE></STRONG><code class='machineMsg'>init :: [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>init "bar"
</CODE></STRONG><code class='machineMsg'>"ba"
</code></PRE> <SPAN id='comments_ch04.list.ghci:init' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:init' onclick='return loadComments(&quot;ch04.list.ghci:init&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_A7'><A name='x_A7'></A>Várias das funções acima se comportam mal em uma lista vazia, então tome cuidado se você não souber ou não uma lista está vazia. Como se dá sua má conduta tomar?<SPAN id='comments_x_A7' class='comment'><A class='commenttoggle' id='toggle_x_A7' pid='x_A7' onclick='return loadComments(&quot;x_A7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:head.empty'></A><PRE id='ch04.list.ghci:head.empty' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>head []
</CODE></STRONG><code class='machineMsg'>*** Exception: Prelude.head: empty list
</code></PRE> <SPAN id='comments_ch04.list.ghci:head.empty' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:head.empty' onclick='return loadComments(&quot;ch04.list.ghci:head.empty&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_nC1'><A name='x_nC1'></A>Tente cada uma das funções acima, no <SPAN class='command'><STRONG>ghci</STRONG></SPAN>. Quais falhar quando dada uma lista vazia?<SPAN id='comments_x_nC1' class='comment'><A class='commenttoggle' id='toggle_x_nC1' pid='x_nC1' onclick='return loadComments(&quot;x_nC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.lists.safe'>Trabalhar segura e saudavelmente a com funções crashy</H3></DIV></DIV></DIV><P id='x_B7'><A name='x_B7'></A>Quando queremos usar uma função como a <CODE class='function'>head</CODE>, onde sabemos que poderia explodir em nós se passar em uma lista vazia, a tentação pode inicialmente ser forte para verificar o comprimento da lista antes que chamamos de <CODE class='function'>head</CODE>. Vamos construir um exemplo artificial para ilustrar o nosso ponto.<SPAN id='comments_x_B7' class='comment'><A class='commenttoggle' id='toggle_x_B7' pid='x_B7' onclick='return loadComments(&quot;x_B7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='EfficientList.hs:myDumbExample'></A><PRE id='EfficientList.hs:myDumbExample' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ListaEfficiente.hs</code>
meuExemploEstúpido xs = if length xs &gt; 0
                        then head xs
                        else 'Z'</PRE><SPAN id='comments_EfficientList.hs:myDumbExample' class='comment'><A class='commenttoggle' id='toggle_EfficientList.hs:myDumbExample' pid='EfficientList.hs:myDumbExample' onclick='return loadComments(&quot;EfficientList.hs:myDumbExample&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_C7'><A name='x_C7'></A>Se nós estamos vindo de uma linguagem como Perl ou Python, isso pode parecer uma forma perfeitamente natural para escrever este ensaio. Nos bastidores, as listas de Python são matrizes, matrizes e Perl são, assim, matrizes. Então, eles necessariamente saber quanto tempo eles estão, e chamando <CODE class='code'>len(foo)</CODE> ou <CODE class='code'>scalar(@foo)</CODE> é natural coisa perfeitamente fazer. Mas como acontece com muitas outras coisas, não é uma boa idéia cegamente transplante de tal pressuposto em Haskell.<SPAN id='comments_x_C7' class='comment'><A class='commenttoggle' id='toggle_x_C7' pid='x_C7' onclick='return loadComments(&quot;x_C7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_D7'><A name='x_D7'></A>Nós já vimos a definição do tipo de dados algébrica lista muitas vezes, e sei que a lista não armazena seu próprio comprimento explicitamente. Assim, a única maneira de <CODE class='function'>length</CODE> pode operar é andar toda a lista.<SPAN id='comments_x_D7' class='comment'><A class='commenttoggle' id='toggle_x_D7' pid='x_D7' onclick='return loadComments(&quot;x_D7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_E7'><A name='x_E7'></A>Portanto, quando só se preocupam ou não uma lista é vazia, chamada <CODE class='function'>length</CODE> não é uma boa estratégia. Ele pode, potencialmente, fazer um trabalho muito mais do que nós queremos, se a lista que estamos trabalhando é finito. Desde Haskell nos permite facilmente criar listas de infinito, uma utilização descuidada de <CODE class='function'>length</CODE> pode até resultar em um loop infinito.<SPAN id='comments_x_E7' class='comment'><A class='commenttoggle' id='toggle_x_E7' pid='x_E7' onclick='return loadComments(&quot;x_E7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_F7'><A name='x_F7'></A>A função mais adequada para chamar aqui ao contrário é <CODE class='function'>null</CODE>, que é executado em tempo constante. Melhor ainda, usando <CODE class='function'>null</CODE> torna nosso código de indicar o imóvel da lista que realmente nos importa. Aqui estão duas maneiras de se expressar melhor <CODE class='function'>meuExemploEstúpido</CODE>. <SPAN id='comments_x_F7' class='comment'><A class='commenttoggle' id='toggle_x_F7' pid='x_F7' onclick='return loadComments(&quot;x_F7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='EfficientList.hs:mySmartExample'></A><PRE id='EfficientList.hs:mySmartExample' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ListaEfficiente.hs</code>
meuExemploFino xs = if not (null xs)
                    then head xs
                    else 'Z'

meuOutroExemplo (x:_) = x
meuOutroExemplo [] = 'Z'</PRE><SPAN id='comments_EfficientList.hs:mySmartExample' class='comment'><A class='commenttoggle' id='toggle_EfficientList.hs:mySmartExample' pid='EfficientList.hs:mySmartExample' onclick='return loadComments(&quot;EfficientList.hs:mySmartExample&quot;)' href='comments: show / hide'>?? comments</A></SPAN></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id590211'>Funções parcial e total</H3></DIV></DIV></DIV><P id='x_G7'><A name='x_G7'></A>Funções que só têm valores de retorno definido para um subconjunto de entradas válidas são chamadas de funções <SPAN class='emphasis'><EM>parciais</EM></SPAN> (chamar <CODE class='function'>error</CODE> não se qualifica como retornar um valor!). Nós chamamos funções que retornam resultados válidos sobre os seus domínios de entrada inteira funções <SPAN class='emphasis'><EM>totais</EM></SPAN>.<SPAN id='comments_x_G7' class='comment'><A class='commenttoggle' id='toggle_x_G7' pid='x_G7' onclick='return loadComments(&quot;x_G7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_H7'><A name='x_H7'></A>É sempre uma boa idéia para saber se uma função que você está usando é parcial ou total. Chamar uma função parcial, com uma entrada que não pode suportar é provavelmente a maior fonte de simples, os erros evitáveis em programas Haskell.<SPAN id='comments_x_H7' class='comment'><A class='commenttoggle' id='toggle_x_H7' pid='x_H7' onclick='return loadComments(&quot;x_H7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_I7'><A name='x_I7'></A>Alguns programadores Haskell ir tão longe para dar nomes de funções parciais que começam com um prefixo, como <CODE class='code'>unsafe</CODE>, para que eles não podem atirar no próprio pé acidentalmente.<SPAN id='comments_x_I7' class='comment'><A class='commenttoggle' id='toggle_x_I7' pid='x_I7' onclick='return loadComments(&quot;x_I7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_J7'><A name='x_J7'></A>É indiscutivelmente uma deficiência do prelúdio padrão que define um bom número funções parciais “<SPAN class='quote'>inseguros</SPAN>”, como a <CODE class='function'>head</CODE>, sem oferecer equivalentes totais “<SPAN class='quote'>seguros</SPAN>”.<SPAN id='comments_x_J7' class='comment'><A class='commenttoggle' id='toggle_x_J7' pid='x_J7' onclick='return loadComments(&quot;x_J7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id590283'>Mais manipulações de listas simples</H3></DIV></DIV></DIV><P id='x_K7'><A name='x_K7'></A>O nome Haskell para a função “<SPAN class='quote'>append</SPAN>” é <CODE class='function'>(++)</CODE>. <SPAN id='comments_x_K7' class='comment'><A class='commenttoggle' id='toggle_x_K7' pid='x_K7' onclick='return loadComments(&quot;x_K7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:append'></A><PRE id='ch04.list.ghci:append' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t (++)
</CODE></STRONG><code class='machineMsg'>(++) :: [a] -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"foo" ++ "bar"
</CODE></STRONG><code class='machineMsg'>"foobar"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>[] ++ [1,2,3]
</CODE></STRONG><code class='machineMsg'>[1,2,3]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>[True] ++ []
</CODE></STRONG><code class='machineMsg'>[True]
</code></PRE> <SPAN id='comments_ch04.list.ghci:append' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:append' onclick='return loadComments(&quot;ch04.list.ghci:append&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_L7'><A name='x_L7'></A>A função <CODE class='function'>concat</CODE> recebe uma lista de listas, todas do mesmo tipo, e concatena-los em uma única lista.<SPAN id='comments_x_L7' class='comment'><A class='commenttoggle' id='toggle_x_L7' pid='x_L7' onclick='return loadComments(&quot;x_L7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:concat'></A><PRE id='ch04.list.ghci:concat' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t concat
</CODE></STRONG><code class='machineMsg'>concat :: [[a]] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>concat [[1,2,3], [4,5,6]]
</CODE></STRONG><code class='machineMsg'>[1,2,3,4,5,6]
</code></PRE> <SPAN id='comments_ch04.list.ghci:concat' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:concat' onclick='return loadComments(&quot;ch04.list.ghci:concat&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_M7'><A name='x_M7'></A>Ele remove um nível de aninhamento.<SPAN id='comments_x_M7' class='comment'><A class='commenttoggle' id='toggle_x_M7' pid='x_M7' onclick='return loadComments(&quot;x_M7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:concat.multi'></A><PRE id='ch04.list.ghci:concat.multi' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>concat [[[1,2],[3]], [[4],[5],[6]]]
</CODE></STRONG><code class='machineMsg'>[[1,2],[3],[4],[5],[6]]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>concat (concat [[[1,2],[3]], [[4],[5],[6]]])
</CODE></STRONG><code class='machineMsg'>[1,2,3,4,5,6]
</code></PRE> <SPAN id='comments_ch04.list.ghci:concat.multi' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:concat.multi' onclick='return loadComments(&quot;ch04.list.ghci:concat.multi&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_N7'><A name='x_N7'></A>A função <CODE class='function'>reverse</CODE> retorna os elementos de uma lista em ordem inversa.<SPAN id='comments_x_N7' class='comment'><A class='commenttoggle' id='toggle_x_N7' pid='x_N7' onclick='return loadComments(&quot;x_N7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:reverse'></A><PRE id='ch04.list.ghci:reverse' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t reverse
</CODE></STRONG><code class='machineMsg'>reverse :: [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>reverse "foo"
</CODE></STRONG><code class='machineMsg'>"oof"
</code></PRE> <SPAN id='comments_ch04.list.ghci:reverse' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:reverse' onclick='return loadComments(&quot;ch04.list.ghci:reverse&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_O7'><A name='x_O7'></A>Para listas de <SPAN class='type'>Bool</SPAN>, as funções <CODE class='function'>and</CODE> e <CODE class='function'>or</CODE>, generalizar seus primos de dois argumentos<CODE class='function'>(&amp;&amp;)</CODE> e <CODE class='function'>(||)</CODE>, sobre as listas.<SPAN id='comments_x_O7' class='comment'><A class='commenttoggle' id='toggle_x_O7' pid='x_O7' onclick='return loadComments(&quot;x_O7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:and.or'></A><PRE id='ch04.list.ghci:and.or' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t and
</CODE></STRONG><code class='machineMsg'>and :: [Bool] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>and [True,False,True]
</CODE></STRONG><code class='machineMsg'>False
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>and []
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:type or
</CODE></STRONG><code class='machineMsg'>or :: [Bool] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>or [False,False,False,True,False]
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>or []
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:and.or' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:and.or' onclick='return loadComments(&quot;ch04.list.ghci:and.or&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_P7'><A name='x_P7'></A>Eles têm primos mais úteis, <CODE class='function'>all</CODE> e <CODE class='function'>any</CODE>, que operam em listas de qualquer tipo. Cada um leva um predicado como seu primeiro argumento, <CODE class='function'>all</CODE>retorna <CODE class='code'>True</CODE> se o predicado for bem-sucedido em cada elemento da lista, enquanto <CODE class='function'>any</CODE>retorna <CODE class='code'>True</CODE> se o predicado for bem-sucedido em pelo menos um elemento da lista.<SPAN id='comments_x_P7' class='comment'><A class='commenttoggle' id='toggle_x_P7' pid='x_P7' onclick='return loadComments(&quot;x_P7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:all.any'></A><PRE id='ch04.list.ghci:all.any' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t all
</CODE></STRONG><code class='machineMsg'>all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>all odd [1,3,5]
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>all odd [3,1,4,1,5,9,2,6,5]
</CODE></STRONG><code class='machineMsg'>False
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>all odd []
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:type any
</CODE></STRONG><code class='machineMsg'>any :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>any even [3,1,4,1,5,9,2,6,5]
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>any even []
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:all.any' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:all.any' onclick='return loadComments(&quot;ch04.list.ghci:all.any&quot;)' href='comment: add'>?? comments</A></SPAN></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id590714'>Trabalhar com sublistas</H3></DIV></DIV></DIV><P id='x_Q7'><A name='x_Q7'></A>A função <CODE class='function'>take</CODE>, de que já reuniu em <A class='xref' href='types-and-functions.html#funcstypes.calling' title='“aplicação&nbsp;de&nbsp;função”'>“aplicação de função”</A>, retorna uma sublista consistindo de primeiros <SPAN class='emphasis'><EM>k</EM></SPAN> elementos de uma lista. Seu inverso, <CODE class='function'>drop</CODE>, quedas de <SPAN class='emphasis'><EM>k</EM></SPAN> elementos, desde o início da lista.<SPAN id='comments_x_Q7' class='comment'><A class='commenttoggle' id='toggle_x_Q7' pid='x_Q7' onclick='return loadComments(&quot;x_Q7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:take.drop'></A><PRE id='ch04.list.ghci:take.drop' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t take
</CODE></STRONG><code class='machineMsg'>take :: Int -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>take 3 "foobar"
</CODE></STRONG><code class='machineMsg'>"foo"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>take 2 [1]
</CODE></STRONG><code class='machineMsg'>[1]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:type drop
</CODE></STRONG><code class='machineMsg'>drop :: Int -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>drop 3 "xyzzy"
</CODE></STRONG><code class='machineMsg'>"zy"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>drop 1 []
</CODE></STRONG><code class='machineMsg'>[]
</code></PRE> <SPAN id='comments_ch04.list.ghci:take.drop' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:take.drop' onclick='return loadComments(&quot;ch04.list.ghci:take.drop&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_R7'><A name='x_R7'></A>A função <CODE class='function'>splitAt</CODE> combina as funções de <CODE class='function'>take</CODE> e <CODE class='function'>drop</CODE>, voltando um par da lista de entrada, dividido o índice determinado.<SPAN id='comments_x_R7' class='comment'><A class='commenttoggle' id='toggle_x_R7' pid='x_R7' onclick='return loadComments(&quot;x_R7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:splitAt'></A><PRE id='ch04.list.ghci:splitAt' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t splitAt
</CODE></STRONG><code class='machineMsg'>splitAt :: Int -&gt; [a] -&gt; ([a], [a])
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>splitAt 3 "foobar"
</CODE></STRONG><code class='machineMsg'>("foo","bar")
</code></PRE> <SPAN id='comments_ch04.list.ghci:splitAt' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:splitAt' onclick='return loadComments(&quot;ch04.list.ghci:splitAt&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_S7'><A name='x_S7'></A>As funções <CODE class='function'>takeWhile</CODE> e <CODE class='function'>dropWhile</CODE>levar predicados: <CODE class='function'>takeWhile</CODE> toma elementos a partir do início de uma lista tão longa quanto o predicado retornar <CODE class='code'>True</CODE>, enquanto <CODE class='function'>dropWhile</CODE> gotas elementos da lista, enquanto o predicado retornar <CODE class='code'>True</CODE>.<SPAN id='comments_x_S7' class='comment'><A class='commenttoggle' id='toggle_x_S7' pid='x_S7' onclick='return loadComments(&quot;x_S7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:takeWhile.dropWhile'></A><PRE id='ch04.list.ghci:takeWhile.dropWhile' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t takeWhile
</CODE></STRONG><code class='machineMsg'>takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>takeWhile odd [1,3,5,6,8,9,11]
</CODE></STRONG><code class='machineMsg'>[1,3,5]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:type dropWhile
</CODE></STRONG><code class='machineMsg'>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>dropWhile even [2,4,6,7,9,10,12]
</CODE></STRONG><code class='machineMsg'>[7,9,10,12]
</code></PRE> <SPAN id='comments_ch04.list.ghci:takeWhile.dropWhile' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:takeWhile.dropWhile' onclick='return loadComments(&quot;ch04.list.ghci:takeWhile.dropWhile&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_T7'><A name='x_T7'></A>Assim como <CODE class='function'>splitAt</CODE>“<SPAN class='quote'>tuplas</SPAN>” os resultados de <CODE class='function'>take</CODE> e <CODE class='function'>drop</CODE>, as funções <CODE class='function'>break</CODE> (que já vimos na <A class='xref' href='#fp.splitlines' title='seção&nbsp;chamada&nbsp;“Warming&nbsp;up:&nbsp;Separação&nbsp;das&nbsp;linhas&nbsp;de&nbsp;texto&nbsp;portavel”'>seção chamada “Warming up: Separação das linhas de texto portavel”</A>) e <CODE class='function'>span</CODE> até tupla os resultados de <CODE class='function'>takeWhile</CODE> e <CODE class='function'>dropWhile</CODE>.<SPAN id='comments_x_T7' class='comment'><A class='commenttoggle' id='toggle_x_T7' pid='x_T7' onclick='return loadComments(&quot;x_T7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_U7'><A name='x_U7'></A>Cada função tem um predicado; <CODE class='function'>break</CODE> consome a sua entrada enquanto o predicado falha, enquanto <CODE class='function'>span</CODE> consome enquanto seu predicado êxito.<SPAN id='comments_x_U7' class='comment'><A class='commenttoggle' id='toggle_x_U7' pid='x_U7' onclick='return loadComments(&quot;x_U7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:break.span'></A><PRE id='ch04.list.ghci:break.span' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t span
</CODE></STRONG><code class='machineMsg'>span :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>span even [2,4,6,7,9,10,11]
</CODE></STRONG><code class='machineMsg'>([2,4,6],[7,9,10,11])
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:type break
</CODE></STRONG><code class='machineMsg'>break :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>break even [1,3,5,6,8,9,10]
</CODE></STRONG><code class='machineMsg'>([1,3,5],[6,8,9,10])
</code></PRE> <SPAN id='comments_ch04.list.ghci:break.span' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:break.span' onclick='return loadComments(&quot;ch04.list.ghci:break.span&quot;)' href='comment: add'>?? comments</A></SPAN></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.list.search'>Buscando listas</H3></DIV></DIV></DIV><P id='x_V7'><A name='x_V7'></A>Como já vimos, a função <CODE class='function'>elem</CODE>indica se um valor está presente em uma lista. Ele tem uma função complementar, <CODE class='function'>notElem</CODE>.<SPAN id='comments_x_V7' class='comment'><A class='commenttoggle' id='toggle_x_V7' pid='x_V7' onclick='return loadComments(&quot;x_V7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:elem'></A><PRE id='ch04.list.ghci:elem' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t elem
</CODE></STRONG><code class='machineMsg'>elem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>2 `elem` [5,3,2,1,1]
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>2 `notElem` [5,3,2,1,1]
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:elem' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:elem' onclick='return loadComments(&quot;ch04.list.ghci:elem&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_W7'><A name='x_W7'></A>Para uma pesquisa mais geral, <CODE class='function'>filter</CODE> tem um predicado, e retorna todos os elementos da lista em que o predicado for bem-sucedido.<SPAN id='comments_x_W7' class='comment'><A class='commenttoggle' id='toggle_x_W7' pid='x_W7' onclick='return loadComments(&quot;x_W7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:filter'></A><PRE id='ch04.list.ghci:filter' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t filter
</CODE></STRONG><code class='machineMsg'>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>filter odd [2,4,1,3,6,8,5,7]
</CODE></STRONG><code class='machineMsg'>[1,3,5,7]
</code></PRE> <SPAN id='comments_ch04.list.ghci:filter' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:filter' onclick='return loadComments(&quot;ch04.list.ghci:filter&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_X7'><A name='x_X7'></A>Em <CODE class='code'>Data.List</CODE>, três predicados, <CODE class='function'>isPrefixOf</CODE>, <CODE class='function'>isInfixOf</CODE> e <CODE class='function'>isSuffixOf</CODE>, vamos testar a presença de sublistas dentro de uma grande lista. A maneira mais fácil de usá-los é usando a notação infixa.<SPAN id='comments_x_X7' class='comment'><A class='commenttoggle' id='toggle_x_X7' pid='x_X7' onclick='return loadComments(&quot;x_X7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_Y7'><A name='x_Y7'></A>A função <CODE class='function'>isPrefixOf</CODE> nos diz se o seu argumento deixou coincide com o início da sua tese direita.<SPAN id='comments_x_Y7' class='comment'><A class='commenttoggle' id='toggle_x_Y7' pid='x_Y7' onclick='return loadComments(&quot;x_Y7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:isPrefixOf'></A><PRE id='ch04.list.ghci:isPrefixOf' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t isPrefixOf
</CODE></STRONG><code class='machineMsg'>isPrefixOf :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"foo" `isPrefixOf` "foobar"
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>[1,2] `isPrefixOf` []
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:isPrefixOf' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:isPrefixOf' onclick='return loadComments(&quot;ch04.list.ghci:isPrefixOf&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_Z7'><A name='x_Z7'></A>A função <CODE class='function'>isInfixOf</CODE> indica se o seu argumento de esquerda é uma sublista de seu direito.<SPAN id='comments_x_Z7' class='comment'><A class='commenttoggle' id='toggle_x_Z7' pid='x_Z7' onclick='return loadComments(&quot;x_Z7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:isInfixOf'></A><PRE id='ch04.list.ghci:isInfixOf' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>[2,6] `isInfixOf` [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]
</CODE></STRONG><code class='machineMsg'>True
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>"funk" `isInfixOf` "sonic youth"
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_ch04.list.ghci:isInfixOf' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:isInfixOf' onclick='return loadComments(&quot;ch04.list.ghci:isInfixOf&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_a7'><A name='x_a7'></A>A operação de <CODE class='function'>isSuffixOf</CODE> não deve precisar de qualquer explicação.<SPAN id='comments_x_a7' class='comment'><A class='commenttoggle' id='toggle_x_a7' pid='x_a7' onclick='return loadComments(&quot;x_a7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:isSuffixOf'></A><PRE id='ch04.list.ghci:isSuffixOf' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>".c" `isSuffixOf` "crash_o_meu.c"
</CODE></STRONG><code class='machineMsg'>True
</code></PRE> <SPAN id='comments_ch04.list.ghci:isSuffixOf' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:isSuffixOf' onclick='return loadComments(&quot;ch04.list.ghci:isSuffixOf&quot;)' href='comment: add'>?? comments</A></SPAN></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id591412'>Trabalhando com muitas listas ao mesmo tempo</H3></DIV></DIV></DIV><P id='x_b7'><A name='x_b7'></A>A função <CODE class='function'>zip</CODE>recebe duas listas e “<SPAN class='quote'>fecha-los</SPAN>” em uma única lista de pares. A lista resultante é o mesmo comprimento que o mais curto dos dois insumos.<SPAN id='comments_x_b7' class='comment'><A class='commenttoggle' id='toggle_x_b7' pid='x_b7' onclick='return loadComments(&quot;x_b7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:zip'></A><PRE id='ch04.list.ghci:zip' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zip
</CODE></STRONG><code class='machineMsg'>zip :: [a] -&gt; [b] -&gt; [(a, b)]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip [12,72,93] "zippidade"
</CODE></STRONG><code class='machineMsg'>[(12,'z'),(72,'i'),(93,'p')]
</code></PRE> <SPAN id='comments_ch04.list.ghci:zip' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:zip' onclick='return loadComments(&quot;ch04.list.ghci:zip&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_c7'><A name='x_c7'></A>Mais útil é <CODE class='function'>zipWith</CODE>, que pega duas listas e aplica uma função para cada par de elementos, gerando uma lista que é do mesmo comprimento que o menor dos dois.<SPAN id='comments_x_c7' class='comment'><A class='commenttoggle' id='toggle_x_c7' pid='x_c7' onclick='return loadComments(&quot;x_c7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:zipWith'></A><PRE id='ch04.list.ghci:zipWith' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zipWith
</CODE></STRONG><code class='machineMsg'>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zipWith (+) [1,2,3] [4,5,6]
</CODE></STRONG><code class='machineMsg'>[5,7,9]
</code></PRE> <SPAN id='comments_ch04.list.ghci:zipWith' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:zipWith' onclick='return loadComments(&quot;ch04.list.ghci:zipWith&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_d7'><A name='x_d7'></A>O sistema de tipo de Haskell torna um desafio interessante para escrever funções que recebem número variável de argumentos<SUP>[<A name='id591518' href='#ftn.id591518' class='footnote'>8</A>]</SUP>. Portanto, se queremos zip três listas em conjunto, chamamos <CODE class='function'>zip3</CODE> ou <CODE class='function'>zipWith3</CODE>, e assim por diante até <CODE class='function'>zip7</CODE> e <CODE class='function'>zipWith7</CODE>.<SPAN id='comments_x_d7' class='comment'><A class='commenttoggle' id='toggle_x_d7' pid='x_d7' onclick='return loadComments(&quot;x_d7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.lists.strings'>Funções especiais de manipulação de string</H3></DIV></DIV></DIV><P id='x_e7'><A name='x_e7'></A>Nós já encontramos a função padrão <CODE class='function'>lines</CODE> em <A class='xref' href='#fp.splitlines' title='a&nbsp;seção&nbsp;chamada&nbsp;“Warming&nbsp;up:&nbsp;Separação&nbsp;das&nbsp;linhas&nbsp;de&nbsp;texto&nbsp;portavel”'>a seção chamada “Warming up: Separação das linhas de texto portavel”</A>, eo seu homólogo padrão, <CODE class='function'>unlines</CODE>. Observe que <CODE class='function'>unlines</CODE> sempre coloca uma nova linha no final do seu resultado.<SPAN id='comments_x_e7' class='comment'><A class='commenttoggle' id='toggle_x_e7' pid='x_e7' onclick='return loadComments(&quot;x_e7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:unlines'></A><PRE id='ch04.list.ghci:unlines' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>lines "foo\nbar"
</CODE></STRONG><code class='machineMsg'>["foo","bar"]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>unlines ["foo", "bar"]
</CODE></STRONG><code class='machineMsg'>"foo\nbar\n"
</code></PRE> <SPAN id='comments_ch04.list.ghci:unlines' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:unlines' onclick='return loadComments(&quot;ch04.list.ghci:unlines&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_f7'><A name='x_f7'></A>A função <CODE class='function'>words</CODE> divide uma seqüência de entrada em qualquer espaço em branco. Sua contraparte, <CODE class='function'>unwords</CODE>, usa um único espaço para participar de uma lista de palavras.<SPAN id='comments_x_f7' class='comment'><A class='commenttoggle' id='toggle_x_f7' pid='x_f7' onclick='return loadComments(&quot;x_f7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:words.unwords'></A><PRE id='ch04.list.ghci:words.unwords' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>words "the  \r  quick \t  brown\n\n\nfox"
</CODE></STRONG><code class='machineMsg'>["the","quick","brown","fox"]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>unwords ["jumps", "over", "the", "lazy", "dog"]
</CODE></STRONG><code class='machineMsg'>"jumps over the lazy dog"
</code></PRE> <SPAN id='comments_ch04.list.ghci:words.unwords' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:words.unwords' onclick='return loadComments(&quot;ch04.list.ghci:words.unwords&quot;)' href='comment: add'>?? comments</A></SPAN></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id591678'>Exercícios</H3></DIV></DIV></DIV><DIV class='qandaset'><TABLE border='0' summary='Q and A Set'><COL align='left' width='1%'><TBODY><TR class='question'><TD align='left' valign='top'><P><B>1.</B></P></TD><TD align='left' valign='top'><P id='x_g7'><A name='x_g7'></A>Escreva seus próprios definições “<SPAN class='quote'>seguras</SPAN>” das funções de lista parcial normal, mas certifique-se que o seu nunca falham. Como dica, você pode querer considerar usando os seguintes tipos.<SPAN id='comments_x_g7' class='comment'><A class='commenttoggle' id='toggle_x_g7' pid='x_g7' onclick='return loadComments(&quot;x_g7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:safe'></A><PRE id='ch04.exercises.hs:safe' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
safeHead:: [a]-&gt; Maybe a
safeTail:: [a]-&gt; Maybe [a]
safeLast:: [a]-&gt; Maybe a
safeInit:: [a]-&gt; Maybe [a]</PRE><SPAN id='comments_ch04.exercises.hs:safe' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:safe' pid='ch04.exercises.hs:safe' onclick='return loadComments(&quot;ch04.exercises.hs:safe&quot;)' href='comments: show / hide'>?? comments</A></SPAN></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>2.</B></P></TD><TD align='left' valign='top'><P id='x_h7'><A name='x_h7'></A>Escreva uma função <CODE class='function'>splitWith</CODE> que atua de forma semelhante a <CODE class='function'>words</CODE>, mas leva um predicado e uma lista de qualquer tipo, e divide sua lista de entrada em cada elemento para o qual o predicado retornar <CODE class='function'>False</CODE>.<SPAN id='comments_x_h7' class='comment'><A class='commenttoggle' id='toggle_x_h7' pid='x_h7' onclick='return loadComments(&quot;x_h7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:splitWith'></A><PRE id='ch04.exercises.hs:splitWith' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
splitWith:: (a-&gt;Bool)-&gt; [a]-&gt; [[a]]</PRE><SPAN id='comments_ch04.exercises.hs:splitWith' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:splitWith' pid='ch04.exercises.hs:splitWith' onclick='return loadComments(&quot;ch04.exercises.hs:splitWith&quot;)' href='comments: show / hide'>?? comments</A></SPAN></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>3.</B></P></TD><TD align='left' valign='top'><P id='x_pC1'><A name='x_pC1'></A>Usando a estrutura de comando da <A class='xref' href='#fp.framework' title='seção&nbsp;chamada&nbsp;“Um&nbsp;framework&nbsp;de&nbsp;linha&nbsp;de&nbsp;comando&nbsp;simples”'>seção chamada “Um framework de linha de comando simples”</A>, escreva um programa que imprime a primeira palavra de cada linha de sua entrada.<SPAN id='comments_x_pC1' class='comment'><A class='commenttoggle' id='toggle_x_pC1' pid='x_pC1' onclick='return loadComments(&quot;x_pC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>4.</B></P></TD><TD align='left' valign='top'><P id='x_qC1'><A name='x_qC1'></A>Escreva um programa que transpõe o texto em um arquivo. Por exemplo, ele deve converter <CODE class='code'>"hello\nworld\n"</CODE> para <CODE class='code'>"hw\neo\nlr\nll\nod\n"</CODE>.<SPAN id='comments_x_qC1' class='comment'><A class='commenttoggle' id='toggle_x_qC1' pid='x_qC1' onclick='return loadComments(&quot;x_qC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.loop'>Como pensar a respeito de loops</H2></DIV></DIV></DIV><P id='x_i7'><A name='x_i7'></A>Diferentemente das linguagens tradicionais, Haskell não tem nem um <CODE class='code'>for</CODE> loop nem <CODE class='code'>while</CODE> loop. Se nós temos um monte de dados para processar, o que queremos usar no lugar? Existem várias respostas possíveis a esta pergunta.<SPAN id='comments_x_i7' class='comment'><A class='commenttoggle' id='toggle_x_i7' pid='x_i7' onclick='return loadComments(&quot;x_i7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.tailrecursion'>Recursão explícita</H3></DIV></DIV></DIV><P id='x_j7'><A name='x_j7'></A>Uma maneira simples de fazer o salto a partir de uma linguagem que tem laços com uma que não é executado através de alguns exemplos, olhando para as diferenças. Aqui está uma função C que recebe uma string de dígitos decimais e os transforma em um inteiro.<SPAN id='comments_x_j7' class='comment'><A class='commenttoggle' id='toggle_x_j7' pid='x_j7' onclick='return loadComments(&quot;x_j7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='intparse.c:as_int'></A><PRE id='intparse.c:as_int' class='programlisting'>int as_int(char *string){
    int acc; <code class='codecomment'>/* accumulate the partial result */</code>
    for(acc= 0; isdigit(*string); string++)
        acc= acc*10 + (*string - '0');
    return acc;
}</PRE><SPAN id='comments_intparse.c:as_int' class='comment'><A class='commenttoggle' id='toggle_intparse.c:as_int' pid='intparse.c:as_int' onclick='return loadComments(&quot;intparse.c:as_int&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_k7'><A name='x_k7'></A>Dado que Haskell não possui construções de repetição, como devemos pensar sobre o que representa um simples pedaço bastante de código como este?<SPAN id='comments_x_k7' class='comment'><A class='commenttoggle' id='toggle_x_k7' pid='x_k7' onclick='return loadComments(&quot;x_k7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_l7'><A name='x_l7'></A>Nós não temos de começar por escrever um tipo de assinatura, mas ajuda a nos lembrar que estamos trabalhando.<SPAN id='comments_x_l7' class='comment'><A class='commenttoggle' id='toggle_x_l7' pid='x_l7' onclick='return loadComments(&quot;x_l7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='IntParse.hs:type'></A><PRE id='IntParse.hs:type' class='programlisting'><code class='codecomment'>-- arquivo: ca04/IntParse.hs</code>
import Data.Char(ord) <code class='codecomment'>-- vamos precisar de ord em breve</code>

asInt:: String-&gt; Int</PRE><SPAN id='comments_IntParse.hs:type' class='comment'><A class='commenttoggle' id='toggle_IntParse.hs:type' pid='IntParse.hs:type' onclick='return loadComments(&quot;IntParse.hs:type&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_m7'><A name='x_m7'></A>O código C calcula o resultado de forma incremental, uma vez que percorre a string, o código Haskell pode fazer a mesma função. No entanto, Haskell, podemos expressar o equivalente a um ciclo como um arquivo. Vamos chamar o nosso <CODE class='function'>loop</CODE> só para manter as coisas agradáveis e explícita.<SPAN id='comments_x_m7' class='comment'><A class='commenttoggle' id='toggle_x_m7' pid='x_m7' onclick='return loadComments(&quot;x_m7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='IntParse.hs:loop'></A><PRE id='IntParse.hs:loop' class='programlisting'><code class='codecomment'>-- arquivo: ca04/IntParse.hs</code>
loop:: Int-&gt; String-&gt; Int

asInt xs = loop 0 xs</PRE><SPAN id='comments_IntParse.hs:loop' class='comment'><A class='commenttoggle' id='toggle_IntParse.hs:loop' pid='IntParse.hs:loop' onclick='return loadComments(&quot;IntParse.hs:loop&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_n7'><A name='x_n7'></A>Esse primeiro parâmetro para <CODE class='function'>loop</CODE> é a variável acumulador estaremos usando. Passando em zero é equivalente a inicialização do <CODE class='varname'>acc</CODE> variável em C, no início do loop.<SPAN id='comments_x_n7' class='comment'><A class='commenttoggle' id='toggle_x_n7' pid='x_n7' onclick='return loadComments(&quot;x_n7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_o7'><A name='x_o7'></A>Ao invés de pular em código chamas, vamos pensar sobre os dados que temos para trabalhar. Nossa <SPAN class='type'>String</SPAN> familiar é apenas um sinônimo para <SPAN class='type'>[Char]</SPAN>, uma lista de caracteres. A maneira mais fácil para nós para obter o direito de passagem é para pensar sobre a estrutura de uma lista: é vazia ou um único elemento seguido pelo resto da lista.<SPAN id='comments_x_o7' class='comment'><A class='commenttoggle' id='toggle_x_o7' pid='x_o7' onclick='return loadComments(&quot;x_o7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_p7'><A name='x_p7'></A>Podemos expressar este pensamento estrutural directamente pelo padrão correspondente na lista de construtores do tipo. Muitas vezes é útil pensar sobre os casos fáceis primeiro: aqui, o que significa que vamos considerar o caso de lista vazia.<SPAN id='comments_x_p7' class='comment'><A class='commenttoggle' id='toggle_x_p7' pid='x_p7' onclick='return loadComments(&quot;x_p7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='IntParse.hs:base'></A><PRE id='IntParse.hs:base' class='programlisting'><code class='codecomment'>-- arquivo: ca04/IntParse.hs</code>
loop acc [] = acc</PRE><SPAN id='comments_IntParse.hs:base' class='comment'><A class='commenttoggle' id='toggle_IntParse.hs:base' pid='IntParse.hs:base' onclick='return loadComments(&quot;IntParse.hs:base&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_q7'><A name='x_q7'></A>Uma lista vazia não significa apenas “<SPAN class='quote'>o String de entrada está vazia</SPAN>”; é também o caso, vamos encontrar quando percorremos todo o caminho até o fim de uma lista não-vazia para fora. Então, nós não queremos “<SPAN class='quote'>erro</SPAN>” se vemos uma lista vazia. Em vez disso, devemos fazer algo sensato. Aqui, a única coisa sensata é a de terminar o ciclo, e voltar o nosso valor acumulado.<SPAN id='comments_x_q7' class='comment'><A class='commenttoggle' id='toggle_x_q7' pid='x_q7' onclick='return loadComments(&quot;x_q7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_r7'><A name='x_r7'></A>O outro caso temos que considerar surge quando a lista de entrada não estiver vazia. Precisamos fazer alguma coisa com o elemento atual da lista, e algo com o resto da lista.<SPAN id='comments_x_r7' class='comment'><A class='commenttoggle' id='toggle_x_r7' pid='x_r7' onclick='return loadComments(&quot;x_r7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='IntParse.hs:inductive'></A><PRE id='IntParse.hs:inductive' class='programlisting'><code class='codecomment'>-- arquivo: ca04/IntParse.hs</code>
loop acc (x:xs) = let acc' = acc*10 + ord x
                  in loop acc' xs</PRE><SPAN id='comments_IntParse.hs:inductive' class='comment'><A class='commenttoggle' id='toggle_IntParse.hs:inductive' pid='IntParse.hs:inductive' onclick='return loadComments(&quot;IntParse.hs:inductive&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_s7'><A name='x_s7'></A>Calculamos um novo valor para o acumulador, e dar-lhe o nome de <CODE class='varname'>acc'</CODE>. Em seguida, chamamos a função <CODE class='function'>words</CODE> divide uma seqüência de entrada em qualquer espaço em branco. Sua contraparte, <CODE class='function'>unwords</CODE>, usa um único espaço para participar de uma lista de palavras.<SPAN id='comments_x_s7' class='comment'><A class='commenttoggle' id='toggle_x_s7' pid='x_s7' onclick='return loadComments(&quot;x_s7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><DIV class='note'><TABLE border='0' summary='Note: As aspas simples em nomes de variáveis'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Note]' src='support/figs/note.png'></TD><TH align='left'>As aspas simples em nomes de variáveis</TH></TR><TR><TD align='left' valign='top'><P id='x_t7'><A name='x_t7'></A>Lembre-se, uma única citação é um personagem legal para usar em um nome de variável Haskell, e é pronunciado como “<SPAN class='quote'>prime</SPAN>”. Há uma expressão comum em programas Haskell envolvendo uma variável, digamos <CODE class='varname'>foo</CODE> e outra variável, por exemplo <CODE class='varname'>foo'</CODE>. Normalmente podemos assumir que <CODE class='varname'>foo'</CODE> é de alguma forma relacionada com <CODE class='varname'>foo</CODE>. É muitas vezes um novo valor para <CODE class='varname'>foo</CODE>, como no nosso código acima.<SPAN id='comments_x_t7' class='comment'><A class='commenttoggle' id='toggle_x_t7' pid='x_t7' onclick='return loadComments(&quot;x_t7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_u7'><A name='x_u7'></A>Às vezes, vamos ver essa expressão alargado, como <CODE class='varname'>foo''</CODE>. Como manter o controle do número de aspas simples tacheada no final de um nome rapidamente se torna enfadonho, o uso de mais de dois em uma fileira, felizmente, é rara. Na verdade, mesmo uma única citação pode ser fácil de se perder, o que pode levar a confusão por parte dos leitores. Talvez seja melhor pensar no uso de aspas simples como uma convenção de codificação que você deve ser capaz de reconhecer, e menos como um que você deve realmente seguir.<SPAN id='comments_x_u7' class='comment'><A class='commenttoggle' id='toggle_x_u7' pid='x_u7' onclick='return loadComments(&quot;x_u7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV><P id='x_v7'><A name='x_v7'></A>Cada vez que a função <CODE class='function'>loop</CODE> chama a si mesmo, tem um novo valor para o acumulador, e consome um elemento da lista de entrada. Eventualmente, ele vai acertar o final da lista, em que o tempo <CODE class='code'>[]</CODE> padrão irá corresponder, e as chamadas recursivas cessará.<SPAN id='comments_x_v7' class='comment'><A class='commenttoggle' id='toggle_x_v7' pid='x_v7' onclick='return loadComments(&quot;x_v7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_w7'><A name='x_w7'></A>Como isso funciona bem a função? Para inteiros positivos, é perfeitamente cromulent.<SPAN id='comments_x_w7' class='comment'><A class='commenttoggle' id='toggle_x_w7' pid='x_w7' onclick='return loadComments(&quot;x_w7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='intparse.ghci:example'></A><PRE id='intparse.ghci:example' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt "33"
</CODE></STRONG><code class='machineMsg'>33
</code></PRE> <SPAN id='comments_intparse.ghci:example' class='comment'><A class='commenttoggle' id='toggle_intparse.ghci:example' onclick='return loadComments(&quot;intparse.ghci:example&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_x7'><A name='x_x7'></A>Como isso funciona bem a função? Para inteiros positivos, é perfeitamente cromulent.<SPAN id='comments_x_x7' class='comment'><A class='commenttoggle' id='toggle_x_x7' pid='x_x7' onclick='return loadComments(&quot;x_x7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='intparse.ghci:bad'></A><PRE id='intparse.ghci:bad' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt ""
</CODE></STRONG><code class='machineMsg'>0
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt "potato"
</CODE></STRONG><code class='machineMsg'>*** Exception: Char.digitToInt: not a digit 'p'
</code></PRE> <SPAN id='comments_intparse.ghci:bad' class='comment'><A class='commenttoggle' id='toggle_intparse.ghci:bad' onclick='return loadComments(&quot;intparse.ghci:bad&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_y7'><A name='x_y7'></A>Vamos adiar a fixação função nossas deficiências para <A class='xref' href='#fp.asInt.fix' title='Q:&nbsp;1'>Q:&nbsp;1</A>.<SPAN id='comments_x_y7' class='comment'><A class='commenttoggle' id='toggle_x_y7' pid='x_y7' onclick='return loadComments(&quot;x_y7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_z7'><A name='x_z7'></A>Porque a última coisa que <CODE class='function'>loop</CODE> faz é simplesmente chamar a si mesma, é um exemplo de uma função recursiva cauda. Há um outro idioma comum neste código, também. Pensando sobre a estrutura da lista, e manuseio e não vazio casos vazios separadamente, é um tipo de abordagem chamada de <SPAN class='emphasis'><EM>recursão estrutural</EM></SPAN>.<SPAN id='comments_x_z7' class='comment'><A class='commenttoggle' id='toggle_x_z7' pid='x_z7' onclick='return loadComments(&quot;x_z7&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_A8'><A name='x_A8'></A>Chamamos o caso não-recursiva (quando a lista estiver vazia) o <SPAN class='emphasis'><EM>caso de base</EM></SPAN>(por vezes o <SPAN class='emphasis'><EM>caso de terminação</EM></SPAN>). Vamos ver as pessoas se referem ao caso em que a função chama a si mesmo como o caso recursivo (surpresa!), Ou eles podem dar um aceno para a indução matemática e chamá-lo <SPAN class='emphasis'><EM>caso indutivo</EM></SPAN>.<SPAN id='comments_x_A8' class='comment'><A class='commenttoggle' id='toggle_x_A8' pid='x_A8' onclick='return loadComments(&quot;x_A8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_B8'><A name='x_B8'></A>Como uma técnica útil, recursão estrutural não está confinada a lista, podemos usá-lo em outros tipos de dados algébricos, também. Teremos mais a dizer sobre isso mais tarde.<SPAN id='comments_x_B8' class='comment'><A class='commenttoggle' id='toggle_x_B8' pid='x_B8' onclick='return loadComments(&quot;x_B8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><DIV class='note'><TABLE border='0' summary='Note: Qual é a grande coisa sobre recursão de cauda?'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Note]' src='support/figs/note.png'></TD><TH align='left'>Qual é a grande coisa sobre recursão de cauda?</TH></TR><TR><TD align='left' valign='top'><P id='x_QL'><A name='x_QL'></A>Em uma linguagem imperativa, um loop é executado no espaço constante. Sem laços, nós usamos cauda funções recursivas em Haskell vez. Normalmente, uma função recursiva aloca um espaço cada vez que aplica-se, por isso sabe para onde voltar.<SPAN id='comments_x_QL' class='comment'><A class='commenttoggle' id='toggle_x_QL' pid='x_QL' onclick='return loadComments(&quot;x_QL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_RL'><A name='x_RL'></A>Claramente, uma função recursiva estaria em uma enorme desvantagem em relação a um loop se memória alocada para cada aplicação recursiva: isso exigiria espaço linear em vez de espaço constante. No entanto, as implementações de linguagem funcional detectar usos de recursão de cauda, e transformar a cauda chamadas recursivas para executar no espaço constante, isso é chamado de <SPAN class='emphasis'><EM>tail call optimisation</EM></SPAN>, abreviado TCO. <SPAN id='comments_x_RL' class='comment'><A class='commenttoggle' id='toggle_x_RL' pid='x_RL' onclick='return loadComments(&quot;x_RL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_SL'><A name='x_SL'></A>Poucas implementações linguagem imperativa realizar o TCO, que é por isso que usar qualquer tipo de estilo ambiciosa funcional em uma linguagem imperativa, muitas vezes leva à perda de memória e baixo desempenho.<SPAN id='comments_x_SL' class='comment'><A class='commenttoggle' id='toggle_x_SL' pid='x_SL' onclick='return loadComments(&quot;x_SL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id592265'>Transformando cada peça de input</H3></DIV></DIV></DIV><P id='x_C8'><A name='x_C8'></A>Considere uma outra função C, <CODE class='function'>quadrado</CODE>, que quadrados cada elemento em um array.<SPAN id='comments_x_C8' class='comment'><A class='commenttoggle' id='toggle_x_C8' pid='x_C8' onclick='return loadComments(&quot;x_C8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='map.c:square'></A><PRE id='map.c:square' class='programlisting'>void quadrado(double *resultado, const double *entrada, size_t comprimento){
    for(size_t no= 0; no &lt; comprimento; no++)
        resultado[no]= entrada[no] * entrada[no];
}</PRE><SPAN id='comments_map.c:square' class='comment'><A class='commenttoggle' id='toggle_map.c:square' pid='map.c:square' onclick='return loadComments(&quot;map.c:square&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_D8'><A name='x_D8'></A>Este contém um tipo simples e comum de loop, que faz exatamente a mesma coisa a cada elemento da sua matriz de entrada. Como podemos escrever este circuito em Haskell?<SPAN id='comments_x_D8' class='comment'><A class='commenttoggle' id='toggle_x_D8' pid='x_D8' onclick='return loadComments(&quot;x_D8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Map.hs:square'></A><PRE id='Map.hs:square' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Map.hs</code>
quadrado:: [Double]-&gt; [Double]
quadrado (x:xs) = x*x : quadrado xs
quadrado [] = []</PRE><SPAN id='comments_Map.hs:square' class='comment'><A class='commenttoggle' id='toggle_Map.hs:square' pid='Map.hs:square' onclick='return loadComments(&quot;Map.hs:square&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_E8'><A name='x_E8'></A>Nossa função <CODE class='function'>quadrado</CODE> consiste de duas equações a correspondência de padrão. O primeiro “<SPAN class='quote'>desconstrói</SPAN>” o início de uma lista não-vazia, para obter a sua cabeça ea cauda. É praças o primeiro elemento, em seguida, coloca que na frente de uma nova lista, que é construída chamando <CODE class='function'>quadrado</CODE> no restante da lista vazio. A segunda equação garante que <CODE class='function'>quadrado</CODE> pára quando ela atinge o final da lista de entrada.<SPAN id='comments_x_E8' class='comment'><A class='commenttoggle' id='toggle_x_E8' pid='x_E8' onclick='return loadComments(&quot;x_E8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_F8'><A name='x_F8'></A>O efeito de <CODE class='function'>quadrado</CODE> é a construção de uma nova lista que é do mesmo tamanho que a sua lista de entrada, com cada elemento da lista de entrada com a sua praça substituído na lista de saída.<SPAN id='comments_x_F8' class='comment'><A class='commenttoggle' id='toggle_x_F8' pid='x_F8' onclick='return loadComments(&quot;x_F8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_G8'><A name='x_G8'></A>Aqui está um outro ciclo C tal, aquele que garante que cada letra em uma string é convertida em maiúsculas.<SPAN id='comments_x_G8' class='comment'><A class='commenttoggle' id='toggle_x_G8' pid='x_G8' onclick='return loadComments(&quot;x_G8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='map.c:uppercase'></A><PRE id='map.c:uppercase' class='programlisting'>#include &lt;ctype.h&gt;

char *maiuscula(const char *entrada){
    char *resultado= strdup(entrada);
    
    if(resultado != NULL)
        for(size_t no= 0; resultado[no] != '\0'; no++)
            resultado[no]= toupper(resultado[no]);
    return resultado;
}</PRE><SPAN id='comments_map.c:uppercase' class='comment'><A class='commenttoggle' id='toggle_map.c:uppercase' pid='map.c:uppercase' onclick='return loadComments(&quot;map.c:uppercase&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_H8'><A name='x_H8'></A>Vamos olhar um equivalente Haskell.<SPAN id='comments_x_H8' class='comment'><A class='commenttoggle' id='toggle_x_H8' pid='x_H8' onclick='return loadComments(&quot;x_H8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Map.hs:upperCase'></A><PRE id='Map.hs:upperCase' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Map.hs</code>
import Data.Char(toUpper)

maiuscula:: String-&gt; String
maiuscula (x:xs) = toUpper x : maiuscula xs
maiuscula [] = []</PRE><SPAN id='comments_Map.hs:upperCase' class='comment'><A class='commenttoggle' id='toggle_Map.hs:upperCase' pid='Map.hs:upperCase' onclick='return loadComments(&quot;Map.hs:upperCase&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_I8'><A name='x_I8'></A>Aqui, nós estamos importando a função <CODE class='function'>toUpper</CODE> do módulo padrão <CODE class='code'>Data.Char</CODE>, que contém grande quantidade de funções úteis para trabalhar com dados <SPAN class='type'>Char</SPAN>.<SPAN id='comments_x_I8' class='comment'><A class='commenttoggle' id='toggle_x_I8' pid='x_I8' onclick='return loadComments(&quot;x_I8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_J8'><A name='x_J8'></A>Nossa função <CODE class='function'>maiuscula</CODE> segue um padrão semelhante à nossa função anterior <CODE class='function'>quadrado</CODE>. Ele termina com uma lista vazia quando a lista de entrada está vazia, e quando a entrada não estiver vazia, ela chama <CODE class='function'>toUpper</CODE> no primeiro elemento, em seguida, constrói uma nova lista de células e que o resultado de chamar-se sobre o resto da entrada lista.<SPAN id='comments_x_J8' class='comment'><A class='commenttoggle' id='toggle_x_J8' pid='x_J8' onclick='return loadComments(&quot;x_J8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_K8'><A name='x_K8'></A>Estes exemplos seguem um padrão comum para escrever funções recursivas sobre listas em Haskell. O <SPAN class='emphasis'><EM>caso base</EM></SPAN> lida com a situação onde a nossa entrada lista está vazia. O <SPAN class='emphasis'><EM>caso recursivo</EM></SPAN> trata de uma lista não-vazia, que faz algo com a cabeça da lista, e se chama recursivamente na cauda.<SPAN id='comments_x_K8' class='comment'><A class='commenttoggle' id='toggle_x_K8' pid='x_K8' onclick='return loadComments(&quot;x_K8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id592470'>Mapeando sobre uma lista</H3></DIV></DIV></DIV><P id='x_L8'><A name='x_L8'></A>As funções <CODE class='function'>quadrado</CODE> e <CODE class='function'>maiuscula</CODE> que nós definimos produzir novas listas, que são os mesmos comprimentos de suas listas de entrada, e não apenas uma peça de trabalho por elemento. Esse é um padrão comum que prelúdio Haskell define uma função, <CODE class='function'>map</CODE>, para torná-lo mais fácil. <CODE class='function'>map</CODE> tem uma função, e aplica a cada elemento de uma lista, retornando uma nova lista construída a partir dos resultados dessas aplicações.<SPAN id='comments_x_L8' class='comment'><A class='commenttoggle' id='toggle_x_L8' pid='x_L8' onclick='return loadComments(&quot;x_L8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_M8'><A name='x_M8'></A>Aqui estão as nossas funções <CODE class='function'>square</CODE> e <CODE class='function'>maiuscula</CODE> reescrito para usar <CODE class='function'>map</CODE>.<SPAN id='comments_x_M8' class='comment'><A class='commenttoggle' id='toggle_x_M8' pid='x_M8' onclick='return loadComments(&quot;x_M8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Map.hs:map2'></A><PRE id='Map.hs:map2' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Map.hs</code>
quadrado2 xs = map quadrado1 xs
    where quadrado1 x = x*x

maiuscula2 xs = map toUpper xs</PRE><SPAN id='comments_Map.hs:map2' class='comment'><A class='commenttoggle' id='toggle_Map.hs:map2' pid='Map.hs:map2' onclick='return loadComments(&quot;Map.hs:map2&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_N8'><A name='x_N8'></A>Este é o nosso primeiro olhar de perto uma função que recebe outra função como argumento. Podemos aprender muito sobre o <CODE class='function'>map</CODE> simplesmente inspecionando seu tipo.<SPAN id='comments_x_N8' class='comment'><A class='commenttoggle' id='toggle_x_N8' pid='x_N8' onclick='return loadComments(&quot;x_N8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.map.ghci:type'></A><PRE id='ch04.map.ghci:type' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t map
</CODE></STRONG><code class='machineMsg'>map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></PRE> <SPAN id='comments_ch04.map.ghci:type' class='comment'><A class='commenttoggle' id='toggle_ch04.map.ghci:type' onclick='return loadComments(&quot;ch04.map.ghci:type&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_O8'><A name='x_O8'></A>A assinatura nos diz que <CODE class='function'>map</CODE> tem dois argumentos. A primeira é uma função que assume um valor de um tipo, <CODE class='varname'>a</CODE>, e retorna um valor de outro tipo, <CODE class='varname'>b</CODE>.<SPAN id='comments_x_O8' class='comment'><A class='commenttoggle' id='toggle_x_O8' pid='x_O8' onclick='return loadComments(&quot;x_O8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_P8'><A name='x_P8'></A>Desde <CODE class='function'>map</CODE> tem uma função como argumento, nós nos referimos a ela como uma função <SPAN class='emphasis'><EM>higher-order</EM></SPAN> (Apesar do nome, não há nada de misterioso sobre funções de ordem superior, é apenas um termo para funções que recebem outras funções como argumentos, ou funções de retorno.). <SPAN id='comments_x_P8' class='comment'><A class='commenttoggle' id='toggle_x_P8' pid='x_P8' onclick='return loadComments(&quot;x_P8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_Q8'><A name='x_Q8'></A>Desde <CODE class='function'>map</CODE> resumos o padrão comum para as nossas funções <CODE class='function'>square</CODE> e <CODE class='function'>maiuscula</CODE> para que possamos reutilizá-lo com menos clichê, podemos olhar para o que essas funções têm em comum e descobrir como implementá-lo nós mesmos.<SPAN id='comments_x_Q8' class='comment'><A class='commenttoggle' id='toggle_x_Q8' pid='x_Q8' onclick='return loadComments(&quot;x_Q8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Map.hs:myMap'></A><PRE id='Map.hs:myMap' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Map.hs</code>
meuMap:: (a-&gt;b)-&gt; [a]-&gt; [b]
meuMap f (x:xs) = f x : meuMap f xs
meuMap _ _      = []</PRE><SPAN id='comments_Map.hs:myMap' class='comment'><A class='commenttoggle' id='toggle_Map.hs:myMap' pid='Map.hs:myMap' onclick='return loadComments(&quot;Map.hs:myMap&quot;)' href='comments: show / hide'>?? comments</A></SPAN><DIV class='note'><TABLE border='0' summary='Note: Quais são esses wild cards que fazem lá?'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Note]' src='support/figs/note.png'></TD><TH align='left'>Quais são esses wild cards que fazem lá?</TH></TR><TR><TD align='left' valign='top'><P id='x_TL'><A name='x_TL'></A>Se você é novo em programação funcional, as razões para os padrões de correspondência de certas maneiras, nem sempre são óbvias. Por exemplo, na definição de <CODE class='function'>meuMap</CODE> acima, a primeira equação liga a função que está mapeando a variável <CODE class='varname'>f</CODE>, mas o segundo usa cartões selvagens para ambos os parâmetros. O acontecendo estabele que?<SPAN id='comments_x_TL' class='comment'><A class='commenttoggle' id='toggle_x_TL' pid='x_TL' onclick='return loadComments(&quot;x_TL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_UL'><A name='x_UL'></A>Nós usamos um wild card no lugar de <CODE class='varname'>f</CODE> para indicar que não estamos chamando a função <CODE class='varname'>f</CODE> no lado direito da equação. E sobre a lista de parâmetros? O tipo de lista tem dois construtores. Nós já encontrados no construtor não vazia na primeira equação que define <CODE class='function'>myMap</CODE>. Por eliminação, o construtor da segunda equação é necessariamente o construtor lista vazia, então não há necessidade de realizar um jogo para ver o que realmente é o seu valor.<SPAN id='comments_x_UL' class='comment'><A class='commenttoggle' id='toggle_x_UL' pid='x_UL' onclick='return loadComments(&quot;x_UL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_rC1'><A name='x_rC1'></A>Por uma questão de estilo, é bom para usar wild cards para o bem conhecido tipos simples, como listas e <SPAN class='type'>Maybe</SPAN>. Para obter mais ou menos complicados tipos familiares, pode ser mais seguro e mais legível o nome construtores explicitamente.<SPAN id='comments_x_rC1' class='comment'><A class='commenttoggle' id='toggle_x_rC1' pid='x_rC1' onclick='return loadComments(&quot;x_rC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV><P id='x_R8'><A name='x_R8'></A>Procuramos a nossa função <CODE class='function'>meuMap</CODE> para nos dar alguma garantia de que ele se comporta de forma semelhante ao <CODE class='function'>map</CODE>padrão.<SPAN id='comments_x_R8' class='comment'><A class='commenttoggle' id='toggle_x_R8' pid='x_R8' onclick='return loadComments(&quot;x_R8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.map.ghci:inuse'></A><PRE id='ch04.map.ghci:inuse' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.Char
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>map toLower "SHOUTING"
</CODE></STRONG><code class='machineMsg'>"shouting"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>meuMap toUpper "whispering"
</CODE></STRONG><code class='machineMsg'>"WHISPERING"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>map negate [1,2,3]
</CODE></STRONG><code class='machineMsg'>[-1,-2,-3]
</code></PRE> <SPAN id='comments_ch04.map.ghci:inuse' class='comment'><A class='commenttoggle' id='toggle_ch04.map.ghci:inuse' onclick='return loadComments(&quot;ch04.map.ghci:inuse&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_S8'><A name='x_S8'></A>Este padrão de manchas um idioma repetida, então abstraí-lo para que possamos reutilizar (e escrever menos!) De código, é um aspecto comum de programação Haskell. Enquanto a abstração não é exclusivo para Haskell, funções de ordem superior tornam extremamente fácil.<SPAN id='comments_x_S8' class='comment'><A class='commenttoggle' id='toggle_x_S8' pid='x_S8' onclick='return loadComments(&quot;x_S8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.filter'>Seleção de peças de entrada</H3></DIV></DIV></DIV><P id='x_T8'><A name='x_T8'></A>Outra operação comum em uma seqüência de dados é um pente fino nele para os elementos que satisfaçam algum critério. Aqui está uma função que percorre uma lista de números e retorna aqueles que são estranhos. O nosso código tem um caso recursivo que é um pouco mais complexo do que nossas funções anteriores: ele só coloca um número na lista, ele retorna se o número for ímpar. Usando um guarda expressa muito bem isso.<SPAN id='comments_x_T8' class='comment'><A class='commenttoggle' id='toggle_x_T8' pid='x_T8' onclick='return loadComments(&quot;x_T8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Filter.hs:oddList'></A><PRE id='Filter.hs:oddList' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Filter.hs</code>
listaImpar:: [Int]-&gt; [Int]
listaImpar (x:xs) | odd x     = x : listaImpar xs
                  | otherwise = listaImpar xs
listaImpar _                  = []</PRE><SPAN id='comments_Filter.hs:oddList' class='comment'><A class='commenttoggle' id='toggle_Filter.hs:oddList' pid='Filter.hs:oddList' onclick='return loadComments(&quot;Filter.hs:oddList&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_V8'><A name='x_V8'></A>Vamos ver isso em ação.<SPAN id='comments_x_V8' class='comment'><A class='commenttoggle' id='toggle_x_V8' pid='x_V8' onclick='return loadComments(&quot;x_V8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.filter.ghci:oddList'></A><PRE id='ch04.filter.ghci:oddList' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>listaImpar [1,1,2,3,5,8,13,21,34]
</CODE></STRONG><code class='machineMsg'>[1,1,3,5,13,21]
</code></PRE> <SPAN id='comments_ch04.filter.ghci:oddList' class='comment'><A class='commenttoggle' id='toggle_ch04.filter.ghci:oddList' onclick='return loadComments(&quot;ch04.filter.ghci:oddList&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_W8'><A name='x_W8'></A>Mais uma vez, essa expressão é tão comum que o Prelude define uma função, <CODE class='function'>filter</CODE>, que já introduziu. Ele elimina a necessidade de código clichê para recurse sobre a lista.<SPAN id='comments_x_W8' class='comment'><A class='commenttoggle' id='toggle_x_W8' pid='x_W8' onclick='return loadComments(&quot;x_W8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.filter.ghci:filter'></A><PRE id='ch04.filter.ghci:filter' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t filter
</CODE></STRONG><code class='machineMsg'>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>filter odd [3,1,4,1,5,9,2,6,5]
</CODE></STRONG><code class='machineMsg'>[3,1,1,5,9,5]
</code></PRE> <SPAN id='comments_ch04.filter.ghci:filter' class='comment'><A class='commenttoggle' id='toggle_ch04.filter.ghci:filter' onclick='return loadComments(&quot;ch04.filter.ghci:filter&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_X8'><A name='x_X8'></A>A função <CODE class='function'>filter</CODE> tem um predicado e aplica a cada elemento em sua lista de entrada, retornando uma lista de apenas aqueles para os quais o predicado avaliar para <CODE class='code'>True</CODE>. Nós iremos rever <CODE class='function'>filter</CODE> novamente em breve, na <A class='xref' href='#fp.foldr.filter' title='seção&nbsp;chamada&nbsp;“Folding&nbsp;da&nbsp;direita”'>seção chamada “Folding da direita”</A>.<SPAN id='comments_x_X8' class='comment'><A class='commenttoggle' id='toggle_x_X8' pid='x_X8' onclick='return loadComments(&quot;x_X8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id592937'>Computing uma resposta sobre um conjunto</H3></DIV></DIV></DIV><P id='x_Z8'><A name='x_Z8'></A>Outra coisa comum de se fazer com uma coleção é reduzi-lo a um único valor. Um exemplo simples disso é somar os valores de uma lista.<SPAN id='comments_x_Z8' class='comment'><A class='commenttoggle' id='toggle_x_Z8' pid='x_Z8' onclick='return loadComments(&quot;x_Z8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Sum.hs:mySum'></A><PRE id='Sum.hs:mySum' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Soma.hs</code>
meuSoma xs = ajudante 0 xs
    where ajudante acc (x:xs) = ajudante (acc+x) xs
          ajudante acc _      = acc</PRE><SPAN id='comments_Sum.hs:mySum' class='comment'><A class='commenttoggle' id='toggle_Sum.hs:mySum' pid='Sum.hs:mySum' onclick='return loadComments(&quot;Sum.hs:mySum&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_a8'><A name='x_a8'></A>Nossa função <CODE class='function'>ajudante</CODE> é cauda recursiva, e usa um parâmetro acumulador, <CODE class='varname'>acc</CODE>, para segurar a soma das correntes parciais da lista. Como já vimos com <CODE class='function'>asInt</CODE>, esta é uma forma “<SPAN class='quote'>natural</SPAN>” para representar um loop em uma linguagem puramente funcional.<SPAN id='comments_x_a8' class='comment'><A class='commenttoggle' id='toggle_x_a8' pid='x_a8' onclick='return loadComments(&quot;x_a8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_b8'><A name='x_b8'></A>Para algo um pouco mais complicado, vamos dar uma olhada na soma de verificação Adler-32. Este é um algoritmo de soma de verificação popular, que concatena duas somas de 16 bits em um soma de verificação de 32 bits único. A primeira verificação é a soma de todos os bytes de entrada, mais um. A segunda é a soma de todos os valores intermediários da soma primeiro. Em cada caso, as somas são calculadas modulo 65521. Aqui está uma simples, a aplicação Java unoptimised. (É seguro ignorar isso se você não ler Java.)<SPAN id='comments_x_b8' class='comment'><A class='commenttoggle' id='toggle_x_b8' pid='x_b8' onclick='return loadComments(&quot;x_b8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Adler32.java:Adler32'></A><PRE id='Adler32.java:Adler32' class='programlisting'>public class Adler32 {
    private static final int base= 65521;

    public static int compute(byte[] data, int offset, int length) {
    int a= 1, b= 0;
    for (int i= offset; i &lt; offset+length; i++) {
        a= (a+ (data[i] &amp; 0xff)) % base;
        b= (a+b) % base;
    }
    return (b &lt;&lt; 16) | a;
    }
}</PRE><SPAN id='comments_Adler32.java:Adler32' class='comment'><A class='commenttoggle' id='toggle_Adler32.java:Adler32' pid='Adler32.java:Adler32' onclick='return loadComments(&quot;Adler32.java:Adler32&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_c8'><A name='x_c8'></A>Apesar de Adler-32 é uma soma simples, esse código não é muito fácil de ler por conta do bit girando envolvidos. Podemos fazer melhor com uma implementação de Haskell?<SPAN id='comments_x_c8' class='comment'><A class='commenttoggle' id='toggle_x_c8' pid='x_c8' onclick='return loadComments(&quot;x_c8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Adler32.hs:adler32'></A><PRE id='Adler32.hs:adler32' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Adler32.hs</code>
import Data.Char(ord)
import Data.Bits(shiftL,(.&amp;.),(.|.))

base= 65521

adler32 xs = ajudante 1 0 xs
    where ajudante a b (x:xs) = let a'= (a+ (ord x .&amp;. 0xff)) `mod` base
                                    b'= (a'+b) `mod` base
                                in ajudante a' b' xs
          ajudante a b _ = (b `shiftL` 16) .|. a</PRE><SPAN id='comments_Adler32.hs:adler32' class='comment'><A class='commenttoggle' id='toggle_Adler32.hs:adler32' pid='Adler32.hs:adler32' onclick='return loadComments(&quot;Adler32.hs:adler32&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_d8'><A name='x_d8'></A>Este código não é exatamente fácil de seguir do que o código Java, mas vamos olhar o que está acontecendo. Primeiro de tudo, nós introduzimos algumas novas funções. A função <CODE class='function'>shiftL</CODE> implementa um deslocamento lógico à esquerda; <CODE class='function'>(.&amp;.)</CODE> fornece bit a bit “<SPAN class='quote'>e</SPAN>”; e prevê <CODE class='function'>(.|.)</CODE> bit a bit “<SPAN class='quote'>ou</SPAN>”.<SPAN id='comments_x_d8' class='comment'><A class='commenttoggle' id='toggle_x_d8' pid='x_d8' onclick='return loadComments(&quot;x_d8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_sC1'><A name='x_sC1'></A>Mais uma vez, a nossa função <CODE class='function'>ajudante</CODE> é recursiva cauda. Nós viramos as duas variáveis, atualizado em cada iteração do loop em Java em parâmetros acumulador. Quando o nosso recursão termina no final da lista de entrada, calculamos nosso soma de verificação e devolvê-lo.<SPAN id='comments_x_sC1' class='comment'><A class='commenttoggle' id='toggle_x_sC1' pid='x_sC1' onclick='return loadComments(&quot;x_sC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_e8'><A name='x_e8'></A>Se dermos um passo para trás, podemos reestruturar nossas Haskell adler32 para ser mais semelhante a nossa função <CODE class='function'>meuSoma</CODE> anterior. Em vez de dois parâmetros acumulador, pode-se usar um par como o acumulador.<SPAN id='comments_x_e8' class='comment'><A class='commenttoggle' id='toggle_x_e8' pid='x_e8' onclick='return loadComments(&quot;x_e8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Adler32.hs:adler32_try2'></A><PRE id='Adler32.hs:adler32_try2' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Adler32.hs</code>
adler32_2 xs = ajudante (1,0) xs
    where ajudante (a,b) (x:xs) =
              let a'= (a + (ord x .&amp;. 0xff)) `mod` base
                  b'= (a'+b) `mod` base
              in ajudante (a',b') xs
          ajudante (a,b) _ = (b `shiftL` 16) .|. a</PRE><SPAN id='comments_Adler32.hs:adler32_try2' class='comment'><A class='commenttoggle' id='toggle_Adler32.hs:adler32_try2' pid='Adler32.hs:adler32_try2' onclick='return loadComments(&quot;Adler32.hs:adler32_try2&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_f8'><A name='x_f8'></A>Por que nós queremos fazer essa mudança, aparentemente sem sentido estrutural? Porque, como já vimos com <CODE class='function'>map</CODE> e <CODE class='function'>filter</CODE>, podemos extrair o comportamento comum compartilhado por <CODE class='function'>meuSoma</CODE> e <CODE class='function'>adler32_2</CODE> em uma função de ordem superior. Podemos descrever esse comportamento como “<SPAN class='quote'>fazer alguma coisa para cada elemento de uma lista, atualizando um acumulador em que estamos, e retornando o acumulador quando nós somos feitos</SPAN>”.<SPAN id='comments_x_f8' class='comment'><A class='commenttoggle' id='toggle_x_f8' pid='x_f8' onclick='return loadComments(&quot;x_f8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_g8'><A name='x_g8'></A>Este tipo de função é chamado de <SPAN class='emphasis'><EM>fold</EM></SPAN>, porque ela “<SPAN class='quote'>dobra</SPAN>” de uma lista. Existem dois tipos de fold sobre listas, <CODE class='function'>foldl</CODE> para dobrar à esquerda (no início) e <CODE class='function'>foldr</CODE> para dobrar a partir da direita (o fim).<SPAN id='comments_x_g8' class='comment'><A class='commenttoggle' id='toggle_x_g8' pid='x_g8' onclick='return loadComments(&quot;x_g8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.foldl'>A fold esquerda</H3></DIV></DIV></DIV><P id='x_cO1'><A name='x_cO1'></A>Aqui está a definição de <CODE class='function'>foldl</CODE>.<SPAN id='comments_x_cO1' class='comment'><A class='commenttoggle' id='toggle_x_cO1' pid='x_cO1' onclick='return loadComments(&quot;x_cO1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:foldl'></A><PRE id='Fold.hs:foldl' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl:: (a-&gt;b-&gt;a)-&gt; a-&gt; [b]-&gt; a
foldl passo zero (x:xs) = foldl passo (passo zero x) xs
foldl _     zero []     = zero</PRE><SPAN id='comments_Fold.hs:foldl' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:foldl' pid='Fold.hs:foldl' onclick='return loadComments(&quot;Fold.hs:foldl&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_h8'><A name='x_h8'></A>A função <CODE class='function'>foldl</CODE> leva um função de “<SPAN class='quote'>passo</SPAN>”, um valor inicial para o acumulador e uma lista. O “<SPAN class='quote'>passo</SPAN>” leva um acumulador e um elemento da lista, e retorna um valor acumulador novo. Todo <CODE class='function'>foldl</CODE> é chamar o “<SPAN class='quote'>passo</SPAN>” no acumulador atual e um elemento da lista, e passa o valor do acumulador novo para si mesmo recursivamente para consumir o restante da lista.<SPAN id='comments_x_h8' class='comment'><A class='commenttoggle' id='toggle_x_h8' pid='x_h8' onclick='return loadComments(&quot;x_h8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_i8'><A name='x_i8'></A>Referimo-nos a <CODE class='function'>foldl</CODE> como a “<SPAN class='quote'>fold esquerda</SPAN>” porque consome a lista da esquerda (a cabeça) para a direita.<SPAN id='comments_x_i8' class='comment'><A class='commenttoggle' id='toggle_x_i8' pid='x_i8' onclick='return loadComments(&quot;x_i8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_j8'><A name='x_j8'></A>Aqui está uma regravação de <CODE class='function'>meuSoma</CODE> usando <CODE class='function'>foldl</CODE>.<SPAN id='comments_x_j8' class='comment'><A class='commenttoggle' id='toggle_x_j8' pid='x_j8' onclick='return loadComments(&quot;x_j8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Sum.hs:foldlSum'></A><PRE id='Sum.hs:foldlSum' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Soma.hs</code>
foldlSoma xs = foldl passo 0 xs
    where passo acc x = acc + x</PRE><SPAN id='comments_Sum.hs:foldlSum' class='comment'><A class='commenttoggle' id='toggle_Sum.hs:foldlSum' pid='Sum.hs:foldlSum' onclick='return loadComments(&quot;Sum.hs:foldlSum&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_VL'><A name='x_VL'></A>Essa função local <CODE class='function'>passo</CODE> apenas soma dois números, então vamos simplesmente usar o operador de adição ao invés, e eliminar a cláusula desnecessária <CODE class='code'>where</CODE>clause. <SPAN id='comments_x_VL' class='comment'><A class='commenttoggle' id='toggle_x_VL' pid='x_VL' onclick='return loadComments(&quot;x_VL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Sum.hs:niceSum'></A><PRE id='Sum.hs:niceSum' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Soma.hs</code>
somaFina:: [Int]-&gt; Int
somaFina xs = foldl (+) 0 xs</PRE><SPAN id='comments_Sum.hs:niceSum' class='comment'><A class='commenttoggle' id='toggle_Sum.hs:niceSum' pid='Sum.hs:niceSum' onclick='return loadComments(&quot;Sum.hs:niceSum&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_k8'><A name='x_k8'></A>Observe como muito mais simples deste código é que o nosso <CODE class='function'>meuSoma</CODE> original? Não estamos mais usando recursão explícita, porque <CODE class='function'>foldl</CODE> cuida disso para nós. Nós simplificamos o nosso problema para baixo a duas coisas: que o valor inicial do acumulador deve ser (o segundo parâmetro para <CODE class='function'>foldl</CODE>), e como atualizar o acumulador (a função <CODE class='function'>(+)</CODE>). Como um bônus adicional, o nosso código é agora mais curto, também, o que torna mais fácil de entender.<SPAN id='comments_x_k8' class='comment'><A class='commenttoggle' id='toggle_x_k8' pid='x_k8' onclick='return loadComments(&quot;x_k8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_WL'><A name='x_WL'></A>Vamos ter um olhar mais profundo que <CODE class='function'>foldl</CODE> está fazendo aqui, manualmente, escrevendo cada etapa em sua avaliação, quando chamamos <CODE class='code'>somaFina [1,2,3]</CODE>. <SPAN id='comments_x_WL' class='comment'><A class='commenttoggle' id='toggle_x_WL' pid='x_WL' onclick='return loadComments(&quot;x_WL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:foldl.expand'></A><PRE id='Fold.hs:foldl.expand' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl (+) 0 (1:2:3:[])
          == foldl (+) (0 + 1)             (2:3:[])
          == foldl (+) ((0 + 1) + 2)       (3:[])
          == foldl (+) (((0 + 1) + 2) + 3) []
          ==           (((0 + 1) + 2) + 3)</PRE><SPAN id='comments_Fold.hs:foldl.expand' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:foldl.expand' pid='Fold.hs:foldl.expand' onclick='return loadComments(&quot;Fold.hs:foldl.expand&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_l8'><A name='x_l8'></A>Podemos reescrever <CODE class='function'>adler32_2</CODE> usando <CODE class='function'>foldl</CODE> deixar-nos concentrar nos detalhes que são importantes.<SPAN id='comments_x_l8' class='comment'><A class='commenttoggle' id='toggle_x_l8' pid='x_l8' onclick='return loadComments(&quot;x_l8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Adler32.hs:adler32_foldl'></A><PRE id='Adler32.hs:adler32_foldl' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Adler32.hs</code>
adler32_foldl xs = let (a,b) = foldl passo (1,0) xs
                   in (b `shiftL` 16) .|. a
    where passo (a,b) x = let a'= a + (ord x .&amp;. 0xff)
                          in (a' `mod` base, (a'+b) `mod` base)</PRE><SPAN id='comments_Adler32.hs:adler32_foldl' class='comment'><A class='commenttoggle' id='toggle_Adler32.hs:adler32_foldl' pid='Adler32.hs:adler32_foldl' onclick='return loadComments(&quot;Adler32.hs:adler32_foldl&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_m8'><A name='x_m8'></A>Aqui, o nosso acumulador é um par, assim que o resultado de <CODE class='function'>foldl</CODE> será, também. Puxamos o acumulador final distante quando retorna <CODE class='function'>foldl</CODE> e-bit mexer-lo em uma soma de verificação “<SPAN class='quote'>apropriada</SPAN>”.<SPAN id='comments_x_m8' class='comment'><A class='commenttoggle' id='toggle_x_m8' pid='x_m8' onclick='return loadComments(&quot;x_m8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id593448'>Por dobras usar folds, maps e filters?</H3></DIV></DIV></DIV><P id='x_n8'><A name='x_n8'></A>Uma rápida olhada revela que <CODE class='function'>adler32_foldl</CODE> não é realmente menor do que qualquer <CODE class='function'>adler32_2</CODE>. Por que devemos usar uma dobra neste caso? A vantagem reside no fato de que as dobras são extremamente comuns em Haskell, e eles têm um comportamento regular e previsível.<SPAN id='comments_x_n8' class='comment'><A class='commenttoggle' id='toggle_x_n8' pid='x_n8' onclick='return loadComments(&quot;x_n8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_o8'><A name='x_o8'></A>Isso significa que um leitor com um pouco de experiência terão um tempo mais fácil o entendimento a utilização de uma prega que o código que usa recursão explícita. A dobra não vai produzir nenhuma surpresa, mas o comportamento de uma função que recursivamente explicitamente não é imediatamente óbvio. recursão explícita nos obriga a ler atentamente para entender exatamente o que está acontecendo.<SPAN id='comments_x_o8' class='comment'><A class='commenttoggle' id='toggle_x_o8' pid='x_o8' onclick='return loadComments(&quot;x_o8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_p8'><A name='x_p8'></A>Esta linha de raciocínio se aplica a outras funções de biblioteca de ordem superior, incluindo aqueles que já vimos, <CODE class='function'>map</CODE> e <CODE class='function'>filter</CODE>. Porque eles são bibliotecas de funções com comportamentos bem definidos, só precisamos saber o que eles fazem uma vez, e nós vamos ter uma vantagem quando nós precisamos de compreender qualquer código que usa-los. Estas melhorias na legibilidade também transitar para escrever código. Assim que começar a pensar com funções de ordem superior em mente, vamos produzir um código conciso mais rapidamente.<SPAN id='comments_x_p8' class='comment'><A class='commenttoggle' id='toggle_x_p8' pid='x_p8' onclick='return loadComments(&quot;x_p8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.foldr.filter'>Folding da direita</H3></DIV></DIV></DIV><P id='x_x8'><A name='x_x8'></A>A contrapartida <CODE class='function'>foldl</CODE> é <CODE class='function'>foldr</CODE>, a que dobra a partir da direita de uma lista.<SPAN id='comments_x_x8' class='comment'><A class='commenttoggle' id='toggle_x_x8' pid='x_x8' onclick='return loadComments(&quot;x_x8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:foldr'></A><PRE id='Fold.hs:foldr' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldr:: (a-&gt;b-&gt;b)-&gt; b-&gt; [a]-&gt; b
foldr passo zero (x:xs) = passo x (foldr passo zero xs)
foldr _     zero []     = zero</PRE><SPAN id='comments_Fold.hs:foldr' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:foldr' pid='Fold.hs:foldr' onclick='return loadComments(&quot;Fold.hs:foldr&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_XL'><A name='x_XL'></A>Vamos seguir o mesmo processo de avaliação manual com <CODE class='function'>foldr (+) 0 [1,2,3]</CODE> como fizemos com <CODE class='function'>somaFina</CODE> na <A class='xref' href='#fp.foldl' title='seção&nbsp;chamada&nbsp;“A&nbsp;fold&nbsp;esquerda”'>seção chamada “A fold esquerda”</A>. <SPAN id='comments_x_XL' class='comment'><A class='commenttoggle' id='toggle_x_XL' pid='x_XL' onclick='return loadComments(&quot;x_XL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:foldr.expand'></A><PRE id='Fold.hs:foldr.expand' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldr (+) 0 (1:2:3:[])
          == 1 +           foldr (+) 0 (2:3:[])
          == 1 + (2 +      foldr (+) 0 (3:[])
          == 1 + (2 + (3 + foldr (+) 0 []))
          == 1 + (2 + (3 + 0))</PRE><SPAN id='comments_Fold.hs:foldr.expand' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:foldr.expand' pid='Fold.hs:foldr.expand' onclick='return loadComments(&quot;Fold.hs:foldr.expand&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_YL'><A name='x_YL'></A>A diferença entre <CODE class='function'>foldl</CODE> e <CODE class='function'>foldr</CODE>deve ser claro de olhar para onde os parênteses e os “<SPAN class='quote'>lista vazia</SPAN>” elementos aparecem. Com <CODE class='function'>foldl</CODE>, o elemento da lista é vazia à esquerda, e todo o grupo parênteses à esquerda. Com <CODE class='function'>foldr</CODE>, o valor <CODE class='varname'>zero</CODE> é à direita, eo grupo de parênteses para a direita.<SPAN id='comments_x_YL' class='comment'><A class='commenttoggle' id='toggle_x_YL' pid='x_YL' onclick='return loadComments(&quot;x_YL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_ZL'><A name='x_ZL'></A>Há uma explicação intuitiva linda <CODE class='function'>foldr</CODE> de obras como: ele substitui a lista vazia com o valor <CODE class='varname'>zero</CODE>, e cada construtor na lista com uma aplicação da função de passo.<SPAN id='comments_x_ZL' class='comment'><A class='commenttoggle' id='toggle_x_ZL' pid='x_ZL' onclick='return loadComments(&quot;x_ZL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:foldr.sub'></A><PRE id='Fold.hs:foldr.sub' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
1 : (2 : (3 : []))
1 + (2 + (3 + 0 ))</PRE><SPAN id='comments_Fold.hs:foldr.sub' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:foldr.sub' pid='Fold.hs:foldr.sub' onclick='return loadComments(&quot;Fold.hs:foldr.sub&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_y8'><A name='x_y8'></A>À primeira vista, <CODE class='function'>foldr</CODE> pode parecer menos úteis do que <CODE class='function'>foldl</CODE>: o uso que é uma função que se dobra a partir da direita? Mas considere a função <CODE class='function'>filter</CODE> do Prelude, que a última vez que encontrou na <A class='xref' href='#fp.filter' title='seção&nbsp;chamada&nbsp;“Seleção&nbsp;de&nbsp;peças&nbsp;de&nbsp;entrada”'>seção chamada “Seleção de peças de entrada”</A>. Se escrevermos <CODE class='function'>filter</CODE> usando recursão explícita, será algo parecido com isso.<SPAN id='comments_x_y8' class='comment'><A class='commenttoggle' id='toggle_x_y8' pid='x_y8' onclick='return loadComments(&quot;x_y8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:filter'></A><PRE id='Fold.hs:filter' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
filter:: (a-&gt;Bool)-&gt; [a]-&gt; [a]
filter p []   = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs</PRE><SPAN id='comments_Fold.hs:filter' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:filter' pid='Fold.hs:filter' onclick='return loadComments(&quot;Fold.hs:filter&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_z8'><A name='x_z8'></A>Talvez de forma surpreendente, no entanto, pode-se escrever <CODE class='function'>filter</CODE> como um fold, usando <CODE class='function'>foldr</CODE>.<SPAN id='comments_x_z8' class='comment'><A class='commenttoggle' id='toggle_x_z8' pid='x_z8' onclick='return loadComments(&quot;x_z8&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:myFilter'></A><PRE id='Fold.hs:myFilter' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
meuFilter p xs = foldr passo [] xs
    where passo x ys | p x       = x : ys
                     | otherwise = ys</PRE><SPAN id='comments_Fold.hs:myFilter' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:myFilter' pid='Fold.hs:myFilter' onclick='return loadComments(&quot;Fold.hs:myFilter&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_A9'><A name='x_A9'></A>Este é o tipo de definição que poderia nos causar uma dor de cabeça, por isso vamos examiná-lo em um pouco de profundidade. Como <CODE class='function'>foldl</CODE>, <CODE class='function'>foldr</CODE> tem uma função e um caso-base (o que fazer quando a lista de entrada está vazia) como argumentos. Da leitura do tipo de <CODE class='function'>filter</CODE>, nós sabemos que a nossa função <CODE class='function'>meuFilter</CODE> deve retornar uma lista do mesmo tipo que ele consome, então o caso de base deve ser uma lista desse tipo e, a função de auxiliar <CODE class='function'>passo</CODE> deve retornar uma lista.<SPAN id='comments_x_A9' class='comment'><A class='commenttoggle' id='toggle_x_A9' pid='x_A9' onclick='return loadComments(&quot;x_A9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_B9'><A name='x_B9'></A>Como sabemos que <CODE class='function'>foldr </CODE> calls <CODE class='function'>passo</CODE>  convida um elemento da lista de entrada de cada vez, com o acumulador como seu segundo argumento, o <CODE class='function'>passo</CODE> deve ser muito simples. Se o predicado retorna <CODE class='function'>True</CODE>, ele empurra esse elemento para a lista acumulados, caso contrário, ele sai da lista intocada.<SPAN id='comments_x_B9' class='comment'><A class='commenttoggle' id='toggle_x_B9' pid='x_B9' onclick='return loadComments(&quot;x_B9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_C9'><A name='x_C9'></A>A classe de funções que podemos expressar utilizando <CODE class='function'>foldr</CODE> é chamada <SPAN class='emphasis'><EM>recursiva primitiva</EM></SPAN>. Um número surpreendentemente grande de funções de manipulação de lista são recursivas primitivas. Por exemplo, aqui está a <CODE class='function'>map</CODE> escrita em termos de <CODE class='function'>foldr</CODE>.<SPAN id='comments_x_C9' class='comment'><A class='commenttoggle' id='toggle_x_C9' pid='x_C9' onclick='return loadComments(&quot;x_C9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:myMap'></A><PRE id='Fold.hs:myMap' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
meuMap:: (a-&gt;b)-&gt; [a]-&gt; [b]
meuMap f xs = foldr passo [] xs
    where passo x ys = f x : ys</PRE><SPAN id='comments_Fold.hs:myMap' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:myMap' pid='Fold.hs:myMap' onclick='return loadComments(&quot;Fold.hs:myMap&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_D9'><A name='x_D9'></A>Na verdade, podemos até escrever <CODE class='function'>foldl</CODE> usando <CODE class='function'>foldr</CODE>!<SPAN id='comments_x_D9' class='comment'><A class='commenttoggle' id='toggle_x_D9' pid='x_D9' onclick='return loadComments(&quot;x_D9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:myFoldl'></A><PRE id='Fold.hs:myFoldl' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
meuFoldl:: (a-&gt;b-&gt;a)-&gt; a-&gt; [b]-&gt; a
meuFoldl f z xs = foldr passo id xs z
    where passo x g a = g (f a x)</PRE><SPAN id='comments_Fold.hs:myFoldl' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:myFoldl' pid='Fold.hs:myFoldl' onclick='return loadComments(&quot;Fold.hs:myFoldl&quot;)' href='comments: show / hide'>?? comments</A></SPAN><DIV class='tip'><TABLE border='0' summary='Tip: Compreender foldl em termos de foldr'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Tip]' src='support/figs/tip.png'></TD><TH align='left'>Compreender foldl em termos de foldr</TH></TR><TR><TD align='left' valign='top'><P id='x_E9'><A name='x_E9'></A>Se você quiser definir-se um desafio contínuo, tente seguir a definição acima de <CODE class='function'>foldl</CODE> usando <CODE class='function'>foldr</CODE>. Esteja avisado: esta não é trivial! Você pode querer ter as seguintes ferramentas na mão: algumas pílulas de dor de cabeça e um copo de água, <SPAN class='command'><STRONG>ghci</STRONG></SPAN>(para que você possa descobrir o que faz a função <CODE class='function'>id</CODE>), e um lápis e papel.<SPAN id='comments_x_E9' class='comment'><A class='commenttoggle' id='toggle_x_E9' pid='x_E9' onclick='return loadComments(&quot;x_E9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_aL'><A name='x_aL'></A>Você vai querer seguir o mesmo processo de avaliação manual como descrito acima para ver o que <CODE class='function'>foldl</CODE> e <CODE class='function'>foldr</CODE> estavam realmente fazendo. Se você ficar preso, você pode encontrar a tarefa mais fácil, depois de ler a <A class='xref' href='#fp.partialapp' title='seção&nbsp;chamada&nbsp;“Aplicação&nbsp;da&nbsp;função&nbsp;parcial&nbsp;e&nbsp;currying”'>seção chamada “Aplicação da função parcial e currying”</A>.<SPAN id='comments_x_aL' class='comment'><A class='commenttoggle' id='toggle_x_aL' pid='x_aL' onclick='return loadComments(&quot;x_aL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV><P id='x_H9'><A name='x_H9'></A>Voltando à nossa explicação anterior <CODE class='function'>foldr</CODE> intuitiva do que faz, uma outra maneira útil de pensar sobre isso é que ele <SPAN class='emphasis'><EM>transforma</EM></SPAN> sua entrada de lista. Os dois primeiros argumentos são “<SPAN class='quote'>o que fazer com cada elemento da cauda da cabeça / da lista</SPAN>”, e “<SPAN class='quote'>o que para substituir o final da lista</SPAN>”.<SPAN id='comments_x_H9' class='comment'><A class='commenttoggle' id='toggle_x_H9' pid='x_H9' onclick='return loadComments(&quot;x_H9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_I9'><A name='x_I9'></A>A “<SPAN class='quote'>identidade</SPAN>” transformação com <CODE class='function'>foldr</CODE>assim substitui a lista vazia com ela mesma, e aplica-se o construtor de lista para cada cabeça / cauda par:x<SPAN id='comments_x_I9' class='comment'><A class='commenttoggle' id='toggle_x_I9' pid='x_I9' onclick='return loadComments(&quot;x_I9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:identity'></A><PRE id='Fold.hs:identity' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
identidade:: [a]-&gt; [a]
identidade xs = foldr (:) [] xs</PRE><SPAN id='comments_Fold.hs:identity' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:identity' pid='Fold.hs:identity' onclick='return loadComments(&quot;Fold.hs:identity&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_J9'><A name='x_J9'></A>Ela transforma uma lista em uma cópia de si mesmo.<SPAN id='comments_x_J9' class='comment'><A class='commenttoggle' id='toggle_x_J9' pid='x_J9' onclick='return loadComments(&quot;x_J9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='fold.ghci:identity'></A><PRE id='fold.ghci:identity' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>identity [1,2,3]
</CODE></STRONG><code class='machineMsg'>[1,2,3]
</code></PRE> <SPAN id='comments_fold.ghci:identity' class='comment'><A class='commenttoggle' id='toggle_fold.ghci:identity' onclick='return loadComments(&quot;fold.ghci:identity&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_K9'><A name='x_K9'></A>Se <CODE class='function'>foldr</CODE> substitui o fim de uma lista com algum outro valor, isto dá-nos uma outra maneira de olhar para afunção Haskell de acréscimo das listas, <CODE class='function'>(++)</CODE>.<SPAN id='comments_x_K9' class='comment'><A class='commenttoggle' id='toggle_x_K9' pid='x_K9' onclick='return loadComments(&quot;x_K9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='fold.ghci:append.builtin'></A><PRE id='fold.ghci:append.builtin' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>[1,2,3] ++ [4,5,6]
</CODE></STRONG><code class='machineMsg'>[1,2,3,4,5,6]
</code></PRE> <SPAN id='comments_fold.ghci:append.builtin' class='comment'><A class='commenttoggle' id='toggle_fold.ghci:append.builtin' onclick='return loadComments(&quot;fold.ghci:append.builtin&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_L9'><A name='x_L9'></A>Tudo o que temos de fazer para anexar uma lista para outra é substituir essa lista segundo para o fim da nossa primeira lista.<SPAN id='comments_x_L9' class='comment'><A class='commenttoggle' id='toggle_x_L9' pid='x_L9' onclick='return loadComments(&quot;x_L9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:append'></A><PRE id='Fold.hs:append' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
anexado:: [a]-&gt; [a]-&gt; [a]
anexado xs ys = foldr (:) ys xs</PRE><SPAN id='comments_Fold.hs:append' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:append' pid='Fold.hs:append' onclick='return loadComments(&quot;Fold.hs:append&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_M9'><A name='x_M9'></A>Vamos tentar fazer isso.<SPAN id='comments_x_M9' class='comment'><A class='commenttoggle' id='toggle_x_M9' pid='x_M9' onclick='return loadComments(&quot;x_M9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='fold.ghci:append'></A><PRE id='fold.ghci:append' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>anexado [1,2,3] [4,5,6]
</CODE></STRONG><code class='machineMsg'>[1,2,3,4,5,6]
</code></PRE> <SPAN id='comments_fold.ghci:append' class='comment'><A class='commenttoggle' id='toggle_fold.ghci:append' onclick='return loadComments(&quot;fold.ghci:append&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_bL'><A name='x_bL'></A>Aqui, podemos substituir cada construtor lista com outro construtor da lista, mas substituir a lista vazia com a lista que deseja acrescentar sobre o fim da nossa primeira lista.<SPAN id='comments_x_bL' class='comment'><A class='commenttoggle' id='toggle_x_bL' pid='x_bL' onclick='return loadComments(&quot;x_bL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_P9'><A name='x_P9'></A>Como o nosso tratamento prolongado das pregas devem indicar, a função <CODE class='function'>foldr</CODE> é quase tão importante membro da nossa caixa de ferramentas de programação lista das funções mais básicas lista vimos na <A class='xref' href='#fp.lists' title='seção&nbsp;chamada&nbsp;“Trabalhar&nbsp;com&nbsp;as&nbsp;listas”'>seção chamada “Trabalhar com as listas”</A>. Pode consumir e produzir uma lista de forma incremental, o que o torna útil para a gravação de dados preguiçoso código de processamento.<SPAN id='comments_x_P9' class='comment'><A class='commenttoggle' id='toggle_x_P9' pid='x_P9' onclick='return loadComments(&quot;x_P9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id594142'>Folds esquerdos, preguiça e space leaks</H3></DIV></DIV></DIV><P id='x_Q9'><A name='x_Q9'></A>Para manter o nosso simples discussão inicial, usamos <CODE class='function'>foldl</CODE> durante a maior parte desta seção. Isso é conveniente para o teste, mas nunca iremos usar <CODE class='function'>foldl</CODE> na prática.<SPAN id='comments_x_Q9' class='comment'><A class='commenttoggle' id='toggle_x_Q9' pid='x_Q9' onclick='return loadComments(&quot;x_Q9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_tC1'><A name='x_tC1'></A>A razão tem a ver com a avaliação não-estrita Haskell. Se aplicarmos <CODE class='code'>foldl (+) [1,2,3]</CODE>, que avalia a expressão <CODE class='code'>(((0 + 1) + 2) + 3)</CODE>. Podemos ver isso acontecer se rever a forma como a função é expandida.<SPAN id='comments_x_tC1' class='comment'><A class='commenttoggle' id='toggle_x_tC1' pid='x_tC1' onclick='return loadComments(&quot;x_tC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id594184'></A><PRE id='id594184' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl (+) 0 (1:2:3:[])
          == foldl (+) (0 + 1)             (2:3:[])
          == foldl (+) ((0 + 1) + 2)       (3:[])
          == foldl (+) (((0 + 1) + 2) + 3) []
          ==           (((0 + 1) + 2) + 3)</PRE><SPAN id='comments_id594184' class='comment'><A class='commenttoggle' id='toggle_id594184' pid='id594184' onclick='return loadComments(&quot;id594184&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_uC1'><A name='x_uC1'></A>A expressão final não será avaliada a <CODE class='code'>6</CODE> até que seu valor é exigido. Antes que seja avaliada, ele deve ser armazenado como uma conversão. Não surpreendentemente, uma conversão é mais caro do que guardar um número único, e os mais complexos a expressão thunked, o espaço mais precisa. Para algo mais barata, como aritmética, thunking um expressão é computacionalmente mais caro do que avaliá-lo imediatamente. Temos, assim, acabam pagando tanto no espaço quanto no tempo.<SPAN id='comments_x_uC1' class='comment'><A class='commenttoggle' id='toggle_x_uC1' pid='x_uC1' onclick='return loadComments(&quot;x_uC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_vC1'><A name='x_vC1'></A>Quando <SPAN class='application'>GHC</SPAN> está avaliando uma expressão thunked, ele usa uma pilha interna para isso. Como uma expressão thunked poderia ser infinitamente grande, o <SPAN class='application'>GHC</SPAN> coloca um limite fixo sobre o tamanho máximo da pilha. Graças a esse limite, podemos tentar uma expressão de grande thunked em <SPAN class='command'><STRONG>ghci</STRONG></SPAN> sem precisar se preocupar que ele possa consumir toda a memória.<SPAN id='comments_x_vC1' class='comment'><A class='commenttoggle' id='toggle_x_vC1' pid='x_vC1' onclick='return loadComments(&quot;x_vC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='thunky.ghci:sum'></A><PRE id='thunky.ghci:sum' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>foldl (+) 0 [1..1000]
</CODE></STRONG><code class='machineMsg'>500500
</code></PRE> <SPAN id='comments_thunky.ghci:sum' class='comment'><A class='commenttoggle' id='toggle_thunky.ghci:sum' onclick='return loadComments(&quot;thunky.ghci:sum&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_wC1'><A name='x_wC1'></A>De olhar para a expansão acima, podemos supor que este cria uma conversão que consiste em 1.000 inteiros e 999 pedidos de <CODE class='function'>(+)</CODE>. Isso é um monte de memória e esforço para representar um único número! Com uma expressão maior, embora o tamanho ainda é modesta, os resultados são mais dramáticos.<SPAN id='comments_x_wC1' class='comment'><A class='commenttoggle' id='toggle_x_wC1' pid='x_wC1' onclick='return loadComments(&quot;x_wC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='thunky.ghci:overflow'></A><PRE id='thunky.ghci:overflow' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>foldl (+) 0 [1..1000000]
</CODE></STRONG><code class='machineMsg'>*** Exception: stack overflow
</code></PRE> <SPAN id='comments_thunky.ghci:overflow' class='comment'><A class='commenttoggle' id='toggle_thunky.ghci:overflow' onclick='return loadComments(&quot;thunky.ghci:overflow&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_xC1'><A name='x_xC1'></A>Em expressões pequenas, <CODE class='function'>foldl</CODE> irá funcionar corretamente, mas lentamente, devido à sobrecarga thunking em que incorre. Nós nos referimos a este thunking invisível como um <SPAN class='emphasis'><EM>space leak</EM></SPAN>(vazamento de espaço), porque o nosso código está funcionando normalmente, mas com muito mais memória do que deveria.<SPAN id='comments_x_xC1' class='comment'><A class='commenttoggle' id='toggle_x_xC1' pid='x_xC1' onclick='return loadComments(&quot;x_xC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_yC1'><A name='x_yC1'></A>Em expressões maiores, código com um vazamento de espaço simplesmente falham, como acima. Um space leak com <CODE class='code'>foldl</CODE> é um obstáculo clássico para novos programadores Haskell. Felizmente, isso é fácil de evitar.<SPAN id='comments_x_yC1' class='comment'><A class='commenttoggle' id='toggle_x_yC1' pid='x_yC1' onclick='return loadComments(&quot;x_yC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_zC1'><A name='x_zC1'></A>O módulo <CODE class='code'>Data.List</CODE> define uma função chamada <CODE class='function'>foldl'</CODE> que é semelhante ao <CODE class='function'>foldl</CODE>, mas não construir thunks. A diferença de comportamento entre os dois é óbvia.<SPAN id='comments_x_zC1' class='comment'><A class='commenttoggle' id='toggle_x_zC1' pid='x_zC1' onclick='return loadComments(&quot;x_zC1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='thunky.ghci:strict'></A><PRE id='thunky.ghci:strict' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>foldl (+) 0 [1..1000000]
</CODE></STRONG><code class='machineMsg'>*** Exception: stack overflow
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:module +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>foldl' (+) 0 [1..1000000]
</CODE></STRONG><code class='machineMsg'>500000500000
</code></PRE> <SPAN id='comments_thunky.ghci:strict' class='comment'><A class='commenttoggle' id='toggle_thunky.ghci:strict' onclick='return loadComments(&quot;thunky.ghci:strict&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_AD1'><A name='x_AD1'></A>Devido ao comportamento de thunking de <CODE class='function'>foldl</CODE>, é prudente evitar essa função em programas reais: mesmo que não falham completamente, será desnecessariamente ineficiente. Em vez disso, importa <CODE class='code'>Data.List</CODE> e utilisa <CODE class='function'>foldl'</CODE>.<SPAN id='comments_x_AD1' class='comment'><A class='commenttoggle' id='toggle_x_AD1' pid='x_AD1' onclick='return loadComments(&quot;x_AD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='fp.fold.exercises'>Exercícios</H3></DIV></DIV></DIV><DIV class='qandaset'><TABLE border='0' summary='Q and A Set'><COL align='left' width='1%'><TBODY><TR class='question'><TD align='left' valign='top'><P><B>1.</B></P></TD><TD align='left' valign='top'><P id='x_R9'><A name='x_R9'></A>Use uma dobra (escolhendo a tampa adequada fará seu código muito mais simples) para reescrever e melhorar a função <CODE class='function'>asInt</CODE> da <A class='xref' href='#fp.tailrecursion' title='secção&nbsp;chamada&nbsp;“Recursão&nbsp;explícita”'>secção chamada “Recursão explícita”</A>.<SPAN id='comments_x_R9' class='comment'><A class='commenttoggle' id='toggle_x_R9' pid='x_R9' onclick='return loadComments(&quot;x_R9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:asInt_fold'></A><PRE id='ch04.exercises.hs:asInt_fold' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
asInt_fold:: String-&gt; Int</PRE><SPAN id='comments_ch04.exercises.hs:asInt_fold' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:asInt_fold' pid='ch04.exercises.hs:asInt_fold' onclick='return loadComments(&quot;ch04.exercises.hs:asInt_fold&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_S9'><A name='x_S9'></A>Sua função deve se comportar como se segue.<SPAN id='comments_x_S9' class='comment'><A class='commenttoggle' id='toggle_x_S9' pid='x_S9' onclick='return loadComments(&quot;x_S9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.ghci:asInt_fold'></A><PRE id='ch04.exercises.ghci:asInt_fold' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "101"
</CODE></STRONG><code class='machineMsg'>101
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "-31337"
</CODE></STRONG><code class='machineMsg'>-31337
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "1798"
</CODE></STRONG><code class='machineMsg'>1798
</code></PRE> <SPAN id='comments_ch04.exercises.ghci:asInt_fold' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.ghci:asInt_fold' onclick='return loadComments(&quot;ch04.exercises.ghci:asInt_fold&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_T9'><A name='x_T9'></A>Estenda a sua função para tratar os seguintes tipos de condições excepcionais chamando <CODE class='function'>error</CODE>.<SPAN id='comments_x_T9' class='comment'><A class='commenttoggle' id='toggle_x_T9' pid='x_T9' onclick='return loadComments(&quot;x_T9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.ghci:asInt_fold.errors'></A><PRE id='ch04.exercises.ghci:asInt_fold.errors' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold ""
</CODE></STRONG><code class='machineMsg'>0
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "-"
</CODE></STRONG><code class='machineMsg'>0
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "-3"
</CODE></STRONG><code class='machineMsg'>-3
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "2.7"
</CODE></STRONG><code class='machineMsg'>*** Exception: Char.digitToInt: not a digit '.'
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_fold "314159265358979323846"
</CODE></STRONG><code class='machineMsg'>564616105916946374
</code></PRE> <SPAN id='comments_ch04.exercises.ghci:asInt_fold.errors' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.ghci:asInt_fold.errors' onclick='return loadComments(&quot;ch04.exercises.ghci:asInt_fold.errors&quot;)' href='comment: add'>?? comments</A></SPAN></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>2.</B></P></TD><TD align='left' valign='top'><P id='x_U9'><A name='x_U9'></A>A função <CODE class='function'>asInt_fold</CODE> usa <CODE class='function'>error</CODE>, por isso seus chamadores não pode manipular erros. Reescrevê-lo para corrigir esse problema.<SPAN id='comments_x_U9' class='comment'><A class='commenttoggle' id='toggle_x_U9' pid='x_U9' onclick='return loadComments(&quot;x_U9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:asInt_either'></A><PRE id='ch04.exercises.hs:asInt_either' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
type ErrorMessage = String
asInt_either:: String-&gt; Either ErrorMessage Int</PRE><SPAN id='comments_ch04.exercises.hs:asInt_either' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:asInt_either' pid='ch04.exercises.hs:asInt_either' onclick='return loadComments(&quot;ch04.exercises.hs:asInt_either&quot;)' href='comments: show / hide'>?? comments</A></SPAN><A name='ch04.exercises.ghci:asInt_either'></A><PRE id='ch04.exercises.ghci:asInt_either' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_either "33"
</CODE></STRONG><code class='machineMsg'>Right 33
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>asInt_either "foo"
</CODE></STRONG><code class='machineMsg'>Left "non-digit 'o'"
</code></PRE> <SPAN id='comments_ch04.exercises.ghci:asInt_either' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.ghci:asInt_either' onclick='return loadComments(&quot;ch04.exercises.ghci:asInt_either&quot;)' href='comment: add'>?? comments</A></SPAN></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>3.</B></P></TD><TD align='left' valign='top'><P id='x_V9'><A name='x_V9'></A>A função Prelude <CODE class='function'>concat</CODE>concatena uma lista de listas em uma única lista, e digite o seguinte.<SPAN id='comments_x_V9' class='comment'><A class='commenttoggle' id='toggle_x_V9' pid='x_V9' onclick='return loadComments(&quot;x_V9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:concat'></A><PRE id='ch04.exercises.hs:concat' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
concat:: [[a]]-&gt; [a]</PRE><SPAN id='comments_ch04.exercises.hs:concat' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:concat' pid='ch04.exercises.hs:concat' onclick='return loadComments(&quot;ch04.exercises.hs:concat&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_W9'><A name='x_W9'></A>Escreva a sua própria definição de <CODE class='function'>concat</CODE> usando <CODE class='function'>foldr</CODE>. <SPAN id='comments_x_W9' class='comment'><A class='commenttoggle' id='toggle_x_W9' pid='x_W9' onclick='return loadComments(&quot;x_W9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>4.</B></P></TD><TD align='left' valign='top'><P id='x_X9'><A name='x_X9'></A>Escreva a sua própria definição da função padrão <CODE class='function'>takeWhile</CODE>, primeiro usando recursão explícita, então <CODE class='function'>foldr</CODE>.<SPAN id='comments_x_X9' class='comment'><A class='commenttoggle' id='toggle_x_X9' pid='x_X9' onclick='return loadComments(&quot;x_X9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>5.</B></P></TD><TD align='left' valign='top'><P id='x_Z9'><A name='x_Z9'></A>O módulo <CODE class='code'>Data.List</CODE> define uma função, <CODE class='function'>groupBy</CODE>, que tem o seguinte tipo.<SPAN id='comments_x_Z9' class='comment'><A class='commenttoggle' id='toggle_x_Z9' pid='x_Z9' onclick='return loadComments(&quot;x_Z9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.exercises.hs:groupBy'></A><PRE id='ch04.exercises.hs:groupBy' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ch04.exercises.hs</code>
groupBy:: (a-&gt;a-&gt;Bool)-&gt; [a]-&gt; [[a]]</PRE><SPAN id='comments_ch04.exercises.hs:groupBy' class='comment'><A class='commenttoggle' id='toggle_ch04.exercises.hs:groupBy' pid='ch04.exercises.hs:groupBy' onclick='return loadComments(&quot;ch04.exercises.hs:groupBy&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_a9'><A name='x_a9'></A>Use <SPAN class='command'><STRONG>ghci</STRONG></SPAN> para carregar o módulo <CODE class='code'>Data.List</CODE> e descobrir o que <CODE class='function'>groupBy</CODE> faz, em seguida, escrever sua própria implementação usando uma fold.<SPAN id='comments_x_a9' class='comment'><A class='commenttoggle' id='toggle_x_a9' pid='x_a9' onclick='return loadComments(&quot;x_a9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR><TR class='question'><TD align='left' valign='top'><P><B>6.</B></P></TD><TD align='left' valign='top'><P id='x_b9'><A name='x_b9'></A>Quantas das seguintes funções Prelude pode-se reescrever usando dobras lista?<SPAN id='comments_x_b9' class='comment'><A class='commenttoggle' id='toggle_x_b9' pid='x_b9' onclick='return loadComments(&quot;x_b9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><DIV class='itemizedlist'><UL type='disc'><LI><P id='x_BD1'><A name='x_BD1'></A><CODE class='function'>any</CODE><SPAN id='comments_x_BD1' class='comment'><A class='commenttoggle' id='toggle_x_BD1' pid='x_BD1' onclick='return loadComments(&quot;x_BD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></LI><LI><P id='x_CD1'><A name='x_CD1'></A><CODE class='function'>cycle</CODE><SPAN id='comments_x_CD1' class='comment'><A class='commenttoggle' id='toggle_x_CD1' pid='x_CD1' onclick='return loadComments(&quot;x_CD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></LI><LI><P id='x_DD1'><A name='x_DD1'></A><CODE class='function'>words</CODE><SPAN id='comments_x_DD1' class='comment'><A class='commenttoggle' id='toggle_x_DD1' pid='x_DD1' onclick='return loadComments(&quot;x_DD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></LI><LI><P id='x_ED1'><A name='x_ED1'></A><CODE class='function'>unlines</CODE><SPAN id='comments_x_ED1' class='comment'><A class='commenttoggle' id='toggle_x_ED1' pid='x_ED1' onclick='return loadComments(&quot;x_ED1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></LI></UL></DIV><P id='x_FD1'><A name='x_FD1'></A>Para essas funções, onde você pode usar tanto <CODE class='function'>foldl'</CODE> ou <CODE class='function'>foldr</CODE>, que é mais adequado em cada caso?<SPAN id='comments_x_FD1' class='comment'><A class='commenttoggle' id='toggle_x_FD1' pid='x_FD1' onclick='return loadComments(&quot;x_FD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id594881'>Leitura complementar</H3></DIV></DIV></DIV><P id='x_c9'><A name='x_c9'></A>O artigo [<SPAN class='citation'><A href='bibliography.html#bib.hutton99' class='biblioref' title='[Hutton99]'><ABBR class='abbrev'>Hutton99</ABBR></A></SPAN>] é um excelente e profundo tutorial pregas cobertura. Ele inclui muitos exemplos de como usar técnicas simples e sistemática de cálculo para transformar funções que usam recursão explícita em folds.<SPAN id='comments_x_c9' class='comment'><A class='commenttoggle' id='toggle_x_c9' pid='x_c9' onclick='return loadComments(&quot;x_c9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.anonymous'>Funções (lambda) anónimos</H2></DIV></DIV></DIV><P id='x_d9'><A name='x_d9'></A>Em muitas das definições de funções que vimos até agora, nós escrevemos funções de auxiliar de curta duração.<SPAN id='comments_x_d9' class='comment'><A class='commenttoggle' id='toggle_x_d9' pid='x_d9' onclick='return loadComments(&quot;x_d9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Partial.hs:isInAny'></A><PRE id='Partial.hs:isInAny' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Parcial.hs</code>
isInAny needle haystack = any inSequence haystack
    where inSequence s = needle `isInfixOf` s</PRE><SPAN id='comments_Partial.hs:isInAny' class='comment'><A class='commenttoggle' id='toggle_Partial.hs:isInAny' pid='Partial.hs:isInAny' onclick='return loadComments(&quot;Partial.hs:isInAny&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_e9'><A name='x_e9'></A>Haskell lets us write completely anonymous functions, which we can use to avoid the need to give names to our helper functions. Anonymous functions are often called “<SPAN class='quote'>lambda</SPAN>” functions, in a nod to their heritage in the lambda calculus. We introduce an anonymous function with a backslash character, <CODE class='code'>\</CODE>, pronounced <SPAN class='emphasis'><EM>lambda</EM></SPAN><SUP>[<A name='id594951' href='#ftn.id594951' class='footnote'>9</A>]</SUP>. This is followed by the function's arguments (which can include patterns), then an arrow <CODE class='code'>-&gt;</CODE>to introduce the function's body. <SPAN id='comments_x_e9' class='comment'><A class='commenttoggle' id='toggle_x_e9' pid='x_e9' onclick='return loadComments(&quot;x_e9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_f9'><A name='x_f9'></A>Lambdas are most easily illustrated by example. Here's a rewrite of <CODE class='function'>isInAny</CODE>using an anonymous function. <SPAN id='comments_x_f9' class='comment'><A class='commenttoggle' id='toggle_x_f9' pid='x_f9' onclick='return loadComments(&quot;x_f9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Partial.hs:isInAny2'></A><PRE id='Partial.hs:isInAny2' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Parcial.hs</code>
isInAny2 needle haystack = any (\s-&gt; needle `isInfixOf` s) haystack</PRE><SPAN id='comments_Partial.hs:isInAny2' class='comment'><A class='commenttoggle' id='toggle_Partial.hs:isInAny2' pid='Partial.hs:isInAny2' onclick='return loadComments(&quot;Partial.hs:isInAny2&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_g9'><A name='x_g9'></A>Nós colocaremos o lambda parênteses aqui para que Haskell pode dizer onde o corpo da função termina.<SPAN id='comments_x_g9' class='comment'><A class='commenttoggle' id='toggle_x_g9' pid='x_g9' onclick='return loadComments(&quot;x_g9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_h9'><A name='x_h9'></A>Funções anónimos se comportar de forma idêntica em todos os aspectos das funções que têm nomes, mas Haskell coloca algumas restrições importantes sobre como podemos defini-los. O mais importante, enquanto nós podemos escrever uma função normal usando várias cláusulas contendo diferentes modelos e os guardas, um lambda pode ter apenas uma única cláusula na sua definição.<SPAN id='comments_x_h9' class='comment'><A class='commenttoggle' id='toggle_x_h9' pid='x_h9' onclick='return loadComments(&quot;x_h9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_i9'><A name='x_i9'></A>A limitação a uma única cláusula restringe como podemos usar os padrões na definição de uma lambda. Vamos escrever uma função geralmente normal, com várias cláusulas para cobrir possibilidades diferentes padrões de correspondência.<SPAN id='comments_x_i9' class='comment'><A class='commenttoggle' id='toggle_x_i9' pid='x_i9' onclick='return loadComments(&quot;x_i9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Lambda.hs:safeHead'></A><PRE id='Lambda.hs:safeHead' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Lambda.hs</code>
headSeguro (x:_) = Just x
headSeguro _ = Nothing</PRE><SPAN id='comments_Lambda.hs:safeHead' class='comment'><A class='commenttoggle' id='toggle_Lambda.hs:safeHead' pid='Lambda.hs:safeHead' onclick='return loadComments(&quot;Lambda.hs:safeHead&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_j9'><A name='x_j9'></A>Mas como não podemos escrever várias cláusulas para definir uma lambda, devemos estar certos de que qualquer padrão que usamos fósforo.<SPAN id='comments_x_j9' class='comment'><A class='commenttoggle' id='toggle_x_j9' pid='x_j9' onclick='return loadComments(&quot;x_j9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Lambda.hs:unsafeHead'></A><PRE id='Lambda.hs:unsafeHead' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Lambda.hs</code>
headInseguro = \(x:_)-&gt; x</PRE><SPAN id='comments_Lambda.hs:unsafeHead' class='comment'><A class='commenttoggle' id='toggle_Lambda.hs:unsafeHead' pid='Lambda.hs:unsafeHead' onclick='return loadComments(&quot;Lambda.hs:unsafeHead&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_k9'><A name='x_k9'></A>Esta definição de <CODE class='function'>headInseguro</CODE> vai explodir em nossas faces se chamá-lo com um valor em que a correspondência de padrão falhar.<SPAN id='comments_x_k9' class='comment'><A class='commenttoggle' id='toggle_x_k9' pid='x_k9' onclick='return loadComments(&quot;x_k9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='lambda.ghci:unsafeHead'></A><PRE id='lambda.ghci:unsafeHead' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t headInseguro
</CODE></STRONG><code class='machineMsg'>headInseguro :: [t] -&gt; t
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>headInseguro [1]
</CODE></STRONG><code class='machineMsg'>1
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>headInseguro []
</CODE></STRONG><code class='machineMsg'>*** Exception: Lambda.hs:7:13-23: Non-exhaustive patterns in lambda

</code></PRE> <SPAN id='comments_lambda.ghci:unsafeHead' class='comment'><A class='commenttoggle' id='toggle_lambda.ghci:unsafeHead' onclick='return loadComments(&quot;lambda.ghci:unsafeHead&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_l9'><A name='x_l9'></A>A definição typechecks, assim ele vai compilar, então o erro irá ocorrer durante a execução. A moral desta história é que ter cuidado em como usar padrões para definir uma função anônima: certifique-se de seus padrões não pode falhar!<SPAN id='comments_x_l9' class='comment'><A class='commenttoggle' id='toggle_x_l9' pid='x_l9' onclick='return loadComments(&quot;x_l9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_m9'><A name='x_m9'></A>Outra coisa a notar sobre as funções <CODE class='function'>isInAny</CODE> e <CODE class='function'>isInAny2</CODE> que mostrei acima é que a primeira versão, usando uma função auxiliar que tem um nome, é um pouco mais fácil de ler que a versão que se estatela uma função anônima para o meio. A função de auxiliar nomeado não perturbar o “<SPAN class='quote'>fluxo</SPAN>” de a função na qual ele é usado, eo nome escolhido criteriosamente nos dá um pouco de informação sobre o que a função é esperado.<SPAN id='comments_x_m9' class='comment'><A class='commenttoggle' id='toggle_x_m9' pid='x_m9' onclick='return loadComments(&quot;x_m9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_n9'><A name='x_n9'></A>Em contraste, quando corremos em um lambda no meio de um corpo da função, temos de trocar as marchas e ler a sua definição bastante cuidado para entender o que ele faz. Para ajudar com a legibilidade e facilidade de manutenção, então, tendemos a evitar lambdas em muitas situações onde poderíamos utilizá-los para cortar alguns personagens de uma definição de função. Muitas vezes, nós vamos usar uma função parcialmente aplicado em vez disso, resultando em um código mais claro e legível do que qualquer um lambda ou uma função explícita. Não sei o que uma função parcialmente aplicado é ainda? Leia mais!<SPAN id='comments_x_n9' class='comment'><A class='commenttoggle' id='toggle_x_n9' pid='x_n9' onclick='return loadComments(&quot;x_n9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_dL'><A name='x_dL'></A>Nós não pretendemos estas advertências para sugerir que lambdas são inúteis, mas apenas que devemos estar atentos às possíveis armadilhas quando estamos pensando em utilizá-los. Nos capítulos seguintes, veremos que são muitas vezes de valor inestimável como “<SPAN class='quote'>cola</SPAN>”.<SPAN id='comments_x_dL' class='comment'><A class='commenttoggle' id='toggle_x_dL' pid='x_dL' onclick='return loadComments(&quot;x_dL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.partialapp'>Aplicação da função parcial e currying</H2></DIV></DIV></DIV><P id='x_o9'><A name='x_o9'></A>Você pode se perguntar por que a seta <CODE class='code'>-&gt;</CODE> é usado para o que parece ser a dois propósitos na assinatura de um tipo de função.<SPAN id='comments_x_o9' class='comment'><A class='commenttoggle' id='toggle_x_o9' pid='x_o9' onclick='return loadComments(&quot;x_o9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:dropWhile'></A><PRE id='ch04.list.ghci:dropWhile' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t dropWhile
</CODE></STRONG><code class='machineMsg'>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></PRE> <SPAN id='comments_ch04.list.ghci:dropWhile' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:dropWhile' onclick='return loadComments(&quot;ch04.list.ghci:dropWhile&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_p9'><A name='x_p9'></A>Parece que o <CODE class='code'>-&gt;</CODE> é separar os argumentos para <CODE class='function'>dropWhile</CODE> umas das outras, mas que também separa os argumentos do tipo de retorno. Mas, na verdade <CODE class='function'>-&gt;</CODE> tem apenas um significado: ele denota uma função que recebe um argumento do tipo à esquerda, e retorna um valor do tipo do lado direito.<SPAN id='comments_x_p9' class='comment'><A class='commenttoggle' id='toggle_x_p9' pid='x_p9' onclick='return loadComments(&quot;x_p9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_q9'><A name='x_q9'></A>A implicação aqui é muito importante: em Haskell, <SPAN class='emphasis'><EM>todas as funções de tomar apenas um argumento</EM></SPAN>. Quando <CODE class='function'>dropWhile</CODE> <SPAN class='emphasis'><EM>parece</EM></SPAN> como uma função que recebe dois argumentos, é realmente uma função de um argumento, que retorna uma função que recebe um argumento. Aqui está uma expressão perfeitamente válida Haskell.<SPAN id='comments_x_q9' class='comment'><A class='commenttoggle' id='toggle_x_q9' pid='x_q9' onclick='return loadComments(&quot;x_q9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:dropWhile.isSpace'></A><PRE id='ch04.list.ghci:dropWhile.isSpace' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.Char
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t dropWhile isSpace
</CODE></STRONG><code class='machineMsg'>dropWhile isSpace :: [Char] -&gt; [Char]
</code></PRE> <SPAN id='comments_ch04.list.ghci:dropWhile.isSpace' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:dropWhile.isSpace' onclick='return loadComments(&quot;ch04.list.ghci:dropWhile.isSpace&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_s9'><A name='x_s9'></A>Bem, <SPAN class='emphasis'><EM>isso</EM></SPAN> parece útil. O valor <CODE class='code'>dropWhile isSpace</CODE> é uma função que retira líder espaço em branco de uma string. Como isso é útil? Como exemplo, podemos usá-lo como um argumento para uma função de ordem superior.<SPAN id='comments_x_s9' class='comment'><A class='commenttoggle' id='toggle_x_s9' pid='x_s9' onclick='return loadComments(&quot;x_s9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:dropWhile.isSpace.use'></A><PRE id='ch04.list.ghci:dropWhile.isSpace.use' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>map (dropWhile isSpace) [" a","f","   e"]
</CODE></STRONG><code class='machineMsg'>["a","f","e"]
</code></PRE> <SPAN id='comments_ch04.list.ghci:dropWhile.isSpace.use' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:dropWhile.isSpace.use' onclick='return loadComments(&quot;ch04.list.ghci:dropWhile.isSpace.use&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_t9'><A name='x_t9'></A>Toda vez que nós fornecemos um argumento para uma função, nós podemos “<SPAN class='quote'>cortar</SPAN>” um elemento fora da parte dianteira de sua assinatura tipo. Vamos tomar como exemplo <CODE class='function'>zip3</CODE> para ver o que queremos dizer, esta é uma função que fecha três listas em uma lista de três tuplas.<SPAN id='comments_x_t9' class='comment'><A class='commenttoggle' id='toggle_x_t9' pid='x_t9' onclick='return loadComments(&quot;x_t9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:zip3'></A><PRE id='ch04.list.ghci:zip3' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zip3
</CODE></STRONG><code class='machineMsg'>zip3 :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip3 "foo" "bar" "quux"
</CODE></STRONG><code class='machineMsg'>[('f','b','q'),('o','a','u'),('o','r','u')]
</code></PRE> <SPAN id='comments_ch04.list.ghci:zip3' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:zip3' onclick='return loadComments(&quot;ch04.list.ghci:zip3&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_u9'><A name='x_u9'></A>Se aplicarmos <CODE class='function'>zip3</CODE> com apenas um argumento, temos uma função que aceita dois argumentos. Não importa o que nós fornecemos argumentos para esta função compostos, seu primeiro argumento será sempre o valor fixo que especificamos.<SPAN id='comments_x_u9' class='comment'><A class='commenttoggle' id='toggle_x_u9' pid='x_u9' onclick='return loadComments(&quot;x_u9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:zip3foo'></A><PRE id='ch04.list.ghci:zip3foo' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zip3 "foo"
</CODE></STRONG><code class='machineMsg'>zip3 "foo" :: [b] -&gt; [c] -&gt; [(Char, b, c)]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>let zip3foo= zip3 "foo"
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zip3foo
</CODE></STRONG><code class='machineMsg'>zip3foo :: [b] -&gt; [c] -&gt; [(Char, b, c)]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>(zip3 "foo") "aaa" "bbb"
</CODE></STRONG><code class='machineMsg'>[('f','a','b'),('o','a','b'),('o','a','b')]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip3foo "aaa" "bbb"
</CODE></STRONG><code class='machineMsg'>[('f','a','b'),('o','a','b'),('o','a','b')]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip3foo [1,2,3] [True,False,True]
</CODE></STRONG><code class='machineMsg'>[('f',1,True),('o',2,False),('o',3,True)]
</code></PRE> <SPAN id='comments_ch04.list.ghci:zip3foo' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:zip3foo' onclick='return loadComments(&quot;ch04.list.ghci:zip3foo&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_v9'><A name='x_v9'></A>Quando passamos menos argumentos para uma função que a função pode aceitar, nós chamamos isso de <SPAN class='emphasis'><EM>aplicação parcial</EM></SPAN> da função: estamos aplicando a função a que apenas alguns de seus argumentos.<SPAN id='comments_x_v9' class='comment'><A class='commenttoggle' id='toggle_x_v9' pid='x_v9' onclick='return loadComments(&quot;x_v9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_w9'><A name='x_w9'></A>No exemplo acima, temos uma função aplicada parcialmente, <CODE class='code'>zip3 "foo"</CODE>, e uma nova função, <CODE class='function'>zip3foo</CODE>. Podemos ver que as assinaturas do tipo dois e seu comportamento são idênticos.<SPAN id='comments_x_w9' class='comment'><A class='commenttoggle' id='toggle_x_w9' pid='x_w9' onclick='return loadComments(&quot;x_w9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_x9'><A name='x_x9'></A>Isto aplica-se tão bem se fixar dois argumentos, dando-nos uma função de apenas um argumento.<SPAN id='comments_x_x9' class='comment'><A class='commenttoggle' id='toggle_x_x9' pid='x_x9' onclick='return loadComments(&quot;x_x9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='ch04.list.ghci:zip3foobar'></A><PRE id='ch04.list.ghci:zip3foobar' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>let zip3foobar= zip3 "foo" "bar"
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t zip3foobar
</CODE></STRONG><code class='machineMsg'>zip3foobar :: [c] -&gt; [(Char, Char, c)]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip3foobar "quux"
</CODE></STRONG><code class='machineMsg'>[('f','b','q'),('o','a','u'),('o','r','u')]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>zip3foobar [1,2]
</CODE></STRONG><code class='machineMsg'>[('f','b',1),('o','a',2)]
</code></PRE> <SPAN id='comments_ch04.list.ghci:zip3foobar' class='comment'><A class='commenttoggle' id='toggle_ch04.list.ghci:zip3foobar' onclick='return loadComments(&quot;ch04.list.ghci:zip3foobar&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_y9'><A name='x_y9'></A>Aplicação parcial de função nos permite evitar a criação de funções descartáveis cansativo. Muitas vezes é mais útil para este propósito que as funções anônimas que introduzimos na <A class='xref' href='#fp.anonymous' title='seção&nbsp;chamada&nbsp;“Funções&nbsp;(lambda)&nbsp;anónimos”'>seção chamada “Funções (lambda) anónimos”</A>. Olhando para trás, a função <CODE class='function'>isInAny</CODE> nós definimos lá, aqui está como nós usaríamos uma função parcialmente aplicado em vez de uma função auxiliar chamada ou uma lambda.<SPAN id='comments_x_y9' class='comment'><A class='commenttoggle' id='toggle_x_y9' pid='x_y9' onclick='return loadComments(&quot;x_y9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Partial.hs:isInAny3'></A><PRE id='Partial.hs:isInAny3' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Parcial.hs</code>
isInAny3 needle haystack = any (isInfixOf needle) haystack</PRE><SPAN id='comments_Partial.hs:isInAny3' class='comment'><A class='commenttoggle' id='toggle_Partial.hs:isInAny3' pid='Partial.hs:isInAny3' onclick='return loadComments(&quot;Partial.hs:isInAny3&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_z9'><A name='x_z9'></A>Aqui, a expressão <CODE class='code'>isInfixOf needle</CODE> é a função aplicada parcialmente. Nós estamos tomando a função <CODE class='function'>isInfixOf</CODE>, e “<SPAN class='quote'>consertar</SPAN>” seu primeiro argumento a ser a variável de <CODE class='varname'>needle</CODE> de nossa lista de parâmetros. Isso nos dá uma função parcialmente aplicada que tem exatamente o mesmo tipo de comportamento e como o ajudante e lambda em nossas definições anteriores.<SPAN id='comments_x_z9' class='comment'><A class='commenttoggle' id='toggle_x_z9' pid='x_z9' onclick='return loadComments(&quot;x_z9&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_HD1'><A name='x_HD1'></A>Aplicação de função parcial é chamado <SPAN class='emphasis'><EM>currying</EM></SPAN>, após o lógico Haskell Curry (para quem a linguagem Haskell é chamado).<SPAN id='comments_x_HD1' class='comment'><A class='commenttoggle' id='toggle_x_HD1' pid='x_HD1' onclick='return loadComments(&quot;x_HD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_eL'><A name='x_eL'></A>Como outro exemplo de currying em uso, vamos voltar para a função lista-resumo que escrevi na <A class='xref' href='#fp.foldl' title='seção&nbsp;chamada&nbsp;“A&nbsp;fold&nbsp;esquerda”'>seção chamada “A fold esquerda”</A>.<SPAN id='comments_x_eL' class='comment'><A class='commenttoggle' id='toggle_x_eL' pid='x_eL' onclick='return loadComments(&quot;x_eL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id596294'></A><PRE id='id596294' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Soma.hs</code>
somaFina:: [Int]-&gt; Int
somaFina xs = foldl (+) 0 xs</PRE><SPAN id='comments_id596294' class='comment'><A class='commenttoggle' id='toggle_id596294' pid='id596294' onclick='return loadComments(&quot;id596294&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_fL'><A name='x_fL'></A>Nós não precisamos de aplicar plenamente <CODE class='function'>foldl</CODE>, podemos omitir a lista de <CODE class='varname'>xs</CODE> tanto a lista de parâmetros e os parâmetros para <CODE class='function'>foldl</CODE>, e nós vamos acabar com uma função mais compacto que tem o mesmo tipo.<SPAN id='comments_x_fL' class='comment'><A class='commenttoggle' id='toggle_x_fL' pid='x_fL' onclick='return loadComments(&quot;x_fL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Sum.hs:nicerSum'></A><PRE id='Sum.hs:nicerSum' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Soma.hs</code>
somaMaisFina:: [Int]-&gt; Int
somaMaisFina = foldl (+) 0</PRE><SPAN id='comments_Sum.hs:nicerSum' class='comment'><A class='commenttoggle' id='toggle_Sum.hs:nicerSum' pid='Sum.hs:nicerSum' onclick='return loadComments(&quot;Sum.hs:nicerSum&quot;)' href='comments: show / hide'>?? comments</A></SPAN>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id596329'>Secções</H3></DIV></DIV></DIV><P id='x_AA'><A name='x_AA'></A>Haskell fornece um atalho útil para notação vamos escrever uma função parcialmente aplicadas em estilo infixo. Se colocar um operador em parênteses, nós podemos fornecer o seu argumento a esquerda ou direita dentro dos parênteses para obter uma função aplicada parcialmente. Este tipo de aplicação parcial é chamado de <SPAN class='emphasis'><EM>section</EM></SPAN>.<SPAN id='comments_x_AA' class='comment'><A class='commenttoggle' id='toggle_x_AA' pid='x_AA' onclick='return loadComments(&quot;x_AA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='partial.ghci:section'></A><PRE id='partial.ghci:section' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>(1+) 2
</CODE></STRONG><code class='machineMsg'>3
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>map (*3) [24,36]
</CODE></STRONG><code class='machineMsg'>[72,108]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>map (2^) [3,5,7,9]
</CODE></STRONG><code class='machineMsg'>[8,32,128,512]
</code></PRE> <SPAN id='comments_partial.ghci:section' class='comment'><A class='commenttoggle' id='toggle_partial.ghci:section' onclick='return loadComments(&quot;partial.ghci:section&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_BA'><A name='x_BA'></A>Se nos fornecer o argumento à esquerda dentro da seção, chamando a função resultante com um material argumento argumento do lado direito do operador. E vice-versa.<SPAN id='comments_x_BA' class='comment'><A class='commenttoggle' id='toggle_x_BA' pid='x_BA' onclick='return loadComments(&quot;x_BA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_CA'><A name='x_CA'></A>Lembre-se que nós podemos envolver um nome de função em backquotes usá-lo como um operador infixo. Isto nos permite usar seções com funções.<SPAN id='comments_x_CA' class='comment'><A class='commenttoggle' id='toggle_x_CA' pid='x_CA' onclick='return loadComments(&quot;x_CA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='partial.ghci:function'></A><PRE id='partial.ghci:function' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t (`elem` ['a'..'z'])
</CODE></STRONG><code class='machineMsg'>(`elem` ['a'..'z']) :: Char -&gt; Bool
</code></PRE> <SPAN id='comments_partial.ghci:function' class='comment'><A class='commenttoggle' id='toggle_partial.ghci:function' onclick='return loadComments(&quot;partial.ghci:function&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_DA'><A name='x_DA'></A>A definição acima fixa o segundo argumento de <CODE class='function'>elem</CODE> dando-nos uma função que verifica se seu argumento for uma letra minúscula.<SPAN id='comments_x_DA' class='comment'><A class='commenttoggle' id='toggle_x_DA' pid='x_DA' onclick='return loadComments(&quot;x_DA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='partial.ghci:lower.letter'></A><PRE id='partial.ghci:lower.letter' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>(`elem` ['a'..'z']) 'f'
</CODE></STRONG><code class='machineMsg'>True
</code></PRE> <SPAN id='comments_partial.ghci:lower.letter' class='comment'><A class='commenttoggle' id='toggle_partial.ghci:lower.letter' onclick='return loadComments(&quot;partial.ghci:lower.letter&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_EA'><A name='x_EA'></A>Usando isso como um argumento para <CODE class='function'>all</CODE>, temos uma função que verifica uma seqüência inteira para ver se está tudo em minúsculas.<SPAN id='comments_x_EA' class='comment'><A class='commenttoggle' id='toggle_x_EA' pid='x_EA' onclick='return loadComments(&quot;x_EA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='partial.ghci:lower.string'></A><PRE id='partial.ghci:lower.string' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>all (`elem` ['a'..'z']) "Frobozz"
</CODE></STRONG><code class='machineMsg'>False
</code></PRE> <SPAN id='comments_partial.ghci:lower.string' class='comment'><A class='commenttoggle' id='toggle_partial.ghci:lower.string' onclick='return loadComments(&quot;partial.ghci:lower.string&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_ID1'><A name='x_ID1'></A>Se usarmos esse estilo, podemos melhorar ainda mais a leitura de nossa função <CODE class='function'>isInAny3</CODE> anterior.<SPAN id='comments_x_ID1' class='comment'><A class='commenttoggle' id='toggle_x_ID1' pid='x_ID1' onclick='return loadComments(&quot;x_ID1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Partial.hs:isInAny4'></A><PRE id='Partial.hs:isInAny4' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Parcial.hs</code>
isInAny4 needle haystack = any (needle `isInfixOf`) haystack</PRE><SPAN id='comments_Partial.hs:isInAny4' class='comment'><A class='commenttoggle' id='toggle_Partial.hs:isInAny4' pid='Partial.hs:isInAny4' onclick='return loadComments(&quot;Partial.hs:isInAny4&quot;)' href='comments: show / hide'>?? comments</A></SPAN></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.aspattern'>Padrões As</H2></DIV></DIV></DIV><P id='x_FA'><A name='x_FA'></A>A função Haskell <CODE class='function'>tails</CODE>, no módulo <CODE class='code'>Data.List</CODE>, generaliza a função <CODE class='function'>tail</CODE> foi introduzida recentemente. Em vez de retornar uma “<SPAN class='quote'>cauda</SPAN>” da lista, ele retorna <SPAN class='emphasis'><EM>todos</EM></SPAN> eles.<SPAN id='comments_x_FA' class='comment'><A class='commenttoggle' id='toggle_x_FA' pid='x_FA' onclick='return loadComments(&quot;x_FA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:tails'></A><PRE id='suffix.ghci:tails' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.List
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tail "foobar"
</CODE></STRONG><code class='machineMsg'>"oobar"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tail (tail "foobar")
</CODE></STRONG><code class='machineMsg'>"obar"
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tails "foobar"
</CODE></STRONG><code class='machineMsg'>["foobar","oobar","obar","bar","ar","r",""]
</code></PRE> <SPAN id='comments_suffix.ghci:tails' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:tails' onclick='return loadComments(&quot;suffix.ghci:tails&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_GA'><A name='x_GA'></A>Cada uma dessas cadeias é um <SPAN class='emphasis'><EM>sufixo</EM></SPAN> de String inicial, para <CODE class='function'>tails</CODE> produz uma lista de todos os sufixos, além de uma lista vazia extra no final. Ela produz sempre que a lista extra vazio, mesmo quando sua lista de entrada está vazia.<SPAN id='comments_x_GA' class='comment'><A class='commenttoggle' id='toggle_x_GA' pid='x_GA' onclick='return loadComments(&quot;x_GA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:tails.empty'></A><PRE id='suffix.ghci:tails.empty' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tails []
</CODE></STRONG><code class='machineMsg'>[[]]
</code></PRE> <SPAN id='comments_suffix.ghci:tails.empty' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:tails.empty' onclick='return loadComments(&quot;suffix.ghci:tails.empty&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_HA'><A name='x_HA'></A>E se queremos uma função que se comporta como <CODE class='function'>tails</CODE>, mas que retorna <SPAN class='emphasis'><EM>apenas</EM></SPAN> os sufixos não vazios? Uma possibilidade seria para nós a escrever a nossa própria versão a mão. Vamos usar uma nova peça de notação, o símbolo <CODE class='code'>@</CODE>.<SPAN id='comments_x_HA' class='comment'><A class='commenttoggle' id='toggle_x_HA' pid='x_HA' onclick='return loadComments(&quot;x_HA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:suffixes'></A><PRE id='SuffixTree.hs:suffixes' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs</code>
sufixos:: [a]-&gt; [[a]]
sufixos xs@(_:xs') = xs : suffixes xs'
sufixos _ = []</PRE><SPAN id='comments_SuffixTree.hs:suffixes' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:suffixes' pid='SuffixTree.hs:suffixes' onclick='return loadComments(&quot;SuffixTree.hs:suffixes&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_JA'><A name='x_JA'></A>O padrão <CODE class='code'>xs@(_:xs')</CODE> é chamado um <SPAN class='emphasis'><EM>padrão as</EM></SPAN>, e significa “<SPAN class='quote'>ligar o variável <CODE class='varname'>xs</CODE> para o valor que corresponda ao lado direito do símbolo <CODE class='code'>@</CODE></SPAN>”.<SPAN id='comments_x_JA' class='comment'><A class='commenttoggle' id='toggle_x_JA' pid='x_JA' onclick='return loadComments(&quot;x_JA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_KA'><A name='x_KA'></A>No nosso exemplo, se o padrão depois do “<SPAN class='quote'>@</SPAN>” corresponde, <CODE class='varname'>xs</CODE> será obrigado a toda a lista que combinava e <CODE class='varname'>xs'</CODE> para todos, mas o cabeça da lista (usamos o padrão wild card <CODE class='code'>_</CODE> para indicar que estamos não está interessado no valor do cabeça de lista).<SPAN id='comments_x_KA' class='comment'><A class='commenttoggle' id='toggle_x_KA' pid='x_KA' onclick='return loadComments(&quot;x_KA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:suffixes'></A><PRE id='suffix.ghci:suffixes' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tails "foo"
</CODE></STRONG><code class='machineMsg'>["foo","oo","o",""]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>suffixes "foo"
</CODE></STRONG><code class='machineMsg'>["foo","oo","o"]
</code></PRE> <SPAN id='comments_suffix.ghci:suffixes' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:suffixes' onclick='return loadComments(&quot;suffix.ghci:suffixes&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_LA'><A name='x_LA'></A>O padrão as torna o código nosso mais legível. Para ver como isso ajuda, vamos comparar uma definição que não tenha um padrão as.<SPAN id='comments_x_LA' class='comment'><A class='commenttoggle' id='toggle_x_LA' pid='x_LA' onclick='return loadComments(&quot;x_LA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:noAsPattern'></A><PRE id='SuffixTree.hs:noAsPattern' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs</code>
semPadrãoAs:: [a]-&gt; [[a]]
semPadrãoAs (x:xs) = (x:xs) : semPadrãoAs xs
semPadrãoAs _ = []</PRE><SPAN id='comments_SuffixTree.hs:noAsPattern' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:noAsPattern' pid='SuffixTree.hs:noAsPattern' onclick='return loadComments(&quot;SuffixTree.hs:noAsPattern&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_MA'><A name='x_MA'></A>Aqui, a lista que nós desconstruído no padrão de jogo só fica colocada de volta em conjunto no corpo da função.<SPAN id='comments_x_MA' class='comment'><A class='commenttoggle' id='toggle_x_MA' pid='x_MA' onclick='return loadComments(&quot;x_MA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_NA'><A name='x_NA'></A>Padrões as ter um uso mais prático do que a leitura simples: eles podem nos ajudar a compartilhar dados, em vez de copiá-lo. Em nossa definição de <CODE class='function'>semPadrãoAs</CODE>, quando jogo <CODE class='code'>(x:xs)</CODE>, vamos construir uma nova cópia dele no corpo da nossa função. Isso nos leva a atribuir um nó nova lista em tempo de execução. Isso pode ser barato, mas não é livre. Em contraste, quando nós definimos <CODE class='function'>sufixos</CODE>, reutilizadas o valor <CODE class='varname'>xs</CODE> que nós combinamos com o nosso como padrão. Desde que reutilizar um valor existente, evitamos uma atribuição pouco.<SPAN id='comments_x_NA' class='comment'><A class='commenttoggle' id='toggle_x_NA' pid='x_NA' onclick='return loadComments(&quot;x_NA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.compose'>Reutilização de código através da composição</H2></DIV></DIV></DIV><P id='x_OA'><A name='x_OA'></A>Parece uma vergonha para introduzir uma nova função, <CODE class='function'>sufixos</CODE>, que faz quase a mesma coisa que a função existente <CODE class='function'>tails</CODE>. Certamente nós podemos fazer melhor?<SPAN id='comments_x_OA' class='comment'><A class='commenttoggle' id='toggle_x_OA' pid='x_OA' onclick='return loadComments(&quot;x_OA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_PA'><A name='x_PA'></A>Lembre-se da função <CODE class='function'>init</CODE> introduzimos na <A class='xref' href='#fp.lists' title='seção&nbsp;chamada&nbsp;“Trabalhar&nbsp;com&nbsp;as&nbsp;listas”'>seção chamada “Trabalhar com as listas”</A>: retorna todos, mas o último elemento de uma lista.<SPAN id='comments_x_PA' class='comment'><A class='commenttoggle' id='toggle_x_PA' pid='x_PA' onclick='return loadComments(&quot;x_PA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:suffixes2'></A><PRE id='SuffixTree.hs:suffixes2' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs</code>
sufixos2 xs = init (tails xs)</PRE><SPAN id='comments_SuffixTree.hs:suffixes2' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:suffixes2' pid='SuffixTree.hs:suffixes2' onclick='return loadComments(&quot;SuffixTree.hs:suffixes2&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_QA'><A name='x_QA'></A>Esta função <CODE class='function'>sufixos2</CODE> funciona igualmente a <CODE class='function'>sufixos</CODE>, mas é um única linha de código.<SPAN id='comments_x_QA' class='comment'><A class='commenttoggle' id='toggle_x_QA' pid='x_QA' onclick='return loadComments(&quot;x_QA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:suffixes2'></A><PRE id='suffix.ghci:suffixes2' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>sufixos2 "foo"
</CODE></STRONG><code class='machineMsg'>["foo","oo","o"]
</code></PRE> <SPAN id='comments_suffix.ghci:suffixes2' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:suffixes2' onclick='return loadComments(&quot;suffix.ghci:suffixes2&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_RA'><A name='x_RA'></A>Se tomarmos um passo para trás, vemos o reflexo de um padrão aqui: nós estamos aplicando uma função, em seguida, aplicar uma outra função para o seu resultado. Vamos transformar esse padrão em uma definição de função.<SPAN id='comments_x_RA' class='comment'><A class='commenttoggle' id='toggle_x_RA' pid='x_RA' onclick='return loadComments(&quot;x_RA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:compose'></A><PRE id='SuffixTree.hs:compose' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs</code>
compor:: (b-&gt;c)-&gt; (a-&gt;b)-&gt; a-&gt; c
compor f g x = f (g x)</PRE><SPAN id='comments_SuffixTree.hs:compose' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:compose' pid='SuffixTree.hs:compose' onclick='return loadComments(&quot;SuffixTree.hs:compose&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_SA'><A name='x_SA'></A>Agora temos uma função, <CODE class='function'>compor</CODE>, que podemos usar para “<SPAN class='quote'>cola</SPAN>” outras duas funções em conjunto.<SPAN id='comments_x_SA' class='comment'><A class='commenttoggle' id='toggle_x_SA' pid='x_SA' onclick='return loadComments(&quot;x_SA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:suffixes3'></A><PRE id='SuffixTree.hs:suffixes3' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs
sufixos3 xs = compor init tails xs</code></PRE><SPAN id='comments_SuffixTree.hs:suffixes3' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:suffixes3' pid='SuffixTree.hs:suffixes3' onclick='return loadComments(&quot;SuffixTree.hs:suffixes3&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_TA'><A name='x_TA'></A>O currying automático do Haskell nos deixa cair a variável <CODE class='varname'>xs</CODE>para que possamos fazer a nossa definição ainda mais curtos.<SPAN id='comments_x_TA' class='comment'><A class='commenttoggle' id='toggle_x_TA' pid='x_TA' onclick='return loadComments(&quot;x_TA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:suffixes4'></A><PRE id='SuffixTree.hs:suffixes4' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs
sufixos4 = compor init tails</code></PRE><SPAN id='comments_SuffixTree.hs:suffixes4' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:suffixes4' pid='SuffixTree.hs:suffixes4' onclick='return loadComments(&quot;SuffixTree.hs:suffixes4&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_UA'><A name='x_UA'></A>Felizmente, não precisamos de escrever a nossa própria função <CODE class='function'>compor</CODE>. Ligar funções em cada um, como isto é tão comum que a Prelude fornece composição das funções através do operador <CODE class='function'>(.)</CODE>.<SPAN id='comments_x_UA' class='comment'><A class='commenttoggle' id='toggle_x_UA' pid='x_UA' onclick='return loadComments(&quot;x_UA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='SuffixTree.hs:suffixes5'></A><PRE id='SuffixTree.hs:suffixes5' class='programlisting'><code class='codecomment'>-- arquivo: ca04/ArvorDeSufixos.hs
sufixos5 = init . tails</code></PRE><SPAN id='comments_SuffixTree.hs:suffixes5' class='comment'><A class='commenttoggle' id='toggle_SuffixTree.hs:suffixes5' pid='SuffixTree.hs:suffixes5' onclick='return loadComments(&quot;SuffixTree.hs:suffixes5&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_VA'><A name='x_VA'></A>O operador <CODE class='function'>(.)</CODE> não é uma parte especial da sintaxe da linguagem, é apenas um operador normal.<SPAN id='comments_x_VA' class='comment'><A class='commenttoggle' id='toggle_x_VA' pid='x_VA' onclick='return loadComments(&quot;x_VA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:types'></A><PRE id='suffix.ghci:types' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t (.)
</CODE></STRONG><code class='machineMsg'>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t sufixos
</CODE></STRONG><code class='machineMsg'>suffixes :: [a] -&gt; [[a]]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t sufixos5
</CODE></STRONG><code class='machineMsg'>suffixes5 :: [a] -&gt; [[a]]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>sufixs5 "foo"
</CODE></STRONG><code class='machineMsg'>["foo","oo","o"]
</code></PRE> <SPAN id='comments_suffix.ghci:types' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:types' onclick='return loadComments(&quot;suffix.ghci:types&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_WA'><A name='x_WA'></A>Podemos criar novas funções a qualquer momento por escrito cadeias de funções compostas, costurado com <CODE class='function'>(.)</CODE>, tanto tempo (é claro) como o tipo de resultado da função no lado direito de cada um <CODE class='function'>(.)</CODE> corresponde ao tipo de parâmetro que o função na esquerda pode aceitar.<SPAN id='comments_x_WA' class='comment'><A class='commenttoggle' id='toggle_x_WA' pid='x_WA' onclick='return loadComments(&quot;x_WA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_JD1'><A name='x_JD1'></A>Como exemplo, vamos resolver um enigma muito simples: a contagem do número de palavras em uma seqüência que começa com uma letra maiúscula.<SPAN id='comments_x_JD1' class='comment'><A class='commenttoggle' id='toggle_x_JD1' pid='x_JD1' onclick='return loadComments(&quot;x_JD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:dotty'></A><PRE id='suffix.ghci:dotty' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:m +Data.Char
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>let numeroMaiusc= length . filter (isUpper . head) . words
</CODE></STRONG><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>numeroMaiusc "Olá! Olá, mãe!"
</CODE></STRONG><code class='machineMsg'>2
</code></PRE> <SPAN id='comments_suffix.ghci:dotty' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:dotty' onclick='return loadComments(&quot;suffix.ghci:dotty&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_KD1'><A name='x_KD1'></A>Podemos entender que esta função é composta pela análise das suas peças. A função <CODE class='function'>(.)</CODE> é associativa direito, por isso vamos prosseguir da direita para a esquerda.<SPAN id='comments_x_KD1' class='comment'><A class='commenttoggle' id='toggle_x_KD1' pid='x_KD1' onclick='return loadComments(&quot;x_KD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:words.type'></A><PRE id='suffix.ghci:words.type' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t words
</CODE></STRONG><code class='machineMsg'>words :: String -&gt; [String]
</code></PRE> <SPAN id='comments_suffix.ghci:words.type' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:words.type' onclick='return loadComments(&quot;suffix.ghci:words.type&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_LD1'><A name='x_LD1'></A>A função <CODE class='function'>words</CODE> tem um tipo de resultado de <SPAN class='type'>[String]</SPAN>, para o que está no lado esquerdo de <CODE class='function'>(.)</CODE> deve aceitar um argumento compatível.<SPAN id='comments_x_LD1' class='comment'><A class='commenttoggle' id='toggle_x_LD1' pid='x_LD1' onclick='return loadComments(&quot;x_LD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:capped.type'></A><PRE id='suffix.ghci:capped.type' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t isUpper . head
</CODE></STRONG><code class='machineMsg'>isUpper . head :: [Char] -&gt; Bool
</code></PRE> <SPAN id='comments_suffix.ghci:capped.type' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:capped.type' onclick='return loadComments(&quot;suffix.ghci:capped.type&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_MD1'><A name='x_MD1'></A>Essa função retorna <CODE class='code'>True</CODE> se uma palavra começa com uma letra maiúscula (testá-lo em <SPAN class='command'><STRONG>ghci</STRONG></SPAN>), os <CODE class='code'>filter (isUpper . head)</CODE> retorna uma lista de <SPAN class='type'>String</SPAN>s contendo apenas palavras que começam com letras maiúsculas.<SPAN id='comments_x_MD1' class='comment'><A class='commenttoggle' id='toggle_x_MD1' pid='x_MD1' onclick='return loadComments(&quot;x_MD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='suffix.ghci:capfilt.type'></A><PRE id='suffix.ghci:capfilt.type' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t filter (isUpper . head)
</CODE></STRONG><code class='machineMsg'>filter (isUpper . head) :: [[Char]] -&gt; [[Char]]
</code></PRE> <SPAN id='comments_suffix.ghci:capfilt.type' class='comment'><A class='commenttoggle' id='toggle_suffix.ghci:capfilt.type' onclick='return loadComments(&quot;suffix.ghci:capfilt.type&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_ND1'><A name='x_ND1'></A>Uma vez que esta expressão retorna uma lista, tudo o que resta é calcular o comprimento da lista, o que fazemos com outra composição.<SPAN id='comments_x_ND1' class='comment'><A class='commenttoggle' id='toggle_x_ND1' pid='x_ND1' onclick='return loadComments(&quot;x_ND1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_XA'><A name='x_XA'></A>Aqui está outro exemplo, retirado de uma aplicação real. Queremos extrair uma lista de nomes de macro de um arquivo de cabeçalho C acompanha <CODE class='code'>libpcap</CODE>, uma biblioteca popular pacote de filtragem de rede. O arquivo de cabeçalho contém um grande número de definições da seguinte forma.<SPAN id='comments_x_XA' class='comment'><A class='commenttoggle' id='toggle_x_XA' pid='x_XA' onclick='return loadComments(&quot;x_XA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='id597123'></A><PRE id='id597123' class='programlisting'>#define DLT_EN10MB      1       /* Ethernet (10Mb) */
#define DLT_EN3MB       2       /* Experimental Ethernet (3Mb) */
#define DLT_AX25        3       /* Amateur Radio AX.25 */</PRE><SPAN id='comments_id597123' class='comment'><A class='commenttoggle' id='toggle_id597123' pid='id597123' onclick='return loadComments(&quot;id597123&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_OD1'><A name='x_OD1'></A>Nosso objetivo é extrair nomes como <CODE class='code'>DLT_EN10MB</CODE> e <CODE class='code'>DLT_AX25</CODE>.<SPAN id='comments_x_OD1' class='comment'><A class='commenttoggle' id='toggle_x_OD1' pid='x_OD1' onclick='return loadComments(&quot;x_OD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='dlts.hs:dlts'></A><PRE id='dlts.hs:dlts' class='programlisting'><code class='codecomment'>-- arquivo: ca04/dlts.hs</code>
import Data.List(isPrefixOf)

dlts:: String-&gt; [String]
dlts= foldr passo [] . lines</PRE><SPAN id='comments_dlts.hs:dlts' class='comment'><A class='commenttoggle' id='toggle_dlts.hs:dlts' pid='dlts.hs:dlts' onclick='return loadComments(&quot;dlts.hs:dlts&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_YA'><A name='x_YA'></A>Nós tratamos todo um arquivo como uma String, dividi-lo com <CODE class='function'>lines</CODE>, em seguida, aplicar <CODE class='code'>foldr passo []</CODE> para a lista resultante de linhas. A função de auxiliar <CODE class='function'>passo</CODE> opera em uma única linha.<SPAN id='comments_x_YA' class='comment'><A class='commenttoggle' id='toggle_x_YA' pid='x_YA' onclick='return loadComments(&quot;x_YA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='dlts.hs:step'></A><PRE id='dlts.hs:step' class='programlisting'><code class='codecomment'>-- arquivo: ca04/dlts.hs</code>
  where passo l ds
          | "#define DLT_" `isPrefixOf` l = palavra2 l : ds
          | otherwise = ds
        palavra2 = head . tail . words</PRE><SPAN id='comments_dlts.hs:step' class='comment'><A class='commenttoggle' id='toggle_dlts.hs:step' pid='dlts.hs:step' onclick='return loadComments(&quot;dlts.hs:step&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_ZA'><A name='x_ZA'></A>Se coincidir com uma definição de macro com a nossa expressão guarda, podemos contras o nome da macro para a cabeça da lista que está retornando, caso contrário, deixamos a lista intocada.<SPAN id='comments_x_ZA' class='comment'><A class='commenttoggle' id='toggle_x_ZA' pid='x_ZA' onclick='return loadComments(&quot;x_ZA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_aA'><A name='x_aA'></A>Enquanto as funções individuais do corpo de <CODE class='function'>palavra2</CODE> estão agora familiar para nós, pode levar um pouco de prática para montar uma cadeia de composições como esta. Vamos examinar o processo.<SPAN id='comments_x_aA' class='comment'><A class='commenttoggle' id='toggle_x_aA' pid='x_aA' onclick='return loadComments(&quot;x_aA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_bA'><A name='x_bA'></A>Mais uma vez, procede da direita para a esquerda. A primeira função é <CODE class='function'>words</CODE>. <SPAN id='comments_x_bA' class='comment'><A class='commenttoggle' id='toggle_x_bA' pid='x_bA' onclick='return loadComments(&quot;x_bA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='dlts.ghci:words'></A><PRE id='dlts.ghci:words' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t words
</CODE></STRONG><code class='machineMsg'>words :: String -&gt; [String]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>words "#define DLT_CHAOS    5"
</CODE></STRONG><code class='machineMsg'>["#define","DLT_CHAOS","5"]
</code></PRE> <SPAN id='comments_dlts.ghci:words' class='comment'><A class='commenttoggle' id='toggle_dlts.ghci:words' onclick='return loadComments(&quot;dlts.ghci:words&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_cA'><A name='x_cA'></A>Em seguida, aplicamos <CODE class='code'>tail</CODE> para o resultado de <CODE class='function'>words</CODE>.<SPAN id='comments_x_cA' class='comment'><A class='commenttoggle' id='toggle_x_cA' pid='x_cA' onclick='return loadComments(&quot;x_cA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='dlts.ghci:drop1'></A><PRE id='dlts.ghci:drop1' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t tail
</CODE></STRONG><code class='machineMsg'>tail :: [a] -&gt; [a]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>tail ["#define","DLT_CHAOS","5"]
</CODE></STRONG><code class='machineMsg'>["DLT_CHAOS","5"]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t tail . words
</CODE></STRONG><code class='machineMsg'>tail . words :: String -&gt; [String]
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>(tail . words) "#define DLT_CHAOS    5"
</CODE></STRONG><code class='machineMsg'>["DLT_CHAOS","5"]
</code></PRE> <SPAN id='comments_dlts.ghci:drop1' class='comment'><A class='commenttoggle' id='toggle_dlts.ghci:drop1' onclick='return loadComments(&quot;dlts.ghci:drop1&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_eA'><A name='x_eA'></A>Finalmente, aplicando <CODE class='function'>head</CODE> para o resultado de <CODE class='code'>drop 1 . words</CODE>  nos dará o nome de nossa macro.<SPAN id='comments_x_eA' class='comment'><A class='commenttoggle' id='toggle_x_eA' pid='x_eA' onclick='return loadComments(&quot;x_eA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='dlts.ghci:head.drop1.words'></A><PRE id='dlts.ghci:head.drop1.words' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t head . tail . words
</CODE></STRONG><code class='machineMsg'>head . tail . words :: String -&gt; String
</code><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>(head . tail . words) "#define DLT_CHAOS    5"
</CODE></STRONG><code class='machineMsg'>"DLT_CHAOS"
</code></PRE> <SPAN id='comments_dlts.ghci:head.drop1.words' class='comment'><A class='commenttoggle' id='toggle_dlts.ghci:head.drop1.words' onclick='return loadComments(&quot;dlts.ghci:head.drop1.words&quot;)' href='comment: add'>?? comments</A></SPAN>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id597329'>Use a cabeça sabiamente</H3></DIV></DIV></DIV><P id='x_fA'><A name='x_fA'></A>Depois da advertência contra lista de funções inseguras na <A class='xref' href='#fp.lists.safe' title='seção&nbsp;chamada&nbsp;“Trabalhar&nbsp;segura&nbsp;e&nbsp;saudavelmente&nbsp;a&nbsp;com&nbsp;funções&nbsp;crashy”'>seção chamada “Trabalhar segura e saudavelmente a com funções crashy”</A>, aqui estamos chamando tanto a <CODE class='function'>head</CODE> e a <CODE class='function'>tail</CODE>, duas dessas funções de lista inseguro. O Que Dá?<SPAN id='comments_x_fA' class='comment'><A class='commenttoggle' id='toggle_x_fA' pid='x_fA' onclick='return loadComments(&quot;x_fA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_gA'><A name='x_gA'></A>Neste caso, podemos nos assegurar de inspeção que estamos seguros de uma falha de execução. O guarda padrão na definição de <CODE class='function'>passo</CODE> contém duas palavras, por isso quando nós aplicamos <CODE class='function'>words</CODE> a qualquer String de palavras que faz passar pelo guarda, que vamos ter uma lista de pelo menos dois elementos, <CODE class='code'>"#define"</CODE> e alguns macro iniciando com <CODE class='code'>"DLT_"</CODE>.<SPAN id='comments_x_gA' class='comment'><A class='commenttoggle' id='toggle_x_gA' pid='x_gA' onclick='return loadComments(&quot;x_gA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_hA'><A name='x_hA'></A>Este tipo de raciocínio que devemos fazer para nos convencermos de que nosso código não vai explodir quando chamamos funções parciais. Não se esqueça nossa admoestação anterior: chamar funções inseguro como este requer cuidados, e muitas vezes pode tornar o código mais frágil de maneira sutil. Se por algum motivo, modificou o padrão de proteção para conter apenas uma palavra, poderíamos nos expor à possibilidade de um acidente, como o corpo da função assume que receberá duas palavras.<SPAN id='comments_x_hA' class='comment'><A class='commenttoggle' id='toggle_x_hA' pid='x_hA' onclick='return loadComments(&quot;x_hA&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.readability'>Dicas para escrever código legível</H2></DIV></DIV></DIV><P id='x_gL'><A name='x_gL'></A>Até agora, neste capítulo, me deparei com duas características tentador olhar de Haskell: recursão de cauda e funções anônimas. Tão agradável como estes são, muitas vezes não se deseja usá-los.<SPAN id='comments_x_gL' class='comment'><A class='commenttoggle' id='toggle_x_gL' pid='x_gL' onclick='return loadComments(&quot;x_gL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_hL'><A name='x_hL'></A>Muitas operações de manipulação de lista pode ser mais facilmente expressos usando combinações de funções de biblioteca, tais como <CODE class='function'>map</CODE>, <CODE class='function'>take</CODE>, e <CODE class='function'>filter</CODE>. Sem dúvida, isto requer alguma prática para se acostumar com estes. No retorno para nosso investimento inicial, podemos ler e escrever código mais rapidamente e com menos bugs.<SPAN id='comments_x_hL' class='comment'><A class='commenttoggle' id='toggle_x_hL' pid='x_hL' onclick='return loadComments(&quot;x_hL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_iL'><A name='x_iL'></A>A razão para isso é simples. Uma definição de função recursiva de cauda tem o mesmo problema como um loop em uma linguagem imperativa: é completamente geral. Ele pode realizar alguns filtragem, mapeamento de alguns, ou quem sabe mais o quê. Somos obrigados a olhar em detalhe toda a definição da função para ver o que ele está realmente fazendo. Em contraste, <CODE class='function'>map</CODE> e funções de manipulação mais outra lista fazer apenas <SPAN class='emphasis'><EM>uma</EM></SPAN> coisa. Podemos tomar como garantido que estes blocos de construção simples fazer, e focar na idéia de que o código é tentar expressar, não os mínimos detalhes de como é a manipulação de seus insumos.<SPAN id='comments_x_iL' class='comment'><A class='commenttoggle' id='toggle_x_iL' pid='x_iL' onclick='return loadComments(&quot;x_iL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_jL'><A name='x_jL'></A>No meio do caminho entre a cauda funções recursivas (com a generalidade completo) e nossa caixa de ferramentas de funções de manipulação de lista (cada um deles faz uma coisa) encontram-se as dobras. Uma dobra exige mais esforço para entender que, digamos, uma composição de <CODE class='function'>map</CODE> e <CODE class='function'>filter</CODE>que faz a mesma coisa, mas ele se comporta de forma mais regular e previsível do que uma função recursiva de cauda. Como regra geral, não use uma dobra se você pode compor algumas funções da biblioteca, mas caso contrário tenta usar uma dobra de preferência à mão-rolados uma loop uma recursiva cauda.<SPAN id='comments_x_jL' class='comment'><A class='commenttoggle' id='toggle_x_jL' pid='x_jL' onclick='return loadComments(&quot;x_jL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_kL'><A name='x_kL'></A>Para as funções anônimas, eles tendem a interromper o “<SPAN class='quote'>fluxo</SPAN>” de ler um pedaço de código. É muitas vezes tão fácil de escrever uma definição de função local em um cláusula <CODE class='code'>let</CODE> ou <CODE class='code'>where</CODE>, e usar isso, como é para colocar uma função anônima em seu lugar. As vantagens relativas de uma função chamada são dois: não precisamos entender a definição da função quando estamos lendo o código que usa-lo, e um nome de função bem escolhido age como um pequeno pedaço de documentação local.<SPAN id='comments_x_kL' class='comment'><A class='commenttoggle' id='toggle_x_kL' pid='x_kL' onclick='return loadComments(&quot;x_kL&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect1' lang='pt'><DIV class='titlepage'><DIV><DIV><H2 class='title' id='fp.seq'>Space leaks e avaliação rigorosa</H2></DIV></DIV></DIV><P id='x_PD1'><A name='x_PD1'></A>A função <CODE class='function'>foldl</CODE> que discutimos anteriormente não é o único lugar onde podem ocorrer vazamentos espaço no código Haskell. Vamos usá-lo para ilustrar como a avaliação não-estrita às vezes pode ser problemático, e como resolver as dificuldades que podem surgir.<SPAN id='comments_x_PD1' class='comment'><A class='commenttoggle' id='toggle_x_PD1' pid='x_PD1' onclick='return loadComments(&quot;x_PD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><DIV class='tip'><TABLE border='0' summary='Tip: Você precisa saber de tudo isso agora?'><TBODY><TR><TD rowspan='2' align='center' valign='top' width='25'><IMG alt='[Tip]' src='support/figs/tip.png'></TD><TH align='left'>Você precisa saber de tudo isso agora?</TH></TR><TR><TD align='left' valign='top'><P id='x_QD1'><A name='x_QD1'></A>É perfeitamente razoável para pular esta seção até que você encontrar um space leak “<SPAN class='quote'>in the wild</SPAN>”. Desde que você usa <CODE class='function'>foldr</CODE> se você estiver gerando uma lista, e <CODE class='function'>foldl'</CODE> em vez de <CODE class='function'>foldl</CODE> contrário, vazamentos de espaço não são susceptíveis de incomodá-lo na prática por um tempo.<SPAN id='comments_x_QD1' class='comment'><A class='commenttoggle' id='toggle_x_QD1' pid='x_QD1' onclick='return loadComments(&quot;x_QD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></TD></TR></TBODY></TABLE></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id597540'>Evitar space leaks com seq</H3></DIV></DIV></DIV><P id='x_RD1'><A name='x_RD1'></A>Nós nos referimos a uma expressão que não é avaliada preguiçosamente tão <SPAN class='emphasis'><EM>rigorosa</EM></SPAN>, tão <CODE class='function'>foldl'</CODE> é uma rigorosa deixou desistir. Ele ignora avaliação usual Haskell não-estrita através da utilização de uma função chamada <CODE class='function'>seq</CODE>.<SPAN id='comments_x_RD1' class='comment'><A class='commenttoggle' id='toggle_x_RD1' pid='x_RD1' onclick='return loadComments(&quot;x_RD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:strict'></A><PRE id='Fold.hs:strict' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl' _    zero []     = zero
foldl' passo zero (x:xs) =
    let novo= passo zero x
    in  novo `seq` foldl' passo novo xs</PRE><SPAN id='comments_Fold.hs:strict' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:strict' pid='Fold.hs:strict' onclick='return loadComments(&quot;Fold.hs:strict&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_SD1'><A name='x_SD1'></A>Esta função <CODE class='function'>seq</CODE> tem um tipo peculiar, insinuando que ele não está jogando com as regras habituais.<SPAN id='comments_x_SD1' class='comment'><A class='commenttoggle' id='toggle_x_SD1' pid='x_SD1' onclick='return loadComments(&quot;x_SD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='thunky.ghci:seq'></A><PRE id='thunky.ghci:seq' class='screen'><CODE class='prompt'>ghci&gt; </CODE><STRONG class='userinput'><CODE>:t seq
</CODE></STRONG><code class='machineMsg'>seq :: a -&gt; t -&gt; t
</code></PRE> <SPAN id='comments_thunky.ghci:seq' class='comment'><A class='commenttoggle' id='toggle_thunky.ghci:seq' onclick='return loadComments(&quot;thunky.ghci:seq&quot;)' href='comment: add'>?? comments</A></SPAN><P id='x_TD1'><A name='x_TD1'></A>Ele funciona da seguinte forma: quando uma expressão <CODE class='function'>seq</CODE> é avaliada seguintes, ele força o seu primeiro argumento a ser avaliada, em seguida, retorna seu segundo argumento. Na verdade, não fazer nada com o primeiro argumento: <CODE class='function'>seq</CODE> existe apenas como uma maneira de forçar que o valor a ser avaliada. Vamos caminhar através de uma aplicação breve para ver o que acontece.<SPAN id='comments_x_TD1' class='comment'><A class='commenttoggle' id='toggle_x_TD1' pid='x_TD1' onclick='return loadComments(&quot;x_TD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:step1'></A><PRE id='Fold.hs:step1' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl' (+) 1 (2:[])</PRE><SPAN id='comments_Fold.hs:step1' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:step1' pid='Fold.hs:step1' onclick='return loadComments(&quot;Fold.hs:step1&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_UD1'><A name='x_UD1'></A>Isso expande o seguinte.<SPAN id='comments_x_UD1' class='comment'><A class='commenttoggle' id='toggle_x_UD1' pid='x_UD1' onclick='return loadComments(&quot;x_UD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:step2'></A><PRE id='Fold.hs:step2' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
let novo= 1 + 2
in novo `seq` foldl' (+) novo []</PRE><SPAN id='comments_Fold.hs:step2' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:step2' pid='Fold.hs:step2' onclick='return loadComments(&quot;Fold.hs:step2&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_VD1'><A name='x_VD1'></A>O uso de <CODE class='function'>seq</CODE> avalia forçada <CODE class='varname'>novo</CODE> a <CODE class='code'>3</CODE>, e retorna seu segundo argumento.<SPAN id='comments_x_VD1' class='comment'><A class='commenttoggle' id='toggle_x_VD1' pid='x_VD1' onclick='return loadComments(&quot;x_VD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:step3'></A><PRE id='Fold.hs:step3' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
foldl' (+) 3 []</PRE><SPAN id='comments_Fold.hs:step3' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:step3' pid='Fold.hs:step3' onclick='return loadComments(&quot;Fold.hs:step3&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_WD1'><A name='x_WD1'></A>Acabamos com o resultado seguinte.<SPAN id='comments_x_WD1' class='comment'><A class='commenttoggle' id='toggle_x_WD1' pid='x_WD1' onclick='return loadComments(&quot;x_WD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:step4'></A><PRE id='Fold.hs:step4' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
3</PRE><SPAN id='comments_Fold.hs:step4' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:step4' pid='Fold.hs:step4' onclick='return loadComments(&quot;Fold.hs:step4&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_XD1'><A name='x_XD1'></A>Graças a <CODE class='function'>seq</CODE>, não há thunks à vista.<SPAN id='comments_x_XD1' class='comment'><A class='commenttoggle' id='toggle_x_XD1' pid='x_XD1' onclick='return loadComments(&quot;x_XD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV>
<DIV class='sect2' lang='pt'><DIV class='titlepage'><DIV><DIV><H3 class='title' id='id597688'>Aprender a usar o seq</H3></DIV></DIV></DIV><P id='x_YD1'><A name='x_YD1'></A>Sem algum sentido, existe um elemento de mistério para usar efetivamente seguintes. Aqui estão algumas regras úteis para usá-lo bem.<SPAN id='comments_x_YD1' class='comment'><A class='commenttoggle' id='toggle_x_YD1' pid='x_YD1' onclick='return loadComments(&quot;x_YD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_ZD1'><A name='x_ZD1'></A>Para ter algum efeito, uma expressão <CODE class='function'>seq</CODE> devem ser a primeira coisa avaliada em uma expressão.<SPAN id='comments_x_ZD1' class='comment'><A class='commenttoggle' id='toggle_x_ZD1' pid='x_ZD1' onclick='return loadComments(&quot;x_ZD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:hiddenInside'></A><PRE id='Fold.hs:hiddenInside' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs
-- incorreta: seq é escondida pela aplicação de alguma_funcao desde 
-- algumaFuncao será avaliada primeiro, seq pode ocorrer muito tarde</code>
escondidaDentro x y = algumaFuncao (x `seq` y)

-- incorreta: a variação do erro acima
escondidaParaLet x y z = let a= x `seq` algumaFuncao y
                         in algumaOutraFuncao a z
<code class='codecomment'>-- correta: seq será avaliada primeiro, forçando avaliação de x</code>
emFora x y = x `seq` algumaFuncao y</PRE><SPAN id='comments_Fold.hs:hiddenInside' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:hiddenInside' pid='Fold.hs:hiddenInside' onclick='return loadComments(&quot;Fold.hs:hiddenInside&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_aD1'><A name='x_aD1'></A>Para estritamente avaliar vários valores, aplicações da cadeia de <CODE class='function'>seq</CODE> juntos.<SPAN id='comments_x_aD1' class='comment'><A class='commenttoggle' id='toggle_x_aD1' pid='x_aD1' onclick='return loadComments(&quot;x_aD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:chained'></A><PRE id='Fold.hs:chained' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
acorrentado x y z = x `seq` y `seq` algumaFuncao z</PRE><SPAN id='comments_Fold.hs:chained' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:chained' pid='Fold.hs:chained' onclick='return loadComments(&quot;Fold.hs:chained&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_bD1'><A name='x_bD1'></A>Um erro comum é tentar utilizar <CODE class='function'>seq</CODE> com duas expressões independentes.<SPAN id='comments_x_bD1' class='comment'><A class='commenttoggle' id='toggle_x_bD1' pid='x_bD1' onclick='return loadComments(&quot;x_bD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:badExpression'></A><PRE id='Fold.hs:badExpression' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
expressãoMau passo zero (x:xs) =
    seq (passo zero x)
        (expressãoMau passo (passo zero x) xs)</PRE><SPAN id='comments_Fold.hs:badExpression' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:badExpression' pid='Fold.hs:badExpression' onclick='return loadComments(&quot;Fold.hs:badExpression&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_cD1'><A name='x_cD1'></A>Aqui, a intenção aparente é o de avaliar estrita <CODE class='code'>step zero x</CODE>. Uma vez que a expressão é repetido no corpo da função, estritamente avaliar a primeira instância de que não terá nenhum efeito sobre o segundo. A utilização de <CODE class='literal'>let</CODE> partir da definição de  acima <CODE class='function'>foldl'</CODE> mostra como conseguir este efeito corretamente.<SPAN id='comments_x_cD1' class='comment'><A class='commenttoggle' id='toggle_x_cD1' pid='x_cD1' onclick='return loadComments(&quot;x_cD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_dD1'><A name='x_dD1'></A>Ao avaliar uma expressão, <CODE class='function'>seq</CODE> pára logo que se chega a um construtor. Para os tipos simples, como números, isso significa que irá avaliá-los completamente. tipos de dados algébricos são uma história diferente. Considere o valor <CODE class='code'>(1+2):(3+4):[]</CODE>. Se aplicarmos <CODE class='function'>seq</CODE> para isso, vai avaliar o thunk <CODE class='code'>(1+2)</CODE>. Uma vez que ele irá parar quando atingir o primeiro construtor <CODE class='code'>(:)</CODE>, ele não terá nenhum efeito sobre a conversão segundo. O mesmo é verdadeiro para tuplas: <CODE class='code'>seq ((1+2),(3+4)) True</CODE> não fará nada para o thunks dentro do par, uma vez que imediatamente bate construtor do par.<SPAN id='comments_x_dD1' class='comment'><A class='commenttoggle' id='toggle_x_dD1' pid='x_dD1' onclick='return loadComments(&quot;x_dD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_eD1'><A name='x_eD1'></A>Se necessário, podemos utilizar técnicas habituais de programação funcional para contornar essas limitações.<SPAN id='comments_x_eD1' class='comment'><A class='commenttoggle' id='toggle_x_eD1' pid='x_eD1' onclick='return loadComments(&quot;x_eD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><A name='Fold.hs:strictPair'></A><PRE id='Fold.hs:strictPair' class='programlisting'><code class='codecomment'>-- arquivo: ca04/Fold.hs</code>
parEstrito (a,b) = a `seq` b `seq` (a,b)

listaEstrita (x:xs) = x `seq` x : listaEstrita xs
listaEstrita []     = []</PRE><SPAN id='comments_Fold.hs:strictPair' class='comment'><A class='commenttoggle' id='toggle_Fold.hs:strictPair' pid='Fold.hs:strictPair' onclick='return loadComments(&quot;Fold.hs:strictPair&quot;)' href='comments: show / hide'>?? comments</A></SPAN><P id='x_fD1'><A name='x_fD1'></A>É importante compreender que a <CODE class='function'>seq</CODE> não é livre: ele tem que executar uma verificação em tempo de execução para ver se uma expressão foi avaliada. Use com moderação. Por exemplo, enquanto a nossa função <CODE class='function'>parEstrito</CODE> avalia o conteúdo de um par até o primeiro construtor, ele adiciona as despesas gerais da correspondência padrão, duas aplicações de <CODE class='function'>seq</CODE>, e da construção de uma nova tupla. Se fôssemos medir o seu desempenho no circuito interno de um referência, podemos encontrá-lo para tornar o programa lento.<SPAN id='comments_x_fD1' class='comment'><A class='commenttoggle' id='toggle_x_fD1' pid='x_fD1' onclick='return loadComments(&quot;x_fD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_gD1'><A name='x_gD1'></A>Além do seu custo de desempenho se em demasia, <CODE class='function'>seq</CODE> não é um milagre cura para todos os problemas de consumo de memória. Só porque você <SPAN class='emphasis'><EM>pode</EM></SPAN> avaliar algo estritamente não significa que você <SPAN class='emphasis'><EM>deve</EM></SPAN>. O uso descuidado do <CODE class='function'>seq</CODE> podem fazer nada; vazamentos mover espaço existente ao redor, ou introduzir novos vazamentos.<SPAN id='comments_x_gD1' class='comment'><A class='commenttoggle' id='toggle_x_gD1' pid='x_gD1' onclick='return loadComments(&quot;x_gD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P><P id='x_hD1'><A name='x_hD1'></A>Os melhores guias para se <CODE class='function'>seq</CODE> é necessário, e como ele funciona, são medidas de desempenho e perfil, a qual será abordada no <A class='xref' href='profiling-and-optimization.html' title='Chapter&nbsp;25,&nbsp;Profiling&nbsp;e&nbsp;ajuste&nbsp;de&nbsp;desempenho'>Chapter&nbsp;25, <I>Profiling e ajuste de desempenho</I></A>. A partir de uma base de medição empírica, você irá desenvolver um senso de confiança de quando <CODE class='function'>seq</CODE> é mais útil.<SPAN id='comments_x_hD1' class='comment'><A class='commenttoggle' id='toggle_x_hD1' pid='x_hD1' onclick='return loadComments(&quot;x_hD1&quot;)' href='comments: show / hide'>?? comments</A></SPAN></P></DIV></DIV>


<DIV class='footnotes'><BR><HR width='100' align='left'>
<DIV class='footnote'><P><SUP>[<A name='ftn.id591518' href='#id591518' class='para'>8</A>] </SUP>Infelizmente, não temos espaço para abordar esse desafio neste livro.</P></DIV><DIV class='footnote'><P><SUP>[<A name='ftn.id594951' href='#id594951' class='para'>9</A>] </SUP>A barra invertida foi escolhido por sua semelhança visual com a letra grega lambda, <CODE class='code'>λ</CODE>. Embora <SPAN class='application'>GHC</SPAN> pode aceitar a entrada Unicode, ele trata corretamente <CODE class='code'>λ</CODE> como uma letra, não como sinônimo de <CODE class='code'>\</CODE>.</P></DIV>
</DIV>


</DIV>


<DIV class='rwhfooter'><P><IMG src='support/figs/rss.png'> Quer ficar atualizado? Assine o feed comentário para <A id='chapterfeed' class='feed' href='http://book.realworldhaskell.org/feeds/comments/fp/'>este capítulo</A>, ou o <A class='feed' href='http://book.realworldhaskell.org/feeds/comments/'>livro inteiro</A>.</P><P>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart e John Goerzen. Esta obra está licenciada sob uma <A rel='license' href='http://creativecommons.org/licenses/by-nc/3.0/'>Creative Commons Attribution-Noncommercial 3.0 License</A>. Ícones por <A href='mailto:mattahan@gmail.com'>Paul Davey</A> aka <A href='http://mattahan.deviantart.com/'>Mattahan</A>. Tradução por Doralice de Araujo Chaves, Sergio Souza Costa, Nick Rudnick e <A href='http://www.google.com/'>Google Translate</A>.</P></DIV>
<DIV class='navfooter'><TABLE width='100%' summary='Navigation footer'><TBODY><TR><TD width='40%' align='left'><A accesskey='p' href='types-and-functions.html'>Anterior</A>&nbsp;</TD><TD width='20%' align='center'>&nbsp;</TD><TD width='40%' align='right'>&nbsp;<A accesskey='n' href='writing-a-library-working-with-json-data.html'>Próximo</A></TD></TR><TR><TD width='40%' align='left' valign='top'>Capítulo&nbsp;3.&nbsp;Definir os tipos, racionalizando as funções&nbsp;</TD><TD width='20%' align='center'><A accesskey='h' href='index.html'>Casa</A></TD><TD width='40%' align='right' valign='top'>&nbsp;Capítulo&nbsp;5.&nbsp;Escrever uma biblioteca: trabalhar com dados JSON</TD></TR></TBODY></TABLE></DIV>
<SCRIPT src='support/figs/urchin.js' type='text/javascript'></SCRIPT><SCRIPT type='text/javascript'>_uacct = 'UA-1805907-3'; urchinTracker();</SCRIPT></BODY></HTML>