<!DOCTYPE html>
<html lang="pt-br">
<head>
   <meta charset="utf-8"></meta>
	<title>Capítulo 1. Começando</title>
	<link rel="stylesheet" href="support/styles.css" type="text/css">
	
	</head>

	<body>

<header><h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2>
	
	<a accesskey="p" style="float:left" href="why-functional-programming-why-haskell_ptbr.html">Anterior</a>
	<a  href="getting-started.html" style="float:right">Próximo</a>
	<p style="text-align:center"><a accesskey="p"  href="index.html">Inicio</a></p>

	
	
<header>



		
<article id=whyfp>
	
<div class="titlepage"><div><div><h2 class="title">Capítulo 1. Começando</h2></div></div></div>

	<p>Enquanto lê os
primeiros capítulos deste livro, tenha em mente que iremos as vezes
apresentar alguns conceitos de modo restrito e simplificado. Haskell é
uma linguagem ampla, e apresentar todos os aspectos de um determinado
assunto de uma vez só pode atrapalhar o seu aprendizado. Como queremos
construir uma base sólida em Haskell, iremos expandir estas explicações
iniciais mais a frente.</p>


<h2 class="title" id="id1">Seu ambiente Haskell</h2>
	
	<p>
		Haskell é uma linguagem com muitas implementações, dos quais dois estão
		em ampla utilização. Hugs é um intérpretador que é usado principalmente
		para o ensino. Para aplicações reais, o Glasgow Haskell Compiler (GHC) é muito mais popular. Comparado com Hugs, GHCé mais adequado para o “trabalho real”:
		ele compila para código nativo, suporta a execução paralela e fornece
		ferramentas de análise de desempenho e de depuração. Por estas razões, GHC é a implementação Haskell que iremos utilizar ao longo deste livro.
	
	</p>
	
	<p>
	GHC tem três componentes principais.	
	</p>

	<ul type="disc">
      <li>
	<strong>ghc</strong> é um compilador otimizado que gera código nativo rápido.
		</li>
		<li>
		<strong>ghci</strong> é um intérpretador interativo e depurador.	
		</li>
		<li>
		<strong>runghc</strong> é um programa para a execução de programas Haskell como scripts, sem a necessidade de compilá-los em primeiro lugar.	
		</li>
	</ul>
	
	
	<div class="note">
		<p>Como nos referimos aos componentes do GHC<p>
		<p>Quando discutimos o sistema GHC como um todo, vamos nos referir a ele como GHC. Quando precisarmos falar de um comando específico, vamos falar ghc, ghci ou runghc pelo nome.</p>
		
	</div>

<p>
	Neste livro, vamos supor que você está usando pelo menos a versão 6.12.2 do <span class="application">GHC</span>, que foi lançado em 2010. Muitos dos nossos exemplos irá funcionar sem modificações em versões mais antigas. No entanto,
      <span class="emphasis"><em>recomendamos</em></span>
usar a versão mais recente disponível para sua plataforma. Se você
estiver usando Windows ou Mac OS X, você pode começar rápidamente e
facilmente usando um instalador pré-construído. Para obter uma cópia do
<span class="application">GHC</span> para essas plataformas, visite
      <a class="ulink" href="http://www.haskell.org/ghc/download.html" target="_top">a página de download do <span class="application">GHC</span></a>, e olhe na lista de pacotes binários e instaladores.	
</p>

<p>
	Muitas distribuições Linux, BSD Unix e outras variantes, tem disponível pacotes binários personalizado do GHC.
Como estes pacotes são construídos especificamente para cada ambiente,
eles são muito mais fáceis de instalar e de usar do que os pacotes
binários genéricos que estão disponíveis na página de download do GHC. Você pode encontrar uma lista de distribuições de custom-build GHC na página GHC <a class="ulink" href="http://www.haskell.org/ghc/distribution_packages.html" target="_top">pacotes de distribuição</a>.	
</p>

<p>
Para obter informações mais detalhadas sobre como instalar o <span class="application">GHC</span> em uma variedade de plataformas populares, nós fornecemos algumas instruções no <a class="xref" href="installing-ghc-and-haskell-libraries.html" title="Apêndice;Instalação de GHC e bibliotecas Haskell">Apêndice A, <i> Instalação de GHC e bibliotecas Haskell</i></a>. 	
</p>



<h2 class=“title” id=“id12”>Começando com ghci, o intérpretador</h2>

<p> 
	O interpretador interativo para GHC é um programa chamado <span class="command"><strong>ghci</strong></span>.
Nele nós podemos entrar e avaliar expressões Haskell, explorara os
módulos, e depurar o nosso código. Se você estiver familiarizado com o
Python e Ruby, <strong>ghci</strong>é algo semelhante ao
      <code class="filename">python</code> e <code class="filename">irb</code>, os intérpretadores interativos do Python e Ruby.
</p>


<div class="note">
	<p>O comando ghci tem um foco estreito<p>
	<p>	Nós normalmente não podemos copiar algum arquivo código de fonte Haskell e colá-lo em <strong>ghci</strong>.
	Isto não tem um efeito significativo na depuração pedaços de código,
	mas pode inicialmente ser surpreendente se você está acostumado, por
	exemplo, o interpretador Python interativo.</p>
	
</div>

<p> 
Em sistemas Unix-like, rodamos ghci como um comando em uma janela shell. No Windows, está disponível através do Menu Iniciar. Por exemplo, se você instalou usando o instalador do GHC no Windows XP, você deve ir para “Todos programas”, depois “GHC”; então você vai ver ghci na lista. (Veja a seção chamada "Windows".)
</p>

<p>
Quando rodamos ghci, ele exibe um banner de inicialização, seguido de um prompt Prelude>. Aqui, estamos mostrando a versão 6.12.2 em uma máquina Linux.
</p>

<pre id="id574609" class="screen"><code class="prompt">$</code> <strong class="userinput"><code>ghci</code></strong>
GHCi, version 6.12.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
<code class="prompt">Prelude&gt;</code>
</pre>

<p>
	A palavra <code class="code">Prelude</code> no prompt indica que <code class="classname">Prelude</code>,
	uma biblioteca padrão de funções úteis, está carregada e pronto para
	uso. Quando carregar outros módulos ou arquivos de origem, eles vão
	aparecer no prompt, também.
</p>

<div class="tip">
	<p> Obtendo ajuda</p>
	<p> Se você digitar <code class="code">:?</code> no prompt <strong>ghci</strong>
		ele irá imprimir uma detalhada mensagem de ajuda.</p>
</div>

	
	<p>
		O módulo <code class="classname">Prelude</code> é muitas vezes referida como “the standard prelude”, porque seu conteúdo é definido pelo padrão Haskell 98. Normalmente, ele é simplesmente reduzido à
	      “o prelude”.
	</p>

	<div class="note">
		<p>Sobre o prompt ghci<p>
		<p>	O prompt exibido pelo ghci muda freqüentemente, dependendo de quais módulos temos carregados. Que muitas vezes pode crescer o suficiente para deixar poco espaço visual e uma única linha para a nossa entrada</p>

		<p>
		Por questões de brevidade e coerência, ao longo deste livro, temos substituído o prompt padrão ghci pelo seguinte prompt <code class="code">ghci></code>	
		</p>
		<p>
		Se você quiser fazer isso, use a directiva<code class="code"> :set prompt</code> de ghci, como se segue.	
		</p>
		<pre id="id574731" class="screen"><code class="prompt">Prelude</code> <strong class="userinput"><code>:set prompt "ghci"</code></strong>
<code class="prompt">ghci></code></pre>
	</div>
	<p>
	O prelude está sempre implicitamente disponível, nós não precisamos de tomar quaisquer medidas para utilizar os tipos, valores ou funções que ele define. Para utilizar as definições de outros módulos, devemos carregá-los em ghci, utilizando o :module ou :m.	
	</p>
	
	<pre id="basics.ghci:module" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +Data.Ratio</code></strong>
	</pre>
	<p>
		Agora podemos usar as funcionalidades do módulo <code class="prompt">Data.Ratio</code>, que nos permite trabalhar com números racionais (frações)
	</p>
	
	



<h2 class=“title” id=“”>Interação básica: usando ghci como uma calculadora</h2>
<p>
Além de fornecer uma interface conveniente para testar fragmentos de código, ghci pode funcionar como uma calculadora de desktop facilmente acessível. Podemos facilmente exprimir qualquer operação na calculadora ghci e, como bônus, podemos acrescentar operações mais complexas quando nós nos tornamos mais familiarizado com Haskell. Mesmo utilizando o intérprete desta forma simples, ele pode ajudar-nos a tornar-se mais confortáveis com o modo que o Haskell funciona.
</p>



<h3 class="title" id="starting.calc.arithmetic">Aritméticas simples</h3>

<p>
Podemos começar imediatamente a entrar expressões, para ver o que ghci vai fazer com eles. Aritmética simples funciona de forma semelhante a linguagens como C e Python: nós escrevemos expressões na forma infixa onde o operador aparece entre os seus operandos.
</p>

<pre id="basics.ghci:arithmetic" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2 + 2</code></strong>
4
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>31337 * 101</code></strong>
3165037
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>7.0 / 2.0</code></strong>
3.5
</pre>

<p>
O estilo de escrever um infixo expressão é apenas uma conveniência: também podemos escrever uma expressão em forma de prefixo, onde o operador precede os seus argumentos. Para fazer isso, devemos colocar o operador em parênteses.
</p>

<pre id="basics.ghci:prefix" class="screen"><code class="prompt">ghciInicio; </code><strong class="userinput"><code>2 + 2</code></strong>
4
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>(+) 2 2</code></strong>
4
</pre>

<p>
Como as expressões acima implicam, ao Haskell ter uma noção de números inteiros e de ponto flutuante. Inteiros podem ser arbitrariamente grande. Aqui, (^) fornece exponenciação inteiro.
</p>

<pre id="basics.ghci:bignum" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>313 ^ 15</code></strong>
27112218957718876716220410905036741257
</pre>






<h3 class="title"  id=“”>Um equívoco aritmético: escrever números negativos</h3>
<p>
Haskell nos apresenta uma peculiaridade no modo como devemos escrever números: é muitas vezes necessário colocar um número negativo entre parênteses. Isto afeta-nos logo que ir além da simples expressões.
</p>

<p>
Vamos começar por escrever um número negativo.
</p>
<pre id="basics.ghci:neg.simple" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>-3</code></strong>
-3
</pre>

<p>
O - acima, é um operador unário. Em outras palavras, não escrevemos o número único “-3”; nós escrevemos o número “3”, e aplicado o operador - para ele. O operador - é apenas um operador unário do Haskell, e não podemos misturá-la com os operadores infixo.
</p>

<pre id="basics.ghci:neg.error" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2 + -3</code></strong>

&lt;interactive&gt;:1:0:
    precedence parsing error
        cannot mix `(+)' [infixl 6] and prefix `-' [infixl 6] in the same infix expression
</pre>

<p>
Se quisermos usar o menos unário perto de um operador infixo, devemos envolver a expressão que se aplica a entre parênteses.
</p>

<pre id="basics.ghci:neg.better" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2 + (-3)</code></strong>
-1
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>3 + (-(13 * 37))</code></strong>
-478
</pre>

<p>
Isso evita uma ambigüidade análise. Quando se aplica uma função em Haskell, nós escrevemos o nome da função, seguido do argumento, por exemplo, <code class="code">f 3</code>. Se não tivéssemos necessidade de envolver um número negativo entre parênteses, teríamos duas diferentes maneiras de ler profundamente <code class="code">f-3</code>: poderia ser “aplicada a função <code class="code">f</code> para o número <code class="code">-3</code>”, ou “subtrair o número <code class="code">3</code> de <code class="code">f</code>”
</p>

<p>
Na maioria das vezes, podemos omitir o espaço em branco (“blank” caracteres, como espaço e guia) de expressões e Haskell irá analisá-los à medida que se destina. Mas nem sempre. Aqui está uma expressão que funciona: 
</p>

<pre id="basics.ghci:whitespace.ok" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2*3</code></strong>
6
</pre>

<p>
E aqui está um caso que parece similar ao exemplo problemático de número negativo acima, mas a mensagem de erro resultante é diferente.
</p>

<pre id="basics.ghci:whitespace.eek" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2*-3</code></strong>

&lt;interactive&gt;:1:1: Not in scope: `*-'
</pre>
<p>
	Aqui, a aplicação Haskell está lendo *- como um único operador. Haskell nos permite definir novos operadores (um assunto que voltaremos mais tarde), mas não temos definido *-. Mais uma vez, uns poucos parênteses nos permite resolver este problema.
</p>

<pre id="basics.ghci:whitespace.whew" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2*(-3)</code></strong>
-6
</pre>

<p>
	Em comparação com outras linguagens, este tratamento incomum de números negativos pode parecer chato, mas representa um trade-off fundamentado. Haskell nos permite definir operadores novos a qualquer momento. O que não é um tipo de recurso de comun a linguagens, vamos ver bastante operadores definidos pelo usuário nos próximos capítulos. Os projetistas da linguagem decidiram aceitar uma sintaxe um pouco pesado para números negativos em troca deste poder expressivo
</p>





<h3 class="title"  id=“”>Lógica Booleana, operadores e comparações de valores
</h3>

		Os valores da lógica booleana em Haskell são
		<code class="literal">True</code> e <code class="literal">False</code>.
	A capitalização destes nomes é importante. A linguagem foi influenciada
	por C na definição dos operadores para valores booleanos: <code class="function">(&amp;&amp;)</code> é lógico “<span class="quote">e</span>”, e <code class="function">(||)</code>
		é lógico.
</p>

<pre id="basics.ghci:boolean" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>True &amp;&amp; False</code></strong>
False
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>False || True</code></strong>
True
</pre>

<p id="x_k1"><a name="x_k1"></a>
	Embora algumas linguagens de programação trate o número zero como sinônimo de <code class="literal">False</code>,
	Haskell não, nem considera que um valor diferente de zero deve ser <code class="literal">True</code>. 
	</p>

	<pre id="basics.ghci:boolean.bad" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>True &amp;&amp; 1</code></strong>

	&lt;interactive&gt;:1:8:
	    No instance for (Num Bool)
	      arising from the literal `1' at &lt;interactive&gt;:1:8
	    Possible fix: add an instance declaration for (Num Bool)
	    In the second argument of `(&amp;&amp;)', namely `1'
	    In the expression: True &amp;&amp; 1
	    In the definition of `it': it = True &amp;&amp; 1
	</pre>
	
	<p id="x_fM">
		Mais uma vez, somos confrontados com uma mensagem de erro substancial. Em resumo, diz-nos que o tipo Boolean, <span class="type">Bool</span>, não é um membro da família de tipos numéricos, <code class="code">Num</code>.  A mensagem de erro é bastante longa, pois <span class="command"><strong>ghci</strong></span>
	está a apontar a localização do problema, e sugerindo uma possível
	mudança que nós poderíamos fazer de modo que possa resolver o problema.
	</p>
	
	<p>
	Aqui está uma divisão mais detalhada da mensagem de erro.
	</p>
	
	<ul type="disc"><li><p id="x_wA1">
		“<code class="code">No instance for (Num Bool)</code>”
		    diz-nos que <strong>ghci</strong> está tentando tratar o valor numérico
		    <span class="type">1</span> como tendo um tipo <span class="type">Bool</span>, mas não conseguiu.
		   </p></li><li><p id="x_xA1"><a name="x_xA1"></a>
		    “<span class="quote"><code class="code">arising from the literal
			`1'</code></span>” indica que foi o nosso uso do número <code class="code">1</code> que causou o problema. 
			</p></li><li><p id="x_yA1"><a name="x_yA1"></a>
			“<span class="quote"><code class="code">In the definition of `it'</code></span>”
		    se refere a uma abreviação <span class="command"><strong>ghci</strong></span> que iremos rever em algumas páginas a frente. </p></li></ul>
		
			<div class="tip">
				<p> Permaneça sem medo diante das mensagens de erro</p>
				<p> Temos uma importante consideração a fazer aqui, que vamos repetir em todo o trecho inicial do livro. Se você tiver problemas ou mensagens de erro que você ainda não entender, não se desespere. No início, tudo que você precisa fazer é descobrir o suficiente para progredir em um problema. Como você adquirir experiência, será mais fácil de entender as partes das mensagens de erro que inicialmente parece obscuro.</p>
				<p>
					As várias mensagens de erro têm uma finalidade: eles realmente nos ajudar a escrever o código correto, fazendo-nos executar uma certa quantidade de depuração “a frente”, antes que nós executarmos um programa. Se você estiver vindo de um background de trabalho com linguagens mais permissivas, essa forma de trabalho pode vir como uma espécie de choque. 
					</p>
				</div>

<p>
	A maioria dos operadores de comparação Haskell são similares àqueles usados em C e muitas linguagens que foram influencidas
</p>

<pre id="basics.ghci:comparison" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>1 == 1</code></strong>
True
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>2 &lt; 3</code></strong>
True
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>4 &gt;= 3.99</code></strong>
True
</pre>

<p>
Um operador que difere de C é o “não é igual”. Em C, este é escrito como !=. Em Haskell, escrevemos (/=), que se assemelha a notação ≠ usada em matemática.
</p>

<pre id="basics.ghci:neq" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>2 /= 3</code></strong>
True
</pre>

<p>
Além disso, onde linguagens similares C costumam usar ! para a negação lógica, Haskell usa a função not.
</p>

<h3 class="title" id="starting.calc.precedence">Precedência de operadores e associatividade</h3>

<p>
Como em álgebra e outras linguagens de programação que usa operadores infixo, Haskell tem uma noção de precedência de operadores. Podemos usar parênteses para explicitamente agrupar partes de uma expressão, e a precedência nos permite omitir alguns parênteses. Por exemplo, o operador de multiplicação tem precedência maior do que o operador de adição, de modo que Haskell trata as seguinte expressões como equivalentes.
</p>

<pre id="basics.ghci:parens" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>1 + (4 * 4)</code></strong>
17
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>1 + 4 * 4</code></strong>
17
</pre>

<p>
Haskell atribui valores numéricos a precedência dos operadores, sendo 1 a menor precedência e 9 a maior. Um operador de prioridade maior é aplicada antes de um operador de prioridade inferior. Podemos usar ghci para inspecionar os níveis de precedência de operadores individuais, utilizando o seu comando :info ou :i.
</p>
<pre id="basics.ghci:precedence" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:i (+)</code></strong>
class (Eq a, Show a) =&gt; Num a where
  (+) :: a -&gt; a -&gt; a
  ...
  	-- Defined in GHC.Num
infixl 6 +
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:i (*)</code></strong>
class (Eq a, Show a) =&gt; Num a where
  ...
  (*) :: a -&gt; a -&gt; a
  ...
  	-- Defined in GHC.Num
infixl 7 *
</pre>


<p>
A informação que nós buscamos é na linha “infixl 6 +”, que indica que o (+) operador tem uma precedência de 6. (Nós vamos explicar a saída de outros em um capítulo posterior.) O “infixl 7 *” diz-nos que o (*) operador tem uma precedência de 7. Desde (*) tem uma precedência maior do que (+), podemos ver agora porque 1 + 4 * 4 é avaliado como 1 + (4 * 4), e não (1 + 4) * 4.
</p>

<p>
Haskell também define associatividade dos operadores. Isso determina se uma expressão contendo múltiplos usos de um operador é avaliada da esquerda para a direita ou para a direita para a esquerda. Os operadores (+) e (*) ficam associativos esquerdos, que é representado como infixl infixl na saída ghci acima. Um operador de direito associativo é exibida com infixr.
</p>

<p>
A combinação de regras de precedência e associatividade são geralmente referidos como as fixity rules.
</p>

<h3 class="title" id="starting.calc.undef">Valores indefinidos, e introduzindo variáveis</h3>

<p>
O prelude de Haskell, a biblioteca padrão mencionado anteriormente, define pelo menos um conhecido constante matemática para nós.
</p>

<pre id="basics.ghci:pi" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>pi</code></strong>
3.141592653589793
</pre>

<p>
Mas a sua abrangência de constantes matemáticas não é abrangente, como podemos ver rapidamente. Olhemos para o número de Euler, e. 
</p>

<pre id="basics.ghci:e" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>e</code></strong>

&lt;interactive&gt;:1:0: Not in scope: `e'
</pre>
<p>
Tudo bem. Nós temos que defini-lo nós mesmos.
</p>

<div class="note">
	<p>Não se preocupe com a mensagem de erro</p>
	<p>Se a mensagem de erro “not in scope” acima parece um pouco assustador, não se preocupe. Tudo isto significa é que não há nenhuma variável definida com o nome e.</p>
</div>


<p>
Usando a construção let de ghci, nós podemos fazer uma definição temporária e de nós mesmos.
</p>

<pre id="basics.ghci:let" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>let e = exp 1
	</code></strong>
</pre>

<p>
Esta é uma aplicação da função exponencial, exp, e nosso primeiro exemplo de aplicação de uma função em Haskell. Enquanto linguagens como Python exigem parênteses os argumentos para uma função, Haskell não.
</p>

<p>
Com <code class="varname">e</code> definido, agora podemos usá-lo em expressões aritméticas. O operador (^) de exponenciação que introduzimos anteriormente só pode elevar um número a uma potência inteira. Para usar um número de ponto flutuante como o expoente, usamos o operador de exponenciação (**). 
</p>

<div class="warning">
	<p>Essa sintaxe é específica do ghci</p>
	<p>A sintaxe para let que o ghci aceita não é o mesmo que iremos usar no alto nível "de um programa Haskell normal. Vamos ver a sintaxe normal na <a class="xref" href="defining-types-streamlining-functions.html#deftypes.locals" title="Introducing local variables"> seção chamada “Introduzir variáveis locais”</a></p>
</div>

<h3 class="title" id="id575887">Lidar com as regras de precedência e associatividade</h3>

<p>
Às vezes é melhor deixar pelo menos alguns parênteses no lugar, mesmo quando Haskell permite omitir-los. Sua presença pode ajudar os futuros leitores (incluindo nós mesmos) para entender o que se destina.
</p>


<p>
Ainda mais importante, expressões complexas que confiam totalmente na precedência do operador são fontes notórias de bugs. Um compilador e um ser humano pode facilmente acabar com noções diferentes do que até mesmo um parêntese, livre expressão curta é suposto fazer.
</p>

<p>
Não há necessidade de lembrar todas as regras de precedência e associatividade números: é mais simples de adicionar parênteses se tiver dúvidas.
</p>

<h2 class="title" style="clear: both;" id="starting.ghci.edit">Edição de linha de comando em ghci</h2>

<p>
	Na maioria dos sistemas, <strong>ghci</strong> tem uma certa quantidade capacidade de edição de linha de comando. 
	Caso você não esteja familiarizado com edição de linha de comando, é uma enorme economia de tempo. 
	Os princípios básicos são comuns a ambos Unix-like e Windows. Pressionando a tecla de seta para <strong>cima</strong> 
	no seu teclado recorda a última linha de entrada que você entrou; pressionando <strong>cima</strong>
	 repetidamente ciclos através de linhas
	 antes da entrada. Você pode usar as teclas <strong>esquerda</strong> e <strong>direita</strong> seta para se movimentar dentro de uma linha de entrada. 
	 Em Unix (mas não no Windows, infelizmente), a tecla de <strong>tabulação</strong> completa os identificadores parcialmente inseridos.
	
	</p>
	
	<div class="tip">
	<p>Onde procurar mais informações</p>
	<p>
Nós mal arranhamos a superfície de edição de linha de comando aqui.
Desde que você pode trabalhar com mais eficiência se você estiver mais
familiarizado com as capacidades do seu sistema de edição de linha de
comando, você pode achar útil fazer algumas leituras complementares. </p>
	<p>
	
Em sistemas Unix-like, ghci usa a <a class="ulink" href="http://tiswww.case.edu/php/chet/readline/rltop.html#Documentation" target="_top">biblioteca GNU readline </a>, que é poderoso e personalizável. 
No Windows, a capacidade do ghci de edição de linha de comando são fornecidas pelo  <a class="ulink" href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx" target="_top">comando <span class="command"><strong>doskey</strong></span></a>.	
	</p>
</div>
	
	<h2>Listas</h2>
	<p>
A lista é definida entre colchetes, os elementos são separados por vírgulas:	
	</p>
	
	<pre id="basics.ghci:list" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1, 2, 3]</code></strong>
[1,2,3]
</pre>

<div class="warning">
<p>Vírgulas são separadores, não terminadores</p>
<p>Algumas linguagens permitem o último elemento de uma lista seja seguido por uma vírgula à direita opcional 
antes de um parêntese de fecho, mas Haskell não permite isso. Se você deixar uma vírgula no final
 (por exemplo, [1,2,]), ), você receberá um erro de análise</p>

</div>

<p>A lista pode ser de qualquer tamanho. Uma lista vazia é escrita []</p>.

<pre id="basics.ghci:list.shortlong" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[]</code></strong>
[]
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>["foo", "bar", "baz", "quux", "fnord", "xyzzy"]</code></strong>
["foo","bar","baz","quux","fnord","xyzzy"]
</pre>

<p>Todos os elementos de uma lista devem ser do mesmo tipo. Aqui, violamos esta regra: a nossa lista começa com dois valores 
Bool mas termina com um string.</p>

<pre id="basics.ghci:list.bad" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[True, False, "teste"]</code></strong>

&lt;interactive&gt;:1:14:
    Couldn't match expected type `Bool' against inferred type `[Char]'
      Expected type: Bool
      Inferred type: [Char]
    In the expression: "teste"
    In the expression: [True, False, "teste"]
</pre>

<p>Mais uma vez, é uma mensagem de erro <strong>ghci</strong> detalhada, mas ela simplesmente diz que não
 há maneira de transformar a string em um valor booleano,
 então a expressão lista não está corretamente digitado.
				</p>


<p>Se nós escrevemos uma série de elementos usando a notação de enumeração, Haskell irá preencher o
 conteúdo da lista para nós.</p>
 
 <pre id="basics.ghci:range" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1..10]</code></strong>
[1,2,3,4,5,6,7,8,9,10]
</pre>

<p>Aqui, os .. caracteres denotam uma enumeração. Só podemos usar esta notação para os tipos cujos elementos, 
podemos enumerar. Não faz sentido para cadeias de texto, por exemplo: não há qualquer sensível,
 forma geral, para enumerar <code>["foo".."quux"].</code></p>
 
 
<p> De qualquer modo, observe que a utilização acima de notação intervalo nos dá um intervalo fechado; 
 a lista contém os dois pontos finais.</p>

<p>Quando escrevemos uma enumeração, podemos, opcionalmente, especificar o tamanho do passo para utilização,
 fornecendo os primeiros dois elementos, seguido pelo valor em que parar de gerar a enumeração.</p>
 
 <pre id="basics.ghci:range.step" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1.0,1.25..2.0]</code></strong>
[1.0,1.25,1.5,1.75,2.0]
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1,4..15]</code></strong>
[1,4,7,10,13]
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>[10,9..1]</code></strong>
[10,9,8,7,6,5,4,3,2,1]
</pre>

<p>Neste último caso acima, a lista é quase sensata faltando o ponto final da contagem, porque 
não é um elemento da série que nós definimos.</p> 

<p>Nós podemos omitir o ponto final de uma enumeração. Se um tipo não tem um natural “limite superior”,
 isso vai produzir valores indefinidamente. Por exemplo, se você digitar [1..] no prompt ghci você terá
  que interromper ou matar ghci para parar de imprimir uma sucessão infinita de números cada vez maiores. 
  Se você está tentado a fazer isso, tecle Ctrl-C para interromper a contagem. Nós vamos encontrar mais tarde 
  que as listas infinitas são frequentemente útil no Haskell.</p>
  
  <div class="warning">
  
  <p>Cuidado ao enumerar números de ponto flutuante
Aqui está um pouco não-intuitivo.</p>

<pre id="basics.ghci:range.double" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1.0..1.8]</code></strong>
[1.0,2.0]
</pre>

<p>Nos bastidores, para evitar problemas de arredondamento em ponto flutuante, o 
Haskell implementa a enumeração de <code>1.0 </code>a <code>1.8+0.5. 12</code>.</p>

<p>Usando a notação de enumeração sobre números de ponto flutuante pode pegar mais algumas surpresas, 
por isso, se você usá-lo, seja cuidadoso. Comportamento de ponto flutuante é peculiar em 
todas as linguagens de programação, não há nada exclusivo para Haskell aqui.</p>
  
  </div>
  
  <h3 class="title" id="starting.list.op">Operadores em listas</h3>
  
 <p> Existem dois operadores onipresente para trabalhar com listas. Nós concatenamos duas listas com o operador<code> (++)</code>.
</p>

<pre id="basics.ghci:concat" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[3,1,3] ++ [3,7]</code></strong>
[3,1,3,3,7]
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>[] ++ [False,True] ++ [True]</code></strong>
[False,True,True]
</pre>

<p>O mais básico operador é o (:), que acrescenta um elemento para a frente de uma lista. 
Esta é pronunciado como “cons” (abreviação de “construção”). </p>


<pre id="basics.ghci:cons" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>1 : [2,3]</code></strong>
[1,2,3]
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>1 : []</code></strong>
[1]
</pre>

<p>Você pode estar tentado a tentar escrever [<code>1,2]:3</code> para adicionar um elemento ao final de uma lista, 
mas o ghci irá rejeitar-lo com uma 
mensagem de erro, porque o primeiro argumento <code>(:) </code>deve ser um elemento, e o segundo deve ser uma lista.</p>




<h2 class="title" style="clear: both;" id="starting.string">Strings e caracteres</h2>


<p>Se você conhece uma linguagem como Perl ou C, você vai achar as anotações Haskell para strings familiar.</p> 

<p>Uma cadeia de caracteres é cercada por aspas duplas.</p>

<pre id="basics.ghci:string" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>"Esta é uma string."</code></strong>
"Esta é uma string."
</pre>


<p>Como em muitas linguagens, podemos representar caracteres hard-to-see através de “escaping” delas. 
Escapes in Haskell e as regras de escaping segue as convenções utilizadas e amplamente estabelecida pela linguagem C.
 Por exemplo, <code>'\n' </code>denota um caractere de nova linha, e <code>'\t'</code> é um caracter de tabulação. Para detalhes completos, 
 consulte <a class="xref" href="characters-strings-and-escaping-rules.html" title="Apêndice&nbsp;B.&nbsp;Caracteres, strings, e regras escapando">Apêndice B, <i>Caracteres, strings, e regras escapando</i></a></p>


<pre id="basics.ghci:newline" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>putStrLn "Aqui está uma nova linha --&gt;\n&lt;-- Viu?"</code></strong>
Aqui está uma nova linha --&gt;
&lt;-- Viu?
</pre>

<p>O função putStrLn imprime uma string. </p>

<p>Haskell faz uma distinção entre um único caracter e cadeias de caracteres. Um único caractere é colocado entre aspas simples.</p>

<pre id="basics.ghci:char" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>'a'</code></strong>
'a'
</pre>

<p>De fato, uma cadeia de texto é simplesmente uma lista de caracteres individuais. 
Aqui está uma maneira dolorosa para escrever uma string curta, que ghci devolve-nos de uma forma mais familiar.</p>

<pre id="basics.ghci:work" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>let a = ['m', 'u', 'i', 't', 'o', ' ', 't', 'r', 'a', 'b', 'a', 'l', 'h', 'o']</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>a</code></strong>
"muito trabalho"
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>a == "muito trabalho"</code></strong>
True
</pre>

<p>A cadeia vazia é escrito "", e é um sinônimo para [].</p>

<pre id="basics.ghci:emptystring" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>"" == []</code></strong>
True
</pre>

<p>Desde uma string é uma lista de caracteres, podemos utilizar os operadores de lista regulares para 
a construção de novas cadeias.</p>

<pre id="basics.ghci:newstring" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>'a':"bc"</code></strong>
"abc"
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>"foo" ++ "bar"</code></strong>
"foobar"
</pre>

<h2 class="title" style="clear: both;" id="starting.types">Primeiros passos com os tipos</h2>


<p>Enquanto nós ja falamos um pouco sobre os tipos, nossas interações com ghci têm sido até agora 
livre de pensamento do tipo. Nós não disse que tipos em ghci que nós vimos utilizando, e é na sua maioria, 
dispostos a aceitar a nossa entrada. </p>

<p>Haskell exige que nomes de tipo inicie com uma letra maiúscula e nomes de variáveis
 devem começar com uma letra minúscula. Tenha isso em mente sobre como você lê, 
 que torna muito mais fácil seguir os nomes. </p>

<p>A primeira coisa que podemos fazer para começar a explorar o mundo de tipos é pedir 
ao <strong>ghci</strong> para nos dizer mais sobre o que ele é usandondo um comando <strong>ghci</strong>, <code>:set</code> ou <code>:s,</code> que 
nos permite alterar alguns dos seus comportamentos padrão. Podemos pedir que imprima 
mais informações sobre tipo, como a seguir.</p>


<pre id="types.ghci:set_t_on" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:s +t</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>'c'</code></strong>
'c'
it :: Char
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>"foo"</code></strong>
"foo"
it :: [Char]
</pre>

O que <code>+t</code> faz é dizer ghci para imprimir o tipo de expressão após a expressão. 
O enigmático <code>it </code>na saída pode ser muito útil: ele é realmente o nome de uma variável especial, 
que armazena no <strong>ghci</strong> o resultado da última expressão avaliada. (Esta não é uma característica da
 linguagem Haskell, é específico para <strong>ghci</strong>.) Vamos quebrar o significado da última linha de saída <strong>ghci</strong>.

<ul type="disc">
      <li>
 <p>     Ele está nos dizendo sobre a variável especial <code class="varname">it</code>. 
 </p>   </li>
	  <li>
	  
	<p>  Podemos ler o texto da forma <code class="code">x :: y</code> no sentido de “a expressão <code class="code">x</code> com o tipo <code class="code">y</code>”. 
	</p>  </li>
	    <li>
	   <p> Aqui, a expressão “it” tem o tipo <span class="type">[Char]</span>.  (O nome <span class="type">String</span> é frequentemente utilizado em vez de <span class="type">[Char]</span>. É simplesmente um sinônimo para <span class="type">[Char]</span>.) 
	 </p>
	    </li></ul>
	    
</article>

<footer> 
<p>Copyright
	2007, 2008 Bryan O'Sullivan, Don Stewart, and John Goerzen. This
	work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
	  Commons Attribution-Noncommercial 3.0 License</a>. Icons by
	  <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.</p>
	
	<div class="navfooter"><table width="100%" summary="Navigation footer"><tbody><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Anterior</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="getting-started.html">Próximo</a></td></tr><tr><td width="40%" align="left" valign="top">Real World Haskell&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;1.&nbsp;Getting Started</td></tr></tbody></table></div>
	
  </footer>




</body>	
</html>
